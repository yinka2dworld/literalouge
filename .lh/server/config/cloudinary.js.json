{
    "sourceFile": "server/config/cloudinary.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 3,
            "patches": [
                {
                    "date": 1740285392426,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1740285420954,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -68,9 +68,9 @@\n   }\r\n };\r\n \r\n \r\n-const uploadToLocalStorage = async (upload) => {\r\n+expoconst uploadToLocalStorage = async (upload) => {\r\n   const { createReadStream, filename, mimetype } = await upload;\r\n   const stream = createReadStream();\r\n   const uniqueFilename = uuidv4() + '-' + Date.now() + path.extname(filename);\r\n   const filepath = path.join(__dirname, 'books', uniqueFilename);\r\n"
                },
                {
                    "date": 1740285635046,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,11 +1,14 @@\n import { v2 as cloudinary } from 'cloudinary'\r\n import dotenv from 'dotenv';\r\n import { tokenChecker } from \"../middleware/auth.js\";\r\n+import { finished } from 'stream/promises';\r\n+import fs from 'fs';\r\n+import path from 'path';\r\n+import { v4 as uuidv4 } from 'uuid';\r\n \r\n \r\n \r\n-\r\n dotenv.config();\r\n \r\n cloudinary.config({\r\n     cloud_name: process.env.CLOUD_NAME,\r\n"
                },
                {
                    "date": 1740285857147,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,125 @@\n+import { v2 as cloudinary } from 'cloudinary'\r\n+import dotenv from 'dotenv';\r\n+import { tokenChecker } from \"../middleware/auth.js\";\r\n+import { finished } from 'stream/promises';\r\n+import fs from 'fs';\r\n+import path from 'path';\r\n+import { v4 as uuidv4 } from 'uuid';\r\n+import { fileURLToPath } from 'url';\r\n+import path from 'path';\r\n+\r\n+const __filename = fileURLToPath(import.meta.url);\r\n+const __dirname = path.dirname(__filename);\r\n+\r\n+\r\n+\r\n+dotenv.config();\r\n+\r\n+cloudinary.config({\r\n+    cloud_name: process.env.CLOUD_NAME,\r\n+    api_key: process.env.API_KEY,\r\n+    api_secret:process.env.SECRET_KEY,\r\n+    secure: true,\r\n+})\r\n+\r\n+ \r\n+export const applyTokenChecker = (resolver, isExcluded = false) => {\r\n+  return (parent, args, context, info) => {\r\n+      if (!isExcluded) {\r\n+          tokenChecker(context.req, context.res, () => {\r\n+              return resolver(parent, args, context, info);\r\n+          });\r\n+      } else {\r\n+          return resolver(parent, args, context, info);\r\n+      }\r\n+  };\r\n+};\r\n+\r\n+export const uploadToCloudinary = async (file) => {\r\n+  try {\r\n+    const { createReadStream, filename, mimetype } = await file;\r\n+    const fileExtension = filename.split('.').pop();\r\n+    const originalFileName = filename.replace(`.${fileExtension}`, '');\r\n+    \r\n+    let resourceType;\r\n+    if (mimetype.startsWith('image')) {\r\n+      resourceType = 'image';\r\n+    } else if (mimetype === 'application/pdf') {\r\n+      resourceType = 'raw'; \r\n+    } else {\r\n+      throw new Error(`Unsupported file type: ${mimetype}`);\r\n+    }\r\n+    \r\n+    const publicId = originalFileName;\r\n+\r\n+    return new Promise((resolve, reject) => {\r\n+      const stream = createReadStream();\r\n+      const cloudinaryStream = cloudinary.uploader.upload_stream(\r\n+        {\r\n+          folder: 'literalouge',\r\n+          resource_type: resourceType,\r\n+          public_id: publicId,\r\n+        },\r\n+        (error, result) => {\r\n+          if (error) {\r\n+            console.error(`Cloudinary upload error for file ${filename}:`, error);\r\n+            return reject(new Error(`Cloudinary upload failed for ${filename}: ${error.message}`));\r\n+          }\r\n+          console.log(`File ${filename} uploaded successfully. Secure URL:`, result.secure_url);\r\n+          resolve(result.secure_url);\r\n+        }\r\n+      );\r\n+      stream.pipe(cloudinaryStream);\r\n+    });\r\n+  } catch (err) {\r\n+    console.error('Error in file upload process:', err);\r\n+    throw new Error('File upload process failed');\r\n+  }\r\n+};\r\n+\r\n+\r\n+export const uploadToLocalStorage = async (upload) => {\r\n+  const { createReadStream, filename, mimetype } = await upload;\r\n+  const stream = createReadStream();\r\n+  const uniqueFilename = uuidv4() + '-' + Date.now() + path.extname(filename);\r\n+  const filepath = path.join(__dirname, 'books', uniqueFilename);\r\n+  \r\n+  // Pipe the file to a local destination\r\n+  const out = fs.createWriteStream(filepath);\r\n+  stream.pipe(out);\r\n+  await finished(out); // Wait for the stream to finish\r\n+\r\n+  return filepath; // Return the path or URL as needed\r\n+};\r\n+\r\n+export const deleteOldFileFromCloudinary = async (publicId) => {\r\n+  if (!publicId) {\r\n+    throw new Error('No public ID provided.');\r\n+  }\r\n+  try {\r\n+    console.log(`Attempting to delete file with public ID: ${publicId}`); \r\n+    const fileDeleter = await cloudinary.uploader.destroy(publicId);\r\n+    console.log('Cloudinary result for deletion:', result);\r\n+\r\n+    if (fileDeleter.result === 'ok') {\r\n+      console.log(`Cloudinary file with public ID ${publicId} deleted successfully.`);\r\n+    } else {\r\n+      throw new Error(`Failed to delete the file from Cloudinary. Response: ${JSON.stringify(result)}`);\r\n+    }\r\n+  } catch (error) {\r\n+    console.error(`Error deleting file from Cloudinary with public ID ${publicId}:`, error.message);\r\n+    throw new Error(`Cloudinary deletion error: ${error.message}`);\r\n+  }\r\n+};\r\n+\r\n+\r\n+export const extractPublicId = (url) => {\r\n+  console.log(`Extracting public ID from URL: ${url}`);\r\n+  const match = url.match(/\\/([^/]+)\\.(jpg|jpeg|png|gif|pdf|mp3)$/);\r\n+  if (match) {\r\n+    console.log(`Extracted public ID: ${match[1]}`);\r\n+    return match[1];\r\n+  }\r\n+  console.warn('Failed to extract public ID from URL.');\r\n+  return null;\r\n+};\r\n"
                }
            ],
            "date": 1740285392426,
            "name": "Commit-0",
            "content": "import { v2 as cloudinary } from 'cloudinary'\r\nimport dotenv from 'dotenv';\r\nimport { tokenChecker } from \"../middleware/auth.js\";\r\n\r\n\r\n\r\ndotenv.config();\r\n\r\ncloudinary.config({\r\n    cloud_name: process.env.CLOUD_NAME,\r\n    api_key: process.env.API_KEY,\r\n    api_secret:process.env.SECRET_KEY,\r\n    secure: true,\r\n})\r\n\r\n \r\nexport const applyTokenChecker = (resolver, isExcluded = false) => {\r\n  return (parent, args, context, info) => {\r\n      if (!isExcluded) {\r\n          tokenChecker(context.req, context.res, () => {\r\n              return resolver(parent, args, context, info);\r\n          });\r\n      } else {\r\n          return resolver(parent, args, context, info);\r\n      }\r\n  };\r\n};\r\n\r\nexport const uploadToCloudinary = async (file) => {\r\n  try {\r\n    const { createReadStream, filename, mimetype } = await file;\r\n    const fileExtension = filename.split('.').pop();\r\n    const originalFileName = filename.replace(`.${fileExtension}`, '');\r\n    \r\n    let resourceType;\r\n    if (mimetype.startsWith('image')) {\r\n      resourceType = 'image';\r\n    } else if (mimetype === 'application/pdf') {\r\n      resourceType = 'raw'; \r\n    } else {\r\n      throw new Error(`Unsupported file type: ${mimetype}`);\r\n    }\r\n    \r\n    const publicId = originalFileName;\r\n\r\n    return new Promise((resolve, reject) => {\r\n      const stream = createReadStream();\r\n      const cloudinaryStream = cloudinary.uploader.upload_stream(\r\n        {\r\n          folder: 'literalouge',\r\n          resource_type: resourceType,\r\n          public_id: publicId,\r\n        },\r\n        (error, result) => {\r\n          if (error) {\r\n            console.error(`Cloudinary upload error for file ${filename}:`, error);\r\n            return reject(new Error(`Cloudinary upload failed for ${filename}: ${error.message}`));\r\n          }\r\n          console.log(`File ${filename} uploaded successfully. Secure URL:`, result.secure_url);\r\n          resolve(result.secure_url);\r\n        }\r\n      );\r\n      stream.pipe(cloudinaryStream);\r\n    });\r\n  } catch (err) {\r\n    console.error('Error in file upload process:', err);\r\n    throw new Error('File upload process failed');\r\n  }\r\n};\r\n\r\n\r\nconst uploadToLocalStorage = async (upload) => {\r\n  const { createReadStream, filename, mimetype } = await upload;\r\n  const stream = createReadStream();\r\n  const uniqueFilename = uuidv4() + '-' + Date.now() + path.extname(filename);\r\n  const filepath = path.join(__dirname, 'books', uniqueFilename);\r\n  \r\n  // Pipe the file to a local destination\r\n  const out = fs.createWriteStream(filepath);\r\n  stream.pipe(out);\r\n  await finished(out); // Wait for the stream to finish\r\n\r\n  return filepath; // Return the path or URL as needed\r\n};\r\n\r\nexport const deleteOldFileFromCloudinary = async (publicId) => {\r\n  if (!publicId) {\r\n    throw new Error('No public ID provided.');\r\n  }\r\n  try {\r\n    console.log(`Attempting to delete file with public ID: ${publicId}`); \r\n    const fileDeleter = await cloudinary.uploader.destroy(publicId);\r\n    console.log('Cloudinary result for deletion:', result);\r\n\r\n    if (fileDeleter.result === 'ok') {\r\n      console.log(`Cloudinary file with public ID ${publicId} deleted successfully.`);\r\n    } else {\r\n      throw new Error(`Failed to delete the file from Cloudinary. Response: ${JSON.stringify(result)}`);\r\n    }\r\n  } catch (error) {\r\n    console.error(`Error deleting file from Cloudinary with public ID ${publicId}:`, error.message);\r\n    throw new Error(`Cloudinary deletion error: ${error.message}`);\r\n  }\r\n};\r\n\r\n\r\nexport const extractPublicId = (url) => {\r\n  console.log(`Extracting public ID from URL: ${url}`);\r\n  const match = url.match(/\\/([^/]+)\\.(jpg|jpeg|png|gif|pdf|mp3)$/);\r\n  if (match) {\r\n    console.log(`Extracted public ID: ${match[1]}`);\r\n    return match[1];\r\n  }\r\n  console.warn('Failed to extract public ID from URL.');\r\n  return null;\r\n};\r\n"
        }
    ]
}