{
    "sourceFile": "server/config/upload.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 31,
            "patches": [
                {
                    "date": 1740473351490,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1740473503930,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -56,9 +56,9 @@\n  * There is an API endpoint for file removal (https://uploadcare.com/api-refs/upload-api/#remove-file),\r\n  * but it requires additional authentication and is often managed via your account settings.\r\n  *\r\n  * If you need to remove a file via API, see:\r\n- * https://uploadcare.com/docs/api_reference/console/#/files-delete-file\r\n+ * c\r\n  *\r\n  * For demonstration, here is a basic deletion function using node-fetch.\r\n  */\r\n export const deleteFileFromUploadcare = async (uuid) => {\r\n"
                },
                {
                    "date": 1740473691307,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,94 +0,0 @@\n-import dotenv from 'dotenv';\r\n-import fs from 'fs';\r\n-import fetch from 'node-fetch';\r\n-import FormData from 'form-data';\r\n-\r\n-dotenv.config();\r\n-\r\n-const PUBLIC_KEY = process.env.UPLOADCARE_PUBLIC_KEY;\r\n-const SECRET_KEY = process.env.UPLOADCARE_SECRET_KEY;\r\n-\r\n-// Function to upload file to Uploadcare\r\n-export const uploadToUploadcare = async (file) => {\r\n-  try {\r\n-    // Destructure file properties from your file object\r\n-    const { createReadStream, filename, mimetype } = await file;\r\n-    const fileExtension = filename.split('.').pop();\r\n-    const originalFileName = filename.replace(`.${fileExtension}`, '');\r\n-\r\n-    // Create a FormData instance\r\n-    const form = new FormData();\r\n-    form.append('UPLOADCARE_PUB_KEY', PUBLIC_KEY);\r\n-    form.append('UPLOADCARE_STORE', 'auto'); // auto, yes, or no depending on your needs\r\n-\r\n-    // Append file stream. Note: Uploadcare accepts any file type.\r\n-    // We donâ€™t need to specify a resource type like Cloudinary.\r\n-    form.append('file', createReadStream(), { filename });\r\n-\r\n-    // Upload endpoint (base)\r\n-    const uploadUrl = 'https://upload.uploadcare.com/base/';\r\n-\r\n-    const response = await fetch(uploadUrl, {\r\n-      method: 'POST',\r\n-      body: form,\r\n-    });\r\n-\r\n-    const result = await response.json();\r\n-\r\n-    if (!response.ok) {\r\n-      console.error(`Uploadcare error for file ${filename}:`, result);\r\n-      throw new Error(`Uploadcare upload failed for ${filename}: ${JSON.stringify(result)}`);\r\n-    }\r\n-\r\n-    console.log(`File ${filename} uploaded successfully. File UUID:`, result.file);\r\n-    // You can construct the CDN URL as follows:\r\n-    const cdnUrl = `https://ucarecdn.com/${result.file}/`;\r\n-    return cdnUrl;\r\n-  } catch (err) {\r\n-    console.error('Error in file upload process:', err);\r\n-    throw new Error('File upload process failed');\r\n-  }\r\n-};\r\n-\r\n-/**\r\n- * NOTE: Uploadcare does not provide a simple file deletion API similar to Cloudinary's destroy.\r\n- * To \"delete\" a file, you typically need to remove it from your storage in the Uploadcare dashboard.\r\n- * There is an API endpoint for file removal (https://uploadcare.com/api-refs/upload-api/#remove-file),\r\n- * but it requires additional authentication and is often managed via your account settings.\r\n- *\r\n- * If you need to remove a file via API, see:\r\n- * c\r\n- *\r\n- * For demonstration, here is a basic deletion function using node-fetch.\r\n- */\r\n-export const deleteFileFromUploadcare = async (uuid) => {\r\n-  if (!uuid) {\r\n-    throw new Error('No file UUID provided.');\r\n-  }\r\n-\r\n-  // Build deletion URL:\r\n-  const deletionUrl = `https://api.uploadcare.com/files/${uuid}/`;\r\n-\r\n-  try {\r\n-    const response = await fetch(deletionUrl, {\r\n-      method: 'DELETE',\r\n-      headers: {\r\n-        'Accept': 'application/vnd.uploadcare-v0.6+json',\r\n-        'Authorization': `Uploadcare.Simple ${PUBLIC_KEY}:${SECRET_KEY}`,\r\n-      },\r\n-    });\r\n-\r\n-    const result = await response.json();\r\n-\r\n-    if (!response.ok) {\r\n-      console.error(`Error deleting file with UUID ${uuid}:`, result);\r\n-      throw new Error(`Uploadcare deletion failed for UUID ${uuid}: ${JSON.stringify(result)}`);\r\n-    }\r\n-\r\n-    console.log(`File with UUID ${uuid} deleted successfully.`, result);\r\n-    return result;\r\n-  } catch (error) {\r\n-    console.error(`Error deleting file with UUID ${uuid}:`, error.message);\r\n-    throw new Error(`Uploadcare deletion error: ${error.message}`);\r\n-  }\r\n-};\r\n\\ No newline at end of file\n"
                },
                {
                    "date": 1740473708443,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,87 @@\n+import dotenv from 'dotenv';\r\n+import fetch from 'node-fetch';\r\n+import FormData from 'form-data';\r\n+\r\n+dotenv.config();\r\n+\r\n+const PUBLIC_KEY = process.env.PUBLIC_KEY;\r\n+const SECRET_KEY = process.env.UPLOADCARE_SECRET_KEY;\r\n+\r\n+/**\r\n+ * Upload a file to Uploadcare.\r\n+ *\r\n+ * @param {object} file - An object containing:\r\n+ *   - createReadStream: a function that returns a readable stream\r\n+ *   - filename: the name of the file\r\n+ *   - mimetype: the file's MIME type (not used in this example, but you can validate)\r\n+ * @returns {Promise<string>} - Resolves with the CDN URL of the uploaded file.\r\n+ */\r\n+export const uploadToUploadcare = async (file) => {\r\n+  try {\r\n+    const { createReadStream, filename } = await file;\r\n+    const form = new FormData();\r\n+\r\n+    // Required fields\r\n+    form.append('UPLOADCARE_PUB_KEY', PUBLIC_KEY);\r\n+    form.append('UPLOADCARE_STORE', 'auto'); // or 'yes' if you want to store immediately\r\n+    form.append('file', createReadStream(), { filename });\r\n+\r\n+    const uploadUrl = 'https://upload.uploadcare.com/base/';\r\n+\r\n+    const response = await fetch(uploadUrl, {\r\n+      method: 'POST',\r\n+      body: form,\r\n+    });\r\n+\r\n+    const result = await response.json();\r\n+\r\n+    if (!response.ok) {\r\n+      throw new Error(`Uploadcare upload failed: ${JSON.stringify(result)}`);\r\n+    }\r\n+\r\n+    // result.file contains the UUID of the uploaded file\r\n+    const cdnUrl = `https://ucarecdn.com/${result.file}/`;\r\n+    console.log(`File ${filename} uploaded successfully. CDN URL: ${cdnUrl}`);\r\n+    return cdnUrl;\r\n+  } catch (err) {\r\n+    console.error('Error uploading file to Uploadcare:', err);\r\n+    throw new Error('File upload process failed');\r\n+  }\r\n+};\r\n+\r\n+/**\r\n+ * Delete a file from Uploadcare using its UUID.\r\n+ *\r\n+ * @param {string} uuid - The UUID of the file to delete.\r\n+ * @returns {Promise<object>} - Resolves with the deletion result.\r\n+ */\r\n+export const deleteFileFromUploadcare = async (uuid) => {\r\n+  if (!uuid) {\r\n+    throw new Error('No file UUID provided.');\r\n+  }\r\n+\r\n+  const deletionUrl = `https://api.uploadcare.com/files/${uuid}/`;\r\n+\r\n+  try {\r\n+    const response = await fetch(deletionUrl, {\r\n+      method: 'DELETE',\r\n+      headers: {\r\n+        'Accept': 'application/vnd.uploadcare-v0.6+json',\r\n+        // Uploadcare.Simple authentication: \"Uploadcare.Simple <public_key>:<secret_key>\"\r\n+        'Authorization': `Uploadcare.Simple ${PUBLIC_KEY}:${SECRET_KEY}`,\r\n+      },\r\n+    });\r\n+\r\n+    const result = await response.json();\r\n+\r\n+    if (!response.ok) {\r\n+      throw new Error(`Uploadcare deletion failed: ${JSON.stringify(result)}`);\r\n+    }\r\n+\r\n+    console.log(`File with UUID ${uuid} deleted successfully.`);\r\n+    return result;\r\n+  } catch (error) {\r\n+    console.error(`Error deleting file with UUID ${uuid}:`, error);\r\n+    throw new Error(`Uploadcare deletion error: ${error.message}`);\r\n+  }\r\n+};\r\n"
                },
                {
                    "date": 1740473714891,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,87 @@\n+import dotenv from 'dotenv';\r\n+import fetch from 'node-fetch';\r\n+import FormData from 'form-data';\r\n+\r\n+dotenv.config();\r\n+\r\n+const PUBLIC_KEY = process.env.PUBLIC_KEY;\r\n+const SECRET_KEY = process.env.UPLOADCARE_SECRET_KEY;\r\n+\r\n+/**\r\n+ * Upload a file to Uploadcare.\r\n+ *\r\n+ * @param {object} file - An object containing:\r\n+ *   - createReadStream: a function that returns a readable stream\r\n+ *   - filename: the name of the file\r\n+ *   - mimetype: the file's MIME type (not used in this example, but you can validate)\r\n+ * @returns {Promise<string>} - Resolves with the CDN URL of the uploaded file.\r\n+ */\r\n+export const uploadToUploadcare = async (file) => {\r\n+  try {\r\n+    const { createReadStream, filename } = await file;\r\n+    const form = new FormData();\r\n+\r\n+    // Required fields\r\n+    form.append('UPLOADCARE_PUB_KEY', PUBLIC_KEY);\r\n+    form.append('UPLOADCARE_STORE', 'auto'); // or 'yes' if you want to store immediately\r\n+    form.append('file', createReadStream(), { filename });\r\n+\r\n+    const uploadUrl = 'https://upload.uploadcare.com/base/';\r\n+\r\n+    const response = await fetch(uploadUrl, {\r\n+      method: 'POST',\r\n+      body: form,\r\n+    });\r\n+\r\n+    const result = await response.json();\r\n+\r\n+    if (!response.ok) {\r\n+      throw new Error(`Uploadcare upload failed: ${JSON.stringify(result)}`);\r\n+    }\r\n+\r\n+    // result.file contains the UUID of the uploaded file\r\n+    const cdnUrl = `https://ucarecdn.com/${result.file}/`;\r\n+    console.log(`File ${filename} uploaded successfully. CDN URL: ${cdnUrl}`);\r\n+    return cdnUrl;\r\n+  } catch (err) {\r\n+    console.error('Error uploading file to Uploadcare:', err);\r\n+    throw new Error('File upload process failed');\r\n+  }\r\n+};\r\n+\r\n+/**\r\n+ * Delete a file from Uploadcare using its UUID.\r\n+ *\r\n+ * @param {string} uuid - The UUID of the file to delete.\r\n+ * @returns {Promise<object>} - Resolves with the deletion result.\r\n+ */\r\n+export const deleteFileFromUploadcare = async (uuid) => {\r\n+  if (!uuid) {\r\n+    throw new Error('No file UUID provided.');\r\n+  }\r\n+\r\n+  const deletionUrl = `https://api.uploadcare.com/files/${uuid}/`;\r\n+\r\n+  try {\r\n+    const response = await fetch(deletionUrl, {\r\n+      method: 'DELETE',\r\n+      headers: {\r\n+        'Accept': 'application/vnd.uploadcare-v0.6+json',\r\n+        // Uploadcare.Simple authentication: \"Uploadcare.Simple <public_key>:<secret_key>\"\r\n+        'Authorization': `Uploadcare.Simple ${PUBLIC_KEY}:${SECRET_KEY}`,\r\n+      },\r\n+    });\r\n+\r\n+    const result = await response.json();\r\n+\r\n+    if (!response.ok) {\r\n+      throw new Error(`Uploadcare deletion failed: ${JSON.stringify(result)}`);\r\n+    }\r\n+\r\n+    console.log(`File with UUID ${uuid} deleted successfully.`);\r\n+    return result;\r\n+  } catch (error) {\r\n+    console.error(`Error deleting file with UUID ${uuid}:`, error);\r\n+    throw new Error(`Uploadcare deletion error: ${error.message}`);\r\n+  }\r\n+};\r\n"
                },
                {
                    "date": 1740474084322,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,89 @@\n+import dotenv from 'dotenv';\r\n+import fetch from 'node-fetch';\r\n+import FormData from 'form-data';\r\n+\r\n+dotenv.config();\r\n+\r\n+const PUBLIC_KEY = process.env.PUBLIC_KEY;\r\n+const SECRET_KEY = process.env.SECRET_KEY;\r\n+\r\n+/**\r\n+ * Upload a file to Uploadcare.\r\n+ *\r\n+ * @param {object} file - An object containing:\r\n+ *   - createReadStream: a function that returns a readable stream\r\n+ *   - filename: the name of the file\r\n+ *   - mimetype: the file's MIME type (not used in this example, but you can validate)\r\n+ * @returns {Promise<string>} - Resolves with the CDN URL of the uploaded file.\r\n+ */\r\n+export const uploadToUploadcare = async (file) => {\r\n+  try {\r\n+    const { createReadStream, filename } = await file;\r\n+    const form = new FormData();\r\n+\r\n+    // Required fields\r\n+    form.append('UPLOADCARE_PUB_KEY', PUBLIC_KEY);\r\n+    form.append('UPLOADCARE_STORE', 'auto'); // or 'yes' if you want to store immediately\r\n+    form.append('file', createReadStream(), { filename });\r\n+\r\n+    const uploadUrl = 'https://upload.uploadcare.com/base/';\r\n+\r\n+    const response = await fetch(uploadUrl, {\r\n+      method: 'POST',\r\n+      body: form,\r\n+    });\r\n+\r\n+    const result = await response.json();\r\n+\r\n+    if (!response.ok) {\r\n+      throw new Error(`Uploadcare upload failed: ${JSON.stringify(result)}`);\r\n+    }\r\n+\r\n+    // result.file contains the UUID of the uploaded file\r\n+    const cdnUrl = `https://ucarecdn.com/${result.file}/`;\r\n+    console.log(`File ${filename} uploaded successfully. CDN URL: ${cdnUrl}`);\r\n+    return cdnUrl;\r\n+  } catch (err) {\r\n+    console.error('Error uploading file to Uploadcare:', err);\r\n+    throw new Error('File upload process failed');\r\n+  }\r\n+};\r\n+\r\n+\r\n+\r\n+/**\r\n+ * Delete a file from Uploadcare using its UUID.\r\n+ *\r\n+ * @param {string} uuid - The UUID of the file to delete.\r\n+ * @returns {Promise<object>} - Resolves with the deletion result.\r\n+ */\r\n+export const deleteFileFromUploadcare = async (uuid) => {\r\n+  if (!uuid) {\r\n+    throw new Error('No file UUID provided.');\r\n+  }\r\n+\r\n+  const deletionUrl = `https://api.uploadcare.com/files/${uuid}/`;\r\n+\r\n+  try {\r\n+    const response = await fetch(deletionUrl, {\r\n+      method: 'DELETE',\r\n+      headers: {\r\n+        'Accept': 'application/vnd.uploadcare-v0.6+json',\r\n+        // Uploadcare.Simple authentication: \"Uploadcare.Simple <public_key>:<secret_key>\"\r\n+        'Authorization': `Uploadcare.Simple ${PUBLIC_KEY}:${SECRET_KEY}`,\r\n+      },\r\n+    });\r\n+\r\n+    const result = await response.json();\r\n+\r\n+    if (!response.ok) {\r\n+      throw new Error(`Uploadcare deletion failed: ${JSON.stringify(result)}`);\r\n+    }\r\n+\r\n+    console.log(`File with UUID ${uuid} deleted successfully.`);\r\n+    return result;\r\n+  } catch (error) {\r\n+    console.error(`Error deleting file with UUID ${uuid}:`, error);\r\n+    throw new Error(`Uploadcare deletion error: ${error.message}`);\r\n+  }\r\n+};\r\n"
                },
                {
                    "date": 1740474199543,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,40 @@\n+import dotenv from 'dotenv';\r\n+import fetch from 'node-fetch';\r\n+import FormData from 'form-data';\r\n+\r\n+dotenv.config();\r\n+\r\n+const PUBLIC_KEY = process.env.PUBLIC_KEY;\r\n+const SECRET_KEY = process.env.SECRET_KEY;\r\n+\r\n+/\r\n+export const deleteFileFromUploadcare = async (uuid) => {\r\n+  if (!uuid) {\r\n+    throw new Error('No file UUID provided.');\r\n+  }\r\n+\r\n+  const deletionUrl = `https://api.uploadcare.com/files/${uuid}/`;\r\n+\r\n+  try {\r\n+    const response = await fetch(deletionUrl, {\r\n+      method: 'DELETE',\r\n+      headers: {\r\n+        'Accept': 'application/vnd.uploadcare-v0.6+json',\r\n+        // Uploadcare.Simple authentication: \"Uploadcare.Simple <public_key>:<secret_key>\"\r\n+        'Authorization': `Uploadcare.Simple ${PUBLIC_KEY}:${SECRET_KEY}`,\r\n+      },\r\n+    });\r\n+\r\n+    const result = await response.json();\r\n+\r\n+    if (!response.ok) {\r\n+      throw new Error(`Uploadcare deletion failed: ${JSON.stringify(result)}`);\r\n+    }\r\n+\r\n+    console.log(`File with UUID ${uuid} deleted successfully.`);\r\n+    return result;\r\n+  } catch (error) {\r\n+    console.error(`Error deleting file with UUID ${uuid}:`, error);\r\n+    throw new Error(`Uploadcare deletion error: ${error.message}`);\r\n+  }\r\n+};\r\n"
                },
                {
                    "date": 1740474205278,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,45 @@\n+import dotenv from 'dotenv';\r\n+import fetch from 'node-fetch';\r\n+import FormData from 'form-data';\r\n+\r\n+dotenv.config();\r\n+\r\n+const PUBLIC_KEY = process.env.PUBLIC_KEY;\r\n+const SECRET_KEY = process.env.SECRET_KEY;\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+export const deleteFileFromUploadcare = async (uuid) => {\r\n+  if (!uuid) {\r\n+    throw new Error('No file UUID provided.');\r\n+  }\r\n+\r\n+  const deletionUrl = `https://api.uploadcare.com/files/${uuid}/`;\r\n+\r\n+  try {\r\n+    const response = await fetch(deletionUrl, {\r\n+      method: 'DELETE',\r\n+      headers: {\r\n+        'Accept': 'application/vnd.uploadcare-v0.6+json',\r\n+        // Uploadcare.Simple authentication: \"Uploadcare.Simple <public_key>:<secret_key>\"\r\n+        'Authorization': `Uploadcare.Simple ${PUBLIC_KEY}:${SECRET_KEY}`,\r\n+      },\r\n+    });\r\n+\r\n+    const result = await response.json();\r\n+\r\n+    if (!response.ok) {\r\n+      throw new Error(`Uploadcare deletion failed: ${JSON.stringify(result)}`);\r\n+    }\r\n+\r\n+    console.log(`File with UUID ${uuid} deleted successfully.`);\r\n+    return result;\r\n+  } catch (error) {\r\n+    console.error(`Error deleting file with UUID ${uuid}:`, error);\r\n+    throw new Error(`Uploadcare deletion error: ${error.message}`);\r\n+  }\r\n+};\r\n"
                },
                {
                    "date": 1740474213552,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,80 @@\n+import dotenv from 'dotenv';\r\n+import fetch from 'node-fetch';\r\n+import FormData from 'form-data';\r\n+\r\n+dotenv.config();\r\n+\r\n+const PUBLIC_KEY = process.env.PUBLIC_KEY;\r\n+const SECRET_KEY = process.env.SECRET_KEY;\r\n+\r\n+\r\n+\r\n+export const uploadToUploadcare = async (file) => {\r\n+    try {\r\n+      const { createReadStream, filename } = await file;\r\n+      const form = new FormData();\r\n+  \r\n+      // Append required fields\r\n+      form.append('UPLOADCARE_PUB_KEY', PUBLIC_KEY);\r\n+      form.append('UPLOADCARE_STORE', 'auto'); // or 'yes' to store immediately\r\n+      form.append('file', createReadStream(), { filename });\r\n+  \r\n+      const uploadUrl = 'https://upload.uploadcare.com/base/';\r\n+  \r\n+      // Send POST request to Uploadcare\r\n+      const response = await fetch(uploadUrl, {\r\n+        method: 'POST',\r\n+        body: form,\r\n+      });\r\n+  \r\n+      // Debug: log raw response if needed\r\n+      // const raw = await response.text();\r\n+      // console.log('Raw response from Uploadcare:', raw);\r\n+      // const result = JSON.parse(raw);\r\n+  \r\n+      const result = await response.json();\r\n+  \r\n+      if (!response.ok) {\r\n+        throw new Error(`Uploadcare upload failed: ${JSON.stringify(result)}`);\r\n+      }\r\n+      const cdnUrl = `https://ucarecdn.com/${result.file}/`;\r\n+      console.log(`File ${filename} uploaded successfully. CDN URL: ${cdnUrl}`);\r\n+      return cdnUrl;\r\n+    } catch (err) {\r\n+      console.error('Error uploading file to Uploadcare:', err);\r\n+      throw new Error('File upload process failed');\r\n+    }\r\n+  };\r\n+\r\n+\r\n+\r\n+export const deleteFileFromUploadcare = async (uuid) => {\r\n+  if (!uuid) {\r\n+    throw new Error('No file UUID provided.');\r\n+  }\r\n+\r\n+  const deletionUrl = `https://api.uploadcare.com/files/${uuid}/`;\r\n+\r\n+  try {\r\n+    const response = await fetch(deletionUrl, {\r\n+      method: 'DELETE',\r\n+      headers: {\r\n+        'Accept': 'application/vnd.uploadcare-v0.6+json',\r\n+        // Uploadcare.Simple authentication: \"Uploadcare.Simple <public_key>:<secret_key>\"\r\n+        'Authorization': `Uploadcare.Simple ${PUBLIC_KEY}:${SECRET_KEY}`,\r\n+      },\r\n+    });\r\n+\r\n+    const result = await response.json();\r\n+\r\n+    if (!response.ok) {\r\n+      throw new Error(`Uploadcare deletion failed: ${JSON.stringify(result)}`);\r\n+    }\r\n+\r\n+    console.log(`File with UUID ${uuid} deleted successfully.`);\r\n+    return result;\r\n+  } catch (error) {\r\n+    console.error(`Error deleting file with UUID ${uuid}:`, error);\r\n+    throw new Error(`Uploadcare deletion error: ${error.message}`);\r\n+  }\r\n+};\r\n"
                },
                {
                    "date": 1740474360546,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,44 @@\n+import dotenv from 'dotenv';\r\n+import fetch from 'node-fetch';\r\n+import FormData from 'form-data';\r\n+\r\n+dotenv.config();\r\n+\r\n+const PUBLIC_KEY = process.env.PUBLIC_KEY;\r\n+const SECRET_KEY = process.env.SECRET_KEY;\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+export const deleteFileFromUploadcare = async (uuid) => {\r\n+  if (!uuid) {\r\n+    throw new Error('No file UUID provided.');\r\n+  }\r\n+\r\n+  const deletionUrl = `https://api.uploadcare.com/files/${uuid}/`;\r\n+\r\n+  try {\r\n+    const response = await fetch(deletionUrl, {\r\n+      method: 'DELETE',\r\n+      headers: {\r\n+        'Accept': 'application/vnd.uploadcare-v0.6+json',\r\n+        // Uploadcare.Simple authentication: \"Uploadcare.Simple <public_key>:<secret_key>\"\r\n+        'Authorization': `Uploadcare.Simple ${PUBLIC_KEY}:${SECRET_KEY}`,\r\n+      },\r\n+    });\r\n+\r\n+    const result = await response.json();\r\n+\r\n+    if (!response.ok) {\r\n+      throw new Error(`Uploadcare deletion failed: ${JSON.stringify(result)}`);\r\n+    }\r\n+\r\n+    console.log(`File with UUID ${uuid} deleted successfully.`);\r\n+    return result;\r\n+  } catch (error) {\r\n+    console.error(`Error deleting file with UUID ${uuid}:`, error);\r\n+    throw new Error(`Uploadcare deletion error: ${error.message}`);\r\n+  }\r\n+};\r\n"
                },
                {
                    "date": 1740474393062,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -8,52 +8,8 @@\n const SECRET_KEY = process.env.SECRET_KEY;\r\n \r\n \r\n \r\n-\r\n-\r\n-\r\n-export const deleteFileFromUploadcare = async (uuid) => {\r\n-  if (!uuid) {\r\n-    throw new Error('No file UUID provided.');\r\n-  }\r\n-\r\n-  const deletionUrl = `https://api.uploadcare.com/files/${uuid}/`;\r\n-\r\n-  try {\r\n-    const response = await fetch(deletionUrl, {\r\n-      method: 'DELETE',\r\n-      headers: {\r\n-        'Accept': 'application/vnd.uploadcare-v0.6+json',\r\n-        // Uploadcare.Simple authentication: \"Uploadcare.Simple <public_key>:<secret_key>\"\r\n-        'Authorization': `Uploadcare.Simple ${PUBLIC_KEY}:${SECRET_KEY}`,\r\n-      },\r\n-    });\r\n-\r\n-    const result = await response.json();\r\n-\r\n-    if (!response.ok) {\r\n-      throw new Error(`Uploadcare deletion failed: ${JSON.stringify(result)}`);\r\n-    }\r\n-\r\n-    console.log(`File with UUID ${uuid} deleted successfully.`);\r\n-    return result;\r\n-  } catch (error) {\r\n-    console.error(`Error deleting file with UUID ${uuid}:`, error);\r\n-    throw new Error(`Uploadcare deletion error: ${error.message}`);\r\n-  }\r\n-};\r\n-import dotenv from 'dotenv';\r\n-import fetch from 'node-fetch';\r\n-import FormData from 'form-data';\r\n-\r\n-dotenv.config();\r\n-\r\n-const PUBLIC_KEY = process.env.PUBLIC_KEY;\r\n-const SECRET_KEY = process.env.SECRET_KEY;\r\n-\r\n-\r\n-\r\n export const uploadToUploadcare = async (file) => {\r\n     try {\r\n       const { createReadStream, filename } = await file;\r\n       const form = new FormData();\r\n@@ -121,353 +77,4 @@\n     console.error(`Error deleting file with UUID ${uuid}:`, error);\r\n     throw new Error(`Uploadcare deletion error: ${error.message}`);\r\n   }\r\n };\r\n-import dotenv from 'dotenv';\r\n-import fetch from 'node-fetch';\r\n-import FormData from 'form-data';\r\n-\r\n-dotenv.config();\r\n-\r\n-const PUBLIC_KEY = process.env.PUBLIC_KEY;\r\n-const SECRET_KEY = process.env.SECRET_KEY;\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-export const deleteFileFromUploadcare = async (uuid) => {\r\n-  if (!uuid) {\r\n-    throw new Error('No file UUID provided.');\r\n-  }\r\n-\r\n-  const deletionUrl = `https://api.uploadcare.com/files/${uuid}/`;\r\n-\r\n-  try {\r\n-    const response = await fetch(deletionUrl, {\r\n-      method: 'DELETE',\r\n-      headers: {\r\n-        'Accept': 'application/vnd.uploadcare-v0.6+json',\r\n-        // Uploadcare.Simple authentication: \"Uploadcare.Simple <public_key>:<secret_key>\"\r\n-        'Authorization': `Uploadcare.Simple ${PUBLIC_KEY}:${SECRET_KEY}`,\r\n-      },\r\n-    });\r\n-\r\n-    const result = await response.json();\r\n-\r\n-    if (!response.ok) {\r\n-      throw new Error(`Uploadcare deletion failed: ${JSON.stringify(result)}`);\r\n-    }\r\n-\r\n-    console.log(`File with UUID ${uuid} deleted successfully.`);\r\n-    return result;\r\n-  } catch (error) {\r\n-    console.error(`Error deleting file with UUID ${uuid}:`, error);\r\n-    throw new Error(`Uploadcare deletion error: ${error.message}`);\r\n-  }\r\n-};\r\n-import dotenv from 'dotenv';\r\n-import fetch from 'node-fetch';\r\n-import FormData from 'form-data';\r\n-\r\n-dotenv.config();\r\n-\r\n-const PUBLIC_KEY = process.env.PUBLIC_KEY;\r\n-const SECRET_KEY = process.env.SECRET_KEY;\r\n-\r\n-/\r\n-export const deleteFileFromUploadcare = async (uuid) => {\r\n-  if (!uuid) {\r\n-    throw new Error('No file UUID provided.');\r\n-  }\r\n-\r\n-  const deletionUrl = `https://api.uploadcare.com/files/${uuid}/`;\r\n-\r\n-  try {\r\n-    const response = await fetch(deletionUrl, {\r\n-      method: 'DELETE',\r\n-      headers: {\r\n-        'Accept': 'application/vnd.uploadcare-v0.6+json',\r\n-        // Uploadcare.Simple authentication: \"Uploadcare.Simple <public_key>:<secret_key>\"\r\n-        'Authorization': `Uploadcare.Simple ${PUBLIC_KEY}:${SECRET_KEY}`,\r\n-      },\r\n-    });\r\n-\r\n-    const result = await response.json();\r\n-\r\n-    if (!response.ok) {\r\n-      throw new Error(`Uploadcare deletion failed: ${JSON.stringify(result)}`);\r\n-    }\r\n-\r\n-    console.log(`File with UUID ${uuid} deleted successfully.`);\r\n-    return result;\r\n-  } catch (error) {\r\n-    console.error(`Error deleting file with UUID ${uuid}:`, error);\r\n-    throw new Error(`Uploadcare deletion error: ${error.message}`);\r\n-  }\r\n-};\r\n-import dotenv from 'dotenv';\r\n-import fetch from 'node-fetch';\r\n-import FormData from 'form-data';\r\n-\r\n-dotenv.config();\r\n-\r\n-const PUBLIC_KEY = process.env.PUBLIC_KEY;\r\n-const SECRET_KEY = process.env.SECRET_KEY;\r\n-\r\n-/**\r\n- * Upload a file to Uploadcare.\r\n- *\r\n- * @param {object} file - An object containing:\r\n- *   - createReadStream: a function that returns a readable stream\r\n- *   - filename: the name of the file\r\n- *   - mimetype: the file's MIME type (not used in this example, but you can validate)\r\n- * @returns {Promise<string>} - Resolves with the CDN URL of the uploaded file.\r\n- */\r\n-export const uploadToUploadcare = async (file) => {\r\n-  try {\r\n-    const { createReadStream, filename } = await file;\r\n-    const form = new FormData();\r\n-\r\n-    // Required fields\r\n-    form.append('UPLOADCARE_PUB_KEY', PUBLIC_KEY);\r\n-    form.append('UPLOADCARE_STORE', 'auto'); // or 'yes' if you want to store immediately\r\n-    form.append('file', createReadStream(), { filename });\r\n-\r\n-    const uploadUrl = 'https://upload.uploadcare.com/base/';\r\n-\r\n-    const response = await fetch(uploadUrl, {\r\n-      method: 'POST',\r\n-      body: form,\r\n-    });\r\n-\r\n-    const result = await response.json();\r\n-\r\n-    if (!response.ok) {\r\n-      throw new Error(`Uploadcare upload failed: ${JSON.stringify(result)}`);\r\n-    }\r\n-\r\n-    // result.file contains the UUID of the uploaded file\r\n-    const cdnUrl = `https://ucarecdn.com/${result.file}/`;\r\n-    console.log(`File ${filename} uploaded successfully. CDN URL: ${cdnUrl}`);\r\n-    return cdnUrl;\r\n-  } catch (err) {\r\n-    console.error('Error uploading file to Uploadcare:', err);\r\n-    throw new Error('File upload process failed');\r\n-  }\r\n-};\r\n-\r\n-\r\n-\r\n-/**\r\n- * Delete a file from Uploadcare using its UUID.\r\n- *\r\n- * @param {string} uuid - The UUID of the file to delete.\r\n- * @returns {Promise<object>} - Resolves with the deletion result.\r\n- */\r\n-export const deleteFileFromUploadcare = async (uuid) => {\r\n-  if (!uuid) {\r\n-    throw new Error('No file UUID provided.');\r\n-  }\r\n-\r\n-  const deletionUrl = `https://api.uploadcare.com/files/${uuid}/`;\r\n-\r\n-  try {\r\n-    const response = await fetch(deletionUrl, {\r\n-      method: 'DELETE',\r\n-      headers: {\r\n-        'Accept': 'application/vnd.uploadcare-v0.6+json',\r\n-        // Uploadcare.Simple authentication: \"Uploadcare.Simple <public_key>:<secret_key>\"\r\n-        'Authorization': `Uploadcare.Simple ${PUBLIC_KEY}:${SECRET_KEY}`,\r\n-      },\r\n-    });\r\n-\r\n-    const result = await response.json();\r\n-\r\n-    if (!response.ok) {\r\n-      throw new Error(`Uploadcare deletion failed: ${JSON.stringify(result)}`);\r\n-    }\r\n-\r\n-    console.log(`File with UUID ${uuid} deleted successfully.`);\r\n-    return result;\r\n-  } catch (error) {\r\n-    console.error(`Error deleting file with UUID ${uuid}:`, error);\r\n-    throw new Error(`Uploadcare deletion error: ${error.message}`);\r\n-  }\r\n-};\r\n-import dotenv from 'dotenv';\r\n-import fetch from 'node-fetch';\r\n-import FormData from 'form-data';\r\n-\r\n-dotenv.config();\r\n-\r\n-const PUBLIC_KEY = process.env.PUBLIC_KEY;\r\n-const SECRET_KEY = process.env.UPLOADCARE_SECRET_KEY;\r\n-\r\n-/**\r\n- * Upload a file to Uploadcare.\r\n- *\r\n- * @param {object} file - An object containing:\r\n- *   - createReadStream: a function that returns a readable stream\r\n- *   - filename: the name of the file\r\n- *   - mimetype: the file's MIME type (not used in this example, but you can validate)\r\n- * @returns {Promise<string>} - Resolves with the CDN URL of the uploaded file.\r\n- */\r\n-export const uploadToUploadcare = async (file) => {\r\n-  try {\r\n-    const { createReadStream, filename } = await file;\r\n-    const form = new FormData();\r\n-\r\n-    // Required fields\r\n-    form.append('UPLOADCARE_PUB_KEY', PUBLIC_KEY);\r\n-    form.append('UPLOADCARE_STORE', 'auto'); // or 'yes' if you want to store immediately\r\n-    form.append('file', createReadStream(), { filename });\r\n-\r\n-    const uploadUrl = 'https://upload.uploadcare.com/base/';\r\n-\r\n-    const response = await fetch(uploadUrl, {\r\n-      method: 'POST',\r\n-      body: form,\r\n-    });\r\n-\r\n-    const result = await response.json();\r\n-\r\n-    if (!response.ok) {\r\n-      throw new Error(`Uploadcare upload failed: ${JSON.stringify(result)}`);\r\n-    }\r\n-\r\n-    // result.file contains the UUID of the uploaded file\r\n-    const cdnUrl = `https://ucarecdn.com/${result.file}/`;\r\n-    console.log(`File ${filename} uploaded successfully. CDN URL: ${cdnUrl}`);\r\n-    return cdnUrl;\r\n-  } catch (err) {\r\n-    console.error('Error uploading file to Uploadcare:', err);\r\n-    throw new Error('File upload process failed');\r\n-  }\r\n-};\r\n-\r\n-/**\r\n- * Delete a file from Uploadcare using its UUID.\r\n- *\r\n- * @param {string} uuid - The UUID of the file to delete.\r\n- * @returns {Promise<object>} - Resolves with the deletion result.\r\n- */\r\n-export const deleteFileFromUploadcare = async (uuid) => {\r\n-  if (!uuid) {\r\n-    throw new Error('No file UUID provided.');\r\n-  }\r\n-\r\n-  const deletionUrl = `https://api.uploadcare.com/files/${uuid}/`;\r\n-\r\n-  try {\r\n-    const response = await fetch(deletionUrl, {\r\n-      method: 'DELETE',\r\n-      headers: {\r\n-        'Accept': 'application/vnd.uploadcare-v0.6+json',\r\n-        // Uploadcare.Simple authentication: \"Uploadcare.Simple <public_key>:<secret_key>\"\r\n-        'Authorization': `Uploadcare.Simple ${PUBLIC_KEY}:${SECRET_KEY}`,\r\n-      },\r\n-    });\r\n-\r\n-    const result = await response.json();\r\n-\r\n-    if (!response.ok) {\r\n-      throw new Error(`Uploadcare deletion failed: ${JSON.stringify(result)}`);\r\n-    }\r\n-\r\n-    console.log(`File with UUID ${uuid} deleted successfully.`);\r\n-    return result;\r\n-  } catch (error) {\r\n-    console.error(`Error deleting file with UUID ${uuid}:`, error);\r\n-    throw new Error(`Uploadcare deletion error: ${error.message}`);\r\n-  }\r\n-};\r\n-import dotenv from 'dotenv';\r\n-import fetch from 'node-fetch';\r\n-import FormData from 'form-data';\r\n-\r\n-dotenv.config();\r\n-\r\n-const PUBLIC_KEY = process.env.PUBLIC_KEY;\r\n-const SECRET_KEY = process.env.UPLOADCARE_SECRET_KEY;\r\n-\r\n-/**\r\n- * Upload a file to Uploadcare.\r\n- *\r\n- * @param {object} file - An object containing:\r\n- *   - createReadStream: a function that returns a readable stream\r\n- *   - filename: the name of the file\r\n- *   - mimetype: the file's MIME type (not used in this example, but you can validate)\r\n- * @returns {Promise<string>} - Resolves with the CDN URL of the uploaded file.\r\n- */\r\n-export const uploadToUploadcare = async (file) => {\r\n-  try {\r\n-    const { createReadStream, filename } = await file;\r\n-    const form = new FormData();\r\n-\r\n-    // Required fields\r\n-    form.append('UPLOADCARE_PUB_KEY', PUBLIC_KEY);\r\n-    form.append('UPLOADCARE_STORE', 'auto'); // or 'yes' if you want to store immediately\r\n-    form.append('file', createReadStream(), { filename });\r\n-\r\n-    const uploadUrl = 'https://upload.uploadcare.com/base/';\r\n-\r\n-    const response = await fetch(uploadUrl, {\r\n-      method: 'POST',\r\n-      body: form,\r\n-    });\r\n-\r\n-    const result = await response.json();\r\n-\r\n-    if (!response.ok) {\r\n-      throw new Error(`Uploadcare upload failed: ${JSON.stringify(result)}`);\r\n-    }\r\n-\r\n-    // result.file contains the UUID of the uploaded file\r\n-    const cdnUrl = `https://ucarecdn.com/${result.file}/`;\r\n-    console.log(`File ${filename} uploaded successfully. CDN URL: ${cdnUrl}`);\r\n-    return cdnUrl;\r\n-  } catch (err) {\r\n-    console.error('Error uploading file to Uploadcare:', err);\r\n-    throw new Error('File upload process failed');\r\n-  }\r\n-};\r\n-\r\n-/**\r\n- * Delete a file from Uploadcare using its UUID.\r\n- *\r\n- * @param {string} uuid - The UUID of the file to delete.\r\n- * @returns {Promise<object>} - Resolves with the deletion result.\r\n- */\r\n-export const deleteFileFromUploadcare = async (uuid) => {\r\n-  if (!uuid) {\r\n-    throw new Error('No file UUID provided.');\r\n-  }\r\n-\r\n-  const deletionUrl = `https://api.uploadcare.com/files/${uuid}/`;\r\n-\r\n-  try {\r\n-    const response = await fetch(deletionUrl, {\r\n-      method: 'DELETE',\r\n-      headers: {\r\n-        'Accept': 'application/vnd.uploadcare-v0.6+json',\r\n-        // Uploadcare.Simple authentication: \"Uploadcare.Simple <public_key>:<secret_key>\"\r\n-        'Authorization': `Uploadcare.Simple ${PUBLIC_KEY}:${SECRET_KEY}`,\r\n-      },\r\n-    });\r\n-\r\n-    const result = await response.json();\r\n-\r\n-    if (!response.ok) {\r\n-      throw new Error(`Uploadcare deletion failed: ${JSON.stringify(result)}`);\r\n-    }\r\n-\r\n-    console.log(`File with UUID ${uuid} deleted successfully.`);\r\n-    return result;\r\n-  } catch (error) {\r\n-    console.error(`Error deleting file with UUID ${uuid}:`, error);\r\n-    throw new Error(`Uploadcare deletion error: ${error.message}`);\r\n-  }\r\n-};\r\n-\n"
                },
                {
                    "date": 1740474545124,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,80 +0,0 @@\n-import dotenv from 'dotenv';\r\n-import fetch from 'node-fetch';\r\n-import FormData from 'form-data';\r\n-\r\n-dotenv.config();\r\n-\r\n-const PUBLIC_KEY = process.env.PUBLIC_KEY;\r\n-const SECRET_KEY = process.env.SECRET_KEY;\r\n-\r\n-\r\n-\r\n-export const uploadToUploadcare = async (file) => {\r\n-    try {\r\n-      const { createReadStream, filename } = await file;\r\n-      const form = new FormData();\r\n-  \r\n-      // Append required fields\r\n-      form.append('UPLOADCARE_PUB_KEY', PUBLIC_KEY);\r\n-      form.append('UPLOADCARE_STORE', 'auto'); // or 'yes' to store immediately\r\n-      form.append('file', createReadStream(), { filename });\r\n-  \r\n-      const uploadUrl = 'https://upload.uploadcare.com/base/';\r\n-  \r\n-      // Send POST request to Uploadcare\r\n-      const response = await fetch(uploadUrl, {\r\n-        method: 'POST',\r\n-        body: form,\r\n-      });\r\n-  \r\n-      // Debug: log raw response if needed\r\n-      // const raw = await response.text();\r\n-      // console.log('Raw response from Uploadcare:', raw);\r\n-      // const result = JSON.parse(raw);\r\n-  \r\n-      const result = await response.json();\r\n-  \r\n-      if (!response.ok) {\r\n-        throw new Error(`Uploadcare upload failed: ${JSON.stringify(result)}`);\r\n-      }\r\n-      const cdnUrl = `https://ucarecdn.com/${result.file}/`;\r\n-      console.log(`File ${filename} uploaded successfully. CDN URL: ${cdnUrl}`);\r\n-      return cdnUrl;\r\n-    } catch (err) {\r\n-      console.error('Error uploading file to Uploadcare:', err);\r\n-      throw new Error('File upload process failed');\r\n-    }\r\n-  };\r\n-\r\n-\r\n-\r\n-export const deleteFileFromUploadcare = async (uuid) => {\r\n-  if (!uuid) {\r\n-    throw new Error('No file UUID provided.');\r\n-  }\r\n-\r\n-  const deletionUrl = `https://api.uploadcare.com/files/${uuid}/`;\r\n-\r\n-  try {\r\n-    const response = await fetch(deletionUrl, {\r\n-      method: 'DELETE',\r\n-      headers: {\r\n-        'Accept': 'application/vnd.uploadcare-v0.6+json',\r\n-        // Uploadcare.Simple authentication: \"Uploadcare.Simple <public_key>:<secret_key>\"\r\n-        'Authorization': `Uploadcare.Simple ${PUBLIC_KEY}:${SECRET_KEY}`,\r\n-      },\r\n-    });\r\n-\r\n-    const result = await response.json();\r\n-\r\n-    if (!response.ok) {\r\n-      throw new Error(`Uploadcare deletion failed: ${JSON.stringify(result)}`);\r\n-    }\r\n-\r\n-    console.log(`File with UUID ${uuid} deleted successfully.`);\r\n-    return result;\r\n-  } catch (error) {\r\n-    console.error(`Error deleting file with UUID ${uuid}:`, error);\r\n-    throw new Error(`Uploadcare deletion error: ${error.message}`);\r\n-  }\r\n-};\r\n\\ No newline at end of file\n"
                },
                {
                    "date": 1740474931720,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,1 +1,56 @@\n-\n+import { v2 as cloudinary } from 'cloudinary';\r\n+import dotenv from 'dotenv';\r\n+\r\n+dotenv.config();\r\n+\r\n+cloudinary.config({\r\n+  cloud_name: process.env.CLOUD_NAME,\r\n+  api_key: process.env.API_KEY,\r\n+  api_secret: process.env.SECRET_KEY,\r\n+  secure: true,\r\n+});\r\n+\r\n+\r\n+\r\n+\r\n+export const deleteFileFromCloudinary = async (url) => {\r\n+  if (!url) {\r\n+    throw new Error('No URL provided.');\r\n+  }\r\n+  console.log(`Extracting public ID from URL: ${url}`);\r\n+  \r\n+  // Updated regex to capture the folder and public_id for both image and raw uploads.\r\n+  // It will capture any characters after the folder until the last dot before the extension.\r\n+  const match = url.match(/\\/literalouge\\/(.+?)\\.(jpg|jpeg|png|gif|pdf|mp3|epub)$/);\r\n+  if (!match) {\r\n+    throw new Error('Failed to extract public ID from URL.');\r\n+  }\r\n+  \r\n+  // Rebuild the public ID using the folder and captured public_id.\r\n+  const publicId = `literalouge/${match[1]}`;\r\n+  console.log(`Extracted public ID: ${publicId}`);\r\n+\r\n+  try {\r\n+    console.log(`Attempting to delete file with public ID: ${publicId}`);\r\n+    const deletionResult = await cloudinary.uploader.destroy(publicId);\r\n+    console.log('Cloudinary deletion result:', deletionResult);\r\n+\r\n+    if (deletionResult.result === 'ok') {\r\n+      console.log(`Cloudinary file with public ID ${publicId} deleted successfully.`);\r\n+      return deletionResult;\r\n+    } else {\r\n+      throw new Error(`Failed to delete the file from Cloudinary. Response: ${JSON.stringify(deletionResult)}`);\r\n+    }\r\n+  } catch (error) {\r\n+    console.error(`Error deleting file from Cloudinary with public ID ${publicId}:`, error.message);\r\n+    throw new Error(`Cloudinary deletion error: ${error.message}`);\r\n+  }\r\n+};\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n"
                },
                {
                    "date": 1740475038866,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,57 @@\n+import { v2 as cloudinary } from 'cloudinary';\r\n+import dotenv from 'dotenv';\r\n+\r\n+dotenv.config();\r\n+\r\n+cloudinary.config({\r\n+  cloud_name: process.env.CLOUD_NAME,\r\n+  api_key: process.env.API_KEY,\r\n+  api_secret: process.env.SECRET_KEY,\r\n+  secure: true,\r\n+});\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+export const deleteFileFromCloudinary = async (url) => {\r\n+  if (!url) {\r\n+    throw new Error('No URL provided.');\r\n+  }\r\n+  console.log(`Extracting public ID from URL: ${url}`);\r\n+  \r\n+  // Updated regex to capture the folder and public_id for both image and raw uploads.\r\n+  // It will capture any characters after the folder until the last dot before the extension.\r\n+  const match = url.match(/\\/literalouge\\/(.+?)\\.(jpg|jpeg|png|gif|pdf|mp3|epub)$/);\r\n+  if (!match) {\r\n+    throw new Error('Failed to extract public ID from URL.');\r\n+  }\r\n+  \r\n+  // Rebuild the public ID using the folder and captured public_id.\r\n+  const publicId = `literalouge/${match[1]}`;\r\n+  console.log(`Extracted public ID: ${publicId}`);\r\n+\r\n+  try {\r\n+    console.log(`Attempting to delete file with public ID: ${publicId}`);\r\n+    const deletionResult = await cloudinary.uploader.destroy(publicId);\r\n+    console.log('Cloudinary deletion result:', deletionResult);\r\n+\r\n+    if (deletionResult.result === 'ok') {\r\n+      console.log(`Cloudinary file with public ID ${publicId} deleted successfully.`);\r\n+      return deletionResult;\r\n+    } else {\r\n+      throw new Error(`Failed to delete the file from Cloudinary. Response: ${JSON.stringify(deletionResult)}`);\r\n+    }\r\n+  } catch (error) {\r\n+    console.error(`Error deleting file from Cloudinary with public ID ${publicId}:`, error.message);\r\n+    throw new Error(`Cloudinary deletion error: ${error.message}`);\r\n+  }\r\n+};\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n"
                },
                {
                    "date": 1740475194267,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,57 @@\n+import { v2 as cloudinary } from 'cloudinary';\r\n+import dotenv from 'dotenv';\r\n+\r\n+dotenv.config();\r\n+\r\n+cloudinary.config({\r\n+  cloud_name: process.env.CLOUD_NAME,\r\n+  api_key: process.env.API_KEY,\r\n+  api_secret: process.env.SECRET_KEY,\r\n+  secure: true,\r\n+});\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+export const deleteFileFromCloudinary = async (url) => {\r\n+  if (!url) {\r\n+    throw new Error('No URL provided.');\r\n+  }\r\n+  console.log(`Extracting public ID from URL: ${url}`);\r\n+  \r\n+  // Updated regex to capture the folder and public_id for both image and raw uploads.\r\n+  // It will capture any characters after the folder until the last dot before the extension.\r\n+  const match = url.match(/\\/literalouge\\/(.+?)\\.(jpg|jpeg|png|gif|pdf|mp3|epub)$/);\r\n+  if (!match) {\r\n+    throw new Error('Failed to extract public ID from URL.');\r\n+  }\r\n+  \r\n+  // Rebuild the public ID using the folder and captured public_id.\r\n+  const publicId = `literalouge/${match[1]}`;\r\n+  console.log(`Extracted public ID: ${publicId}`);\r\n+\r\n+  try {\r\n+    console.log(`Attempting to delete file with public ID: ${publicId}`);\r\n+    const deletionResult = await cloudinary.uploader.destroy(publicId);\r\n+    console.log('Cloudinary deletion result:', deletionResult);\r\n+\r\n+    if (deletionResult.result === 'ok') {\r\n+      console.log(`Cloudinary file with public ID ${publicId} deleted successfully.`);\r\n+      return deletionResult;\r\n+    } else {\r\n+      throw new Error(`Failed to delete the file from Cloudinary. Response: ${JSON.stringify(deletionResult)}`);\r\n+    }\r\n+  } catch (error) {\r\n+    console.error(`Error deleting file from Cloudinary with public ID ${publicId}:`, error.message);\r\n+    throw new Error(`Cloudinary deletion error: ${error.message}`);\r\n+  }\r\n+};\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n"
                },
                {
                    "date": 1740475201798,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,109 @@\n+import { v2 as cloudinary } from 'cloudinary';\r\n+import dotenv from 'dotenv';\r\n+\r\n+dotenv.config();\r\n+\r\n+cloudinary.config({\r\n+  cloud_name: process.env.CLOUD_NAME,\r\n+  api_key: process.env.API_KEY,\r\n+  api_secret: process.env.SECRET_KEY,\r\n+  secure: true,\r\n+});\r\n+\r\n+export const uploadToCloudinary = async (file) => {\r\n+  try {\r\n+    const { createReadStream, filename, mimetype } = await file;\r\n+    const fileExtension = filename.split('.').pop();\r\n+    const originalFileName = filename.replace(`.${fileExtension}`, '');\r\n+\r\n+    let resourceType;\r\n+    if (mimetype.startsWith('image')) {\r\n+      resourceType = 'image';\r\n+    } else if (\r\n+      mimetype === 'application/pdf' ||\r\n+      mimetype === 'application/epub+zip'\r\n+    ) {\r\n+      resourceType = 'raw';\r\n+    } else {\r\n+      throw new Error(`Unsupported file type: ${mimetype}`);\r\n+    }\r\n+\r\n+    const publicId = originalFileName;\r\n+\r\n+    return new Promise((resolve, reject) => {\r\n+      const stream = createReadStream();\r\n+      const cloudinaryStream = cloudinary.uploader.upload_stream(\r\n+        {\r\n+          folder: 'literalouge',\r\n+          resource_type: resourceType,\r\n+          public_id: publicId,\r\n+        },\r\n+        (error, result) => {\r\n+          if (error) {\r\n+            console.error(\r\n+              `Cloudinary upload error for file ${filename}:`,\r\n+              error\r\n+            );\r\n+            return reject(\r\n+              new Error(\r\n+                `Cloudinary upload failed for ${filename}: ${error.message}`\r\n+              )\r\n+            );\r\n+          }\r\n+          console.log(\r\n+            `File ${filename} uploaded successfully. Secure URL:`,\r\n+            result.secure_url\r\n+          );\r\n+          resolve(result.secure_url);\r\n+        }\r\n+      );\r\n+      stream.pipe(cloudinaryStream);\r\n+    });\r\n+  } catch (err) {\r\n+    console.error('Error in file upload process:', err);\r\n+    throw new Error('File upload process failed');\r\n+  }\r\n+};\r\n+\r\n+\r\n+export const deleteFileFromCloudinary = async (url) => {\r\n+  if (!url) {\r\n+    throw new Error('No URL provided.');\r\n+  }\r\n+  console.log(`Extracting public ID from URL: ${url}`);\r\n+  \r\n+  // Updated regex to capture the folder and public_id for both image and raw uploads.\r\n+  // It will capture any characters after the folder until the last dot before the extension.\r\n+  const match = url.match(/\\/literalouge\\/(.+?)\\.(jpg|jpeg|png|gif|pdf|mp3|epub)$/);\r\n+  if (!match) {\r\n+    throw new Error('Failed to extract public ID from URL.');\r\n+  }\r\n+  \r\n+  // Rebuild the public ID using the folder and captured public_id.\r\n+  const publicId = `literalouge/${match[1]}`;\r\n+  console.log(`Extracted public ID: ${publicId}`);\r\n+\r\n+  try {\r\n+    console.log(`Attempting to delete file with public ID: ${publicId}`);\r\n+    const deletionResult = await cloudinary.uploader.destroy(publicId);\r\n+    console.log('Cloudinary deletion result:', deletionResult);\r\n+\r\n+    if (deletionResult.result === 'ok') {\r\n+      console.log(`Cloudinary file with public ID ${publicId} deleted successfully.`);\r\n+      return deletionResult;\r\n+    } else {\r\n+      throw new Error(`Failed to delete the file from Cloudinary. Response: ${JSON.stringify(deletionResult)}`);\r\n+    }\r\n+  } catch (error) {\r\n+    console.error(`Error deleting file from Cloudinary with public ID ${publicId}:`, error.message);\r\n+    throw new Error(`Cloudinary deletion error: ${error.message}`);\r\n+  }\r\n+};\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n"
                },
                {
                    "date": 1740475208001,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -9,35 +9,25 @@\n   api_secret: process.env.SECRET_KEY,\r\n   secure: true,\r\n });\r\n \r\n-export const uploadToCloudinary = async (file) => {\r\n-  try {\r\n-    const { createReadStream, filename, mimetype } = await file;\r\n-    const fileExtension = filename.split('.').pop();\r\n-    const originalFileName = filename.replace(`.${fileExtension}`, '');\r\n \r\n-    let resourceType;\r\n-    if (mimetype.startsWith('image')) {\r\n-      resourceType = 'image';\r\n-    } else if (\r\n-      mimetype === 'application/pdf' ||\r\n-      mimetype === 'application/epub+zip'\r\n-    ) {\r\n-      resourceType = 'raw';\r\n-    } else {\r\n-      throw new Error(`Unsupported file type: ${mimetype}`);\r\n+export const uploadToCloudinary\r\n+    } else if (mimetype.startsWith('video')) {\r\n+      resourceType = 'video';\r\n     }\r\n \r\n     const publicId = originalFileName;\r\n \r\n     return new Promise((resolve, reject) => {\r\n       const stream = createReadStream();\r\n-      const cloudinaryStream = cloudinary.uploader.upload_stream(\r\n+      const cloudinaryStream = cloudinary.v2.uploader.upload_stream(\r\n         {\r\n           folder: 'literalouge',\r\n           resource_type: resourceType,\r\n           public_id: publicId,\r\n+          use_filename: true, // Uses original filename\r\n+          unique_filename: false, // Prevents Cloudinary from renaming\r\n         },\r\n         (error, result) => {\r\n           if (error) {\r\n             console.error(\r\n@@ -106,174 +96,4 @@\n \r\n \r\n \r\n \r\n-import { v2 as cloudinary } from 'cloudinary';\r\n-import dotenv from 'dotenv';\r\n-\r\n-dotenv.config();\r\n-\r\n-cloudinary.config({\r\n-  cloud_name: process.env.CLOUD_NAME,\r\n-  api_key: process.env.API_KEY,\r\n-  api_secret: process.env.SECRET_KEY,\r\n-  secure: true,\r\n-});\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-export const deleteFileFromCloudinary = async (url) => {\r\n-  if (!url) {\r\n-    throw new Error('No URL provided.');\r\n-  }\r\n-  console.log(`Extracting public ID from URL: ${url}`);\r\n-  \r\n-  // Updated regex to capture the folder and public_id for both image and raw uploads.\r\n-  // It will capture any characters after the folder until the last dot before the extension.\r\n-  const match = url.match(/\\/literalouge\\/(.+?)\\.(jpg|jpeg|png|gif|pdf|mp3|epub)$/);\r\n-  if (!match) {\r\n-    throw new Error('Failed to extract public ID from URL.');\r\n-  }\r\n-  \r\n-  // Rebuild the public ID using the folder and captured public_id.\r\n-  const publicId = `literalouge/${match[1]}`;\r\n-  console.log(`Extracted public ID: ${publicId}`);\r\n-\r\n-  try {\r\n-    console.log(`Attempting to delete file with public ID: ${publicId}`);\r\n-    const deletionResult = await cloudinary.uploader.destroy(publicId);\r\n-    console.log('Cloudinary deletion result:', deletionResult);\r\n-\r\n-    if (deletionResult.result === 'ok') {\r\n-      console.log(`Cloudinary file with public ID ${publicId} deleted successfully.`);\r\n-      return deletionResult;\r\n-    } else {\r\n-      throw new Error(`Failed to delete the file from Cloudinary. Response: ${JSON.stringify(deletionResult)}`);\r\n-    }\r\n-  } catch (error) {\r\n-    console.error(`Error deleting file from Cloudinary with public ID ${publicId}:`, error.message);\r\n-    throw new Error(`Cloudinary deletion error: ${error.message}`);\r\n-  }\r\n-};\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-import { v2 as cloudinary } from 'cloudinary';\r\n-import dotenv from 'dotenv';\r\n-\r\n-dotenv.config();\r\n-\r\n-cloudinary.config({\r\n-  cloud_name: process.env.CLOUD_NAME,\r\n-  api_key: process.env.API_KEY,\r\n-  api_secret: process.env.SECRET_KEY,\r\n-  secure: true,\r\n-});\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-export const deleteFileFromCloudinary = async (url) => {\r\n-  if (!url) {\r\n-    throw new Error('No URL provided.');\r\n-  }\r\n-  console.log(`Extracting public ID from URL: ${url}`);\r\n-  \r\n-  // Updated regex to capture the folder and public_id for both image and raw uploads.\r\n-  // It will capture any characters after the folder until the last dot before the extension.\r\n-  const match = url.match(/\\/literalouge\\/(.+?)\\.(jpg|jpeg|png|gif|pdf|mp3|epub)$/);\r\n-  if (!match) {\r\n-    throw new Error('Failed to extract public ID from URL.');\r\n-  }\r\n-  \r\n-  // Rebuild the public ID using the folder and captured public_id.\r\n-  const publicId = `literalouge/${match[1]}`;\r\n-  console.log(`Extracted public ID: ${publicId}`);\r\n-\r\n-  try {\r\n-    console.log(`Attempting to delete file with public ID: ${publicId}`);\r\n-    const deletionResult = await cloudinary.uploader.destroy(publicId);\r\n-    console.log('Cloudinary deletion result:', deletionResult);\r\n-\r\n-    if (deletionResult.result === 'ok') {\r\n-      console.log(`Cloudinary file with public ID ${publicId} deleted successfully.`);\r\n-      return deletionResult;\r\n-    } else {\r\n-      throw new Error(`Failed to delete the file from Cloudinary. Response: ${JSON.stringify(deletionResult)}`);\r\n-    }\r\n-  } catch (error) {\r\n-    console.error(`Error deleting file from Cloudinary with public ID ${publicId}:`, error.message);\r\n-    throw new Error(`Cloudinary deletion error: ${error.message}`);\r\n-  }\r\n-};\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-import { v2 as cloudinary } from 'cloudinary';\r\n-import dotenv from 'dotenv';\r\n-\r\n-dotenv.config();\r\n-\r\n-cloudinary.config({\r\n-  cloud_name: process.env.CLOUD_NAME,\r\n-  api_key: process.env.API_KEY,\r\n-  api_secret: process.env.SECRET_KEY,\r\n-  secure: true,\r\n-});\r\n-\r\n-\r\n-\r\n-\r\n-export const deleteFileFromCloudinary = async (url) => {\r\n-  if (!url) {\r\n-    throw new Error('No URL provided.');\r\n-  }\r\n-  console.log(`Extracting public ID from URL: ${url}`);\r\n-  \r\n-  // Updated regex to capture the folder and public_id for both image and raw uploads.\r\n-  // It will capture any characters after the folder until the last dot before the extension.\r\n-  const match = url.match(/\\/literalouge\\/(.+?)\\.(jpg|jpeg|png|gif|pdf|mp3|epub)$/);\r\n-  if (!match) {\r\n-    throw new Error('Failed to extract public ID from URL.');\r\n-  }\r\n-  \r\n-  // Rebuild the public ID using the folder and captured public_id.\r\n-  const publicId = `literalouge/${match[1]}`;\r\n-  console.log(`Extracted public ID: ${publicId}`);\r\n-\r\n-  try {\r\n-    console.log(`Attempting to delete file with public ID: ${publicId}`);\r\n-    const deletionResult = await cloudinary.uploader.destroy(publicId);\r\n-    console.log('Cloudinary deletion result:', deletionResult);\r\n-\r\n-    if (deletionResult.result === 'ok') {\r\n-      console.log(`Cloudinary file with public ID ${publicId} deleted successfully.`);\r\n-      return deletionResult;\r\n-    } else {\r\n-      throw new Error(`Failed to delete the file from Cloudinary. Response: ${JSON.stringify(deletionResult)}`);\r\n-    }\r\n-  } catch (error) {\r\n-    console.error(`Error deleting file from Cloudinary with public ID ${publicId}:`, error.message);\r\n-    throw new Error(`Cloudinary deletion error: ${error.message}`);\r\n-  }\r\n-};\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n"
                },
                {
                    "date": 1740475213837,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,108 @@\n+import { v2 as cloudinary } from 'cloudinary';\r\n+import dotenv from 'dotenv';\r\n+\r\n+dotenv.config();\r\n+\r\n+cloudinary.config({\r\n+  cloud_name: process.env.CLOUD_NAME,\r\n+  api_key: process.env.API_KEY,\r\n+  api_secret: process.env.SECRET_KEY,\r\n+  secure: true,\r\n+});\r\n+\r\n+\r\n+export const uploadToCloudinary = async (file) => {\r\n+  try {\r\n+    const { createReadStream, filename, mimetype } = await file;\r\n+    const fileExtension = filename.split('.').pop();\r\n+    const originalFileName = filename.replace(`.${fileExtension}`, '');\r\n+\r\n+    // Determine resource type\r\n+    let resourceType = 'raw'; // Default to raw for non-image/video files\r\n+    if (mimetype.startsWith('image')) {\r\n+      resourceType = 'image';\r\n+    } else if (mimetype.startsWith('video')) {\r\n+      resourceType = 'video';\r\n+    }\r\n+\r\n+    const publicId = originalFileName;\r\n+\r\n+    return new Promise((resolve, reject) => {\r\n+      const stream = createReadStream();\r\n+      const cloudinaryStream = cloudinary.v2.uploader.upload_stream(\r\n+        {\r\n+          folder: 'literalouge',\r\n+          resource_type: resourceType,\r\n+          public_id: publicId,\r\n+          use_filename: true, // Uses original filename\r\n+          unique_filename: false, // Prevents Cloudinary from renaming\r\n+        },\r\n+        (error, result) => {\r\n+          if (error) {\r\n+            console.error(\r\n+              `Cloudinary upload error for file ${filename}:`,\r\n+              error\r\n+            );\r\n+            return reject(\r\n+              new Error(\r\n+                `Cloudinary upload failed for ${filename}: ${error.message}`\r\n+              )\r\n+            );\r\n+          }\r\n+          console.log(\r\n+            `File ${filename} uploaded successfully. Secure URL:`,\r\n+            result.secure_url\r\n+          );\r\n+          resolve(result.secure_url);\r\n+        }\r\n+      );\r\n+      stream.pipe(cloudinaryStream);\r\n+    });\r\n+  } catch (err) {\r\n+    console.error('Error in file upload process:', err);\r\n+    throw new Error('File upload process failed');\r\n+  }\r\n+};\r\n+\r\n+\r\n+export const deleteFileFromCloudinary = async (url) => {\r\n+  if (!url) {\r\n+    throw new Error('No URL provided.');\r\n+  }\r\n+  console.log(`Extracting public ID from URL: ${url}`);\r\n+  \r\n+  // Updated regex to capture the folder and public_id for both image and raw uploads.\r\n+  // It will capture any characters after the folder until the last dot before the extension.\r\n+  const match = url.match(/\\/literalouge\\/(.+?)\\.(jpg|jpeg|png|gif|pdf|mp3|epub)$/);\r\n+  if (!match) {\r\n+    throw new Error('Failed to extract public ID from URL.');\r\n+  }\r\n+  \r\n+  // Rebuild the public ID using the folder and captured public_id.\r\n+  const publicId = `literalouge/${match[1]}`;\r\n+  console.log(`Extracted public ID: ${publicId}`);\r\n+\r\n+  try {\r\n+    console.log(`Attempting to delete file with public ID: ${publicId}`);\r\n+    const deletionResult = await cloudinary.uploader.destroy(publicId);\r\n+    console.log('Cloudinary deletion result:', deletionResult);\r\n+\r\n+    if (deletionResult.result === 'ok') {\r\n+      console.log(`Cloudinary file with public ID ${publicId} deleted successfully.`);\r\n+      return deletionResult;\r\n+    } else {\r\n+      throw new Error(`Failed to delete the file from Cloudinary. Response: ${JSON.stringify(deletionResult)}`);\r\n+    }\r\n+  } catch (error) {\r\n+    console.error(`Error deleting file from Cloudinary with public ID ${publicId}:`, error.message);\r\n+    throw new Error(`Cloudinary deletion error: ${error.message}`);\r\n+  }\r\n+};\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n"
                },
                {
                    "date": 1740475655122,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -10,62 +10,11 @@\n   secure: true,\r\n });\r\n \r\n \r\n-export const uploadToCloudinary = async (file) => {\r\n-  try {\r\n-    const { createReadStream, filename, mimetype } = await file;\r\n-    const fileExtension = filename.split('.').pop();\r\n-    const originalFileName = filename.replace(`.${fileExtension}`, '');\r\n \r\n-    // Determine resource type\r\n-    let resourceType = 'raw'; // Default to raw for non-image/video files\r\n-    if (mimetype.startsWith('image')) {\r\n-      resourceType = 'image';\r\n-    } else if (mimetype.startsWith('video')) {\r\n-      resourceType = 'video';\r\n-    }\r\n \r\n-    const publicId = originalFileName;\r\n \r\n-    return new Promise((resolve, reject) => {\r\n-      const stream = createReadStream();\r\n-      const cloudinaryStream = cloudinary.v2.uploader.upload_stream(\r\n-        {\r\n-          folder: 'literalouge',\r\n-          resource_type: resourceType,\r\n-          public_id: publicId,\r\n-          use_filename: true, // Uses original filename\r\n-          unique_filename: false, // Prevents Cloudinary from renaming\r\n-        },\r\n-        (error, result) => {\r\n-          if (error) {\r\n-            console.error(\r\n-              `Cloudinary upload error for file ${filename}:`,\r\n-              error\r\n-            );\r\n-            return reject(\r\n-              new Error(\r\n-                `Cloudinary upload failed for ${filename}: ${error.message}`\r\n-              )\r\n-            );\r\n-          }\r\n-          console.log(\r\n-            `File ${filename} uploaded successfully. Secure URL:`,\r\n-            result.secure_url\r\n-          );\r\n-          resolve(result.secure_url);\r\n-        }\r\n-      );\r\n-      stream.pipe(cloudinaryStream);\r\n-    });\r\n-  } catch (err) {\r\n-    console.error('Error in file upload process:', err);\r\n-    throw new Error('File upload process failed');\r\n-  }\r\n-};\r\n-\r\n-\r\n export const deleteFileFromCloudinary = async (url) => {\r\n   if (!url) {\r\n     throw new Error('No URL provided.');\r\n   }\r\n@@ -105,103 +54,4 @@\n \r\n \r\n \r\n \r\n-import { v2 as cloudinary } from 'cloudinary';\r\n-import dotenv from 'dotenv';\r\n-\r\n-dotenv.config();\r\n-\r\n-cloudinary.config({\r\n-  cloud_name: process.env.CLOUD_NAME,\r\n-  api_key: process.env.API_KEY,\r\n-  api_secret: process.env.SECRET_KEY,\r\n-  secure: true,\r\n-});\r\n-\r\n-\r\n-export const uploadToCloudinary\r\n-    } else if (mimetype.startsWith('video')) {\r\n-      resourceType = 'video';\r\n-    }\r\n-\r\n-    const publicId = originalFileName;\r\n-\r\n-    return new Promise((resolve, reject) => {\r\n-      const stream = createReadStream();\r\n-      const cloudinaryStream = cloudinary.v2.uploader.upload_stream(\r\n-        {\r\n-          folder: 'literalouge',\r\n-          resource_type: resourceType,\r\n-          public_id: publicId,\r\n-          use_filename: true, // Uses original filename\r\n-          unique_filename: false, // Prevents Cloudinary from renaming\r\n-        },\r\n-        (error, result) => {\r\n-          if (error) {\r\n-            console.error(\r\n-              `Cloudinary upload error for file ${filename}:`,\r\n-              error\r\n-            );\r\n-            return reject(\r\n-              new Error(\r\n-                `Cloudinary upload failed for ${filename}: ${error.message}`\r\n-              )\r\n-            );\r\n-          }\r\n-          console.log(\r\n-            `File ${filename} uploaded successfully. Secure URL:`,\r\n-            result.secure_url\r\n-          );\r\n-          resolve(result.secure_url);\r\n-        }\r\n-      );\r\n-      stream.pipe(cloudinaryStream);\r\n-    });\r\n-  } catch (err) {\r\n-    console.error('Error in file upload process:', err);\r\n-    throw new Error('File upload process failed');\r\n-  }\r\n-};\r\n-\r\n-\r\n-export const deleteFileFromCloudinary = async (url) => {\r\n-  if (!url) {\r\n-    throw new Error('No URL provided.');\r\n-  }\r\n-  console.log(`Extracting public ID from URL: ${url}`);\r\n-  \r\n-  // Updated regex to capture the folder and public_id for both image and raw uploads.\r\n-  // It will capture any characters after the folder until the last dot before the extension.\r\n-  const match = url.match(/\\/literalouge\\/(.+?)\\.(jpg|jpeg|png|gif|pdf|mp3|epub)$/);\r\n-  if (!match) {\r\n-    throw new Error('Failed to extract public ID from URL.');\r\n-  }\r\n-  \r\n-  // Rebuild the public ID using the folder and captured public_id.\r\n-  const publicId = `literalouge/${match[1]}`;\r\n-  console.log(`Extracted public ID: ${publicId}`);\r\n-\r\n-  try {\r\n-    console.log(`Attempting to delete file with public ID: ${publicId}`);\r\n-    const deletionResult = await cloudinary.uploader.destroy(publicId);\r\n-    console.log('Cloudinary deletion result:', deletionResult);\r\n-\r\n-    if (deletionResult.result === 'ok') {\r\n-      console.log(`Cloudinary file with public ID ${publicId} deleted successfully.`);\r\n-      return deletionResult;\r\n-    } else {\r\n-      throw new Error(`Failed to delete the file from Cloudinary. Response: ${JSON.stringify(deletionResult)}`);\r\n-    }\r\n-  } catch (error) {\r\n-    console.error(`Error deleting file from Cloudinary with public ID ${publicId}:`, error.message);\r\n-    throw new Error(`Cloudinary deletion error: ${error.message}`);\r\n-  }\r\n-};\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n"
                },
                {
                    "date": 1740475661157,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,102 @@\n+import { v2 as cloudinary } from 'cloudinary';\r\n+import dotenv from 'dotenv';\r\n+\r\n+dotenv.config();\r\n+\r\n+cloudinary.config({\r\n+  cloud_name: process.env.CLOUD_NAME,\r\n+  api_key: process.env.API_KEY,\r\n+  api_secret: process.env.SECRET_KEY,\r\n+  secure: true,\r\n+});\r\n+\r\n+\r\n+export const uploadToCloudinary = async (file) => {\r\n+  try {\r\n+    const { createReadStream, filename, mimetype } = await file;\r\n+    const fileExtension = filename.split('.').pop();\r\n+    const originalFileName = filename.replace(`.${fileExtension}`, '');\r\n+\r\n+    let resourceType;\r\n+    if (mimetype.startsWith('image')) {\r\n+      resourceType = 'image';\r\n+    } else if (\r\n+      mimetype === 'application/pdf' ||\r\n+      mimetype === 'application/epub+zip'\r\n+    ) {\r\n+      resourceType = 'raw';\r\n+    } else {\r\n+      throw new Error(`Unsupported file type: ${mimetype}`);\r\n+    }\r\n+\r\n+    const publicId = originalFileName;\r\n+\r\n+    return new Promise((resolve, reject) => {\r\n+      const stream = createReadStream();\r\n+      const cloudinaryStream = cloudinary.uploader.upload_stream(\r\n+        {\r\n+          folder: 'literalouge',\r\n+          resource_type: resourceType,\r\n+          public_id: publicId,\r\n+        },\r\n+        (error, result) => {\r\n+          if (error) {\r\n+            console.error(`Cloudinary upload error for file ${filename}:`, error);\r\n+            return reject(new Error(`Cloudinary upload failed: ${error.message}`));\r\n+          }\r\n+          console.log(`File ${filename} uploaded successfully. Secure URL:`, result.secure_url);\r\n+          resolve(result.secure_url);\r\n+        }\r\n+      );\r\n+      stream.pipe(cloudinaryStream);\r\n+    });\r\n+  } catch (err) {\r\n+    console.error('Error in file upload process:', err);\r\n+    throw new Error('File upload process failed');\r\n+  }\r\n+};\r\n+\r\n+\r\n+\r\n+\r\n+export const deleteFileFromCloudinary = async (url) => {\r\n+  if (!url) {\r\n+    throw new Error('No URL provided.');\r\n+  }\r\n+  console.log(`Extracting public ID from URL: ${url}`);\r\n+  \r\n+  // Updated regex to capture the folder and public_id for both image and raw uploads.\r\n+  // It will capture any characters after the folder until the last dot before the extension.\r\n+  const match = url.match(/\\/literalouge\\/(.+?)\\.(jpg|jpeg|png|gif|pdf|mp3|epub)$/);\r\n+  if (!match) {\r\n+    throw new Error('Failed to extract public ID from URL.');\r\n+  }\r\n+  \r\n+  // Rebuild the public ID using the folder and captured public_id.\r\n+  const publicId = `literalouge/${match[1]}`;\r\n+  console.log(`Extracted public ID: ${publicId}`);\r\n+\r\n+  try {\r\n+    console.log(`Attempting to delete file with public ID: ${publicId}`);\r\n+    const deletionResult = await cloudinary.uploader.destroy(publicId);\r\n+    console.log('Cloudinary deletion result:', deletionResult);\r\n+\r\n+    if (deletionResult.result === 'ok') {\r\n+      console.log(`Cloudinary file with public ID ${publicId} deleted successfully.`);\r\n+      return deletionResult;\r\n+    } else {\r\n+      throw new Error(`Failed to delete the file from Cloudinary. Response: ${JSON.stringify(deletionResult)}`);\r\n+    }\r\n+  } catch (error) {\r\n+    console.error(`Error deleting file from Cloudinary with public ID ${publicId}:`, error.message);\r\n+    throw new Error(`Cloudinary deletion error: ${error.message}`);\r\n+  }\r\n+};\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n"
                },
                {
                    "date": 1740475994636,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,59 @@\n+import { v2 as cloudinary } from 'cloudinary';\r\n+import dotenv from 'dotenv';\r\n+\r\n+dotenv.config();\r\n+\r\n+cloudinary.config({\r\n+  cloud_name: process.env.CLOUD_NAME,\r\n+  api_key: process.env.API_KEY,\r\n+  api_secret: process.env.SECRET_KEY,\r\n+  secure: true,\r\n+});\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+export const deleteFileFromCloudinary = async (url) => {\r\n+  if (!url) {\r\n+    throw new Error('No URL provided.');\r\n+  }\r\n+  console.log(`Extracting public ID from URL: ${url}`);\r\n+  \r\n+  // Updated regex to capture the folder and public_id for both image and raw uploads.\r\n+  // It will capture any characters after the folder until the last dot before the extension.\r\n+  const match = url.match(/\\/literalouge\\/(.+?)\\.(jpg|jpeg|png|gif|pdf|mp3|epub)$/);\r\n+  if (!match) {\r\n+    throw new Error('Failed to extract public ID from URL.');\r\n+  }\r\n+  \r\n+  // Rebuild the public ID using the folder and captured public_id.\r\n+  const publicId = `literalouge/${match[1]}`;\r\n+  console.log(`Extracted public ID: ${publicId}`);\r\n+\r\n+  try {\r\n+    console.log(`Attempting to delete file with public ID: ${publicId}`);\r\n+    const deletionResult = await cloudinary.uploader.destroy(publicId);\r\n+    console.log('Cloudinary deletion result:', deletionResult);\r\n+\r\n+    if (deletionResult.result === 'ok') {\r\n+      console.log(`Cloudinary file with public ID ${publicId} deleted successfully.`);\r\n+      return deletionResult;\r\n+    } else {\r\n+      throw new Error(`Failed to delete the file from Cloudinary. Response: ${JSON.stringify(deletionResult)}`);\r\n+    }\r\n+  } catch (error) {\r\n+    console.error(`Error deleting file from Cloudinary with public ID ${publicId}:`, error.message);\r\n+    throw new Error(`Cloudinary deletion error: ${error.message}`);\r\n+  }\r\n+};\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n"
                },
                {
                    "date": 1740476003095,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -10,85 +10,23 @@\n   secure: true,\r\n });\r\n \r\n \r\n-\r\n-\r\n-\r\n-\r\n-\r\n-export const deleteFileFromCloudinary = async (url) => {\r\n-  if (!url) {\r\n-    throw new Error('No URL provided.');\r\n-  }\r\n-  console.log(`Extracting public ID from URL: ${url}`);\r\n-  \r\n-  // Updated regex to capture the folder and public_id for both image and raw uploads.\r\n-  // It will capture any characters after the folder until the last dot before the extension.\r\n-  const match = url.match(/\\/literalouge\\/(.+?)\\.(jpg|jpeg|png|gif|pdf|mp3|epub)$/);\r\n-  if (!match) {\r\n-    throw new Error('Failed to extract public ID from URL.');\r\n-  }\r\n-  \r\n-  // Rebuild the public ID using the folder and captured public_id.\r\n-  const publicId = `literalouge/${match[1]}`;\r\n-  console.log(`Extracted public ID: ${publicId}`);\r\n-\r\n-  try {\r\n-    console.log(`Attempting to delete file with public ID: ${publicId}`);\r\n-    const deletionResult = await cloudinary.uploader.destroy(publicId);\r\n-    console.log('Cloudinary deletion result:', deletionResult);\r\n-\r\n-    if (deletionResult.result === 'ok') {\r\n-      console.log(`Cloudinary file with public ID ${publicId} deleted successfully.`);\r\n-      return deletionResult;\r\n-    } else {\r\n-      throw new Error(`Failed to delete the file from Cloudinary. Response: ${JSON.stringify(deletionResult)}`);\r\n-    }\r\n-  } catch (error) {\r\n-    console.error(`Error deleting file from Cloudinary with public ID ${publicId}:`, error.message);\r\n-    throw new Error(`Cloudinary deletion error: ${error.message}`);\r\n-  }\r\n-};\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-import { v2 as cloudinary } from 'cloudinary';\r\n-import dotenv from 'dotenv';\r\n-\r\n-dotenv.config();\r\n-\r\n-cloudinary.config({\r\n-  cloud_name: process.env.CLOUD_NAME,\r\n-  api_key: process.env.API_KEY,\r\n-  api_secret: process.env.SECRET_KEY,\r\n-  secure: true,\r\n-});\r\n-\r\n-\r\n export const uploadToCloudinary = async (file) => {\r\n   try {\r\n     const { createReadStream, filename, mimetype } = await file;\r\n     const fileExtension = filename.split('.').pop();\r\n     const originalFileName = filename.replace(`.${fileExtension}`, '');\r\n-\r\n+    \r\n     let resourceType;\r\n     if (mimetype.startsWith('image')) {\r\n       resourceType = 'image';\r\n-    } else if (\r\n-      mimetype === 'application/pdf' ||\r\n-      mimetype === 'application/epub+zip'\r\n-    ) {\r\n-      resourceType = 'raw';\r\n+    } else if (mimetype === 'application/pdf') {\r\n+      resourceType = 'raw'; \r\n     } else {\r\n       throw new Error(`Unsupported file type: ${mimetype}`);\r\n     }\r\n-\r\n+    \r\n     const publicId = originalFileName;\r\n \r\n     return new Promise((resolve, reject) => {\r\n       const stream = createReadStream();\r\n@@ -100,9 +38,9 @@\n         },\r\n         (error, result) => {\r\n           if (error) {\r\n             console.error(`Cloudinary upload error for file ${filename}:`, error);\r\n-            return reject(new Error(`Cloudinary upload failed: ${error.message}`));\r\n+            return reject(new Error(`Cloudinary upload failed for ${filename}: ${error.message}`));\r\n           }\r\n           console.log(`File ${filename} uploaded successfully. Secure URL:`, result.secure_url);\r\n           resolve(result.secure_url);\r\n         }\r\n@@ -158,61 +96,4 @@\n \r\n \r\n \r\n \r\n-import { v2 as cloudinary } from 'cloudinary';\r\n-import dotenv from 'dotenv';\r\n-\r\n-dotenv.config();\r\n-\r\n-cloudinary.config({\r\n-  cloud_name: process.env.CLOUD_NAME,\r\n-  api_key: process.env.API_KEY,\r\n-  api_secret: process.env.SECRET_KEY,\r\n-  secure: true,\r\n-});\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-export const deleteFileFromCloudinary = async (url) => {\r\n-  if (!url) {\r\n-    throw new Error('No URL provided.');\r\n-  }\r\n-  console.log(`Extracting public ID from URL: ${url}`);\r\n-  \r\n-  // Updated regex to capture the folder and public_id for both image and raw uploads.\r\n-  // It will capture any characters after the folder until the last dot before the extension.\r\n-  const match = url.match(/\\/literalouge\\/(.+?)\\.(jpg|jpeg|png|gif|pdf|mp3|epub)$/);\r\n-  if (!match) {\r\n-    throw new Error('Failed to extract public ID from URL.');\r\n-  }\r\n-  \r\n-  // Rebuild the public ID using the folder and captured public_id.\r\n-  const publicId = `literalouge/${match[1]}`;\r\n-  console.log(`Extracted public ID: ${publicId}`);\r\n-\r\n-  try {\r\n-    console.log(`Attempting to delete file with public ID: ${publicId}`);\r\n-    const deletionResult = await cloudinary.uploader.destroy(publicId);\r\n-    console.log('Cloudinary deletion result:', deletionResult);\r\n-\r\n-    if (deletionResult.result === 'ok') {\r\n-      console.log(`Cloudinary file with public ID ${publicId} deleted successfully.`);\r\n-      return deletionResult;\r\n-    } else {\r\n-      throw new Error(`Failed to delete the file from Cloudinary. Response: ${JSON.stringify(deletionResult)}`);\r\n-    }\r\n-  } catch (error) {\r\n-    console.error(`Error deleting file from Cloudinary with public ID ${publicId}:`, error.message);\r\n-    throw new Error(`Cloudinary deletion error: ${error.message}`);\r\n-  }\r\n-};\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n"
                },
                {
                    "date": 1740476013968,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,98 @@\n+import { v2 as cloudinary } from 'cloudinary';\r\n+import dotenv from 'dotenv';\r\n+\r\n+dotenv.config();\r\n+\r\n+cloudinary.config({\r\n+  cloud_name: process.env.CLOUD_NAME,\r\n+  api_key: process.env.API_KEY,\r\n+  api_secret: process.env.SECRET_KEY,\r\n+  secure: true,\r\n+});\r\n+\r\n+\r\n+export const uploadToCloudinary = async (file) => {\r\n+  try {\r\n+    const { createReadStream, filename, mimetype } = await file;\r\n+    const fileExtension = filename.split('.').pop();\r\n+    const originalFileName = filename.replace(`.${fileExtension}`, '');\r\n+    \r\n+    let resourceType;\r\n+    if (mimetype.startsWith('image')) {\r\n+      resourceType = 'image';\r\n+    } else if (mimetype === 'application/pdf') {\r\n+      resourceType = 'raw'; \r\n+    } else {\r\n+      throw new Error(`Unsupported file type: ${mimetype}`);\r\n+    }\r\n+    \r\n+    const publicId = originalFileName;\r\n+\r\n+    return new Promise((resolve, reject) => {\r\n+      const stream = createReadStream();\r\n+      const cloudinaryStream = cloudinary.uploader.upload_stream(\r\n+        {\r\n+          folder: 'literalouge',\r\n+          resource_type: resourceType,\r\n+          public_id: publicId,\r\n+        },\r\n+        (error, result) => {\r\n+          if (error) {\r\n+            console.error(`Cloudinary upload error for file ${filename}:`, error);\r\n+            return reject(new Error(`Cloudinary upload failed for ${filename}: ${error.message}`));\r\n+          }\r\n+          console.log(`File ${filename} uploaded successfully. Secure URL:`, result.secure_url);\r\n+          resolve(result.secure_url);\r\n+        }\r\n+      );\r\n+      stream.pipe(cloudinaryStream);\r\n+    });\r\n+  } catch (err) {\r\n+    console.error('Error in file upload process:', err);\r\n+    throw new Error('File upload process failed');\r\n+  }\r\n+};\r\n+\r\n+\r\n+\r\n+export const deleteFileFromCloudinary = async (url) => {\r\n+  if (!url) {\r\n+    throw new Error('No URL provided.');\r\n+  }\r\n+  console.log(`Extracting public ID from URL: ${url}`);\r\n+  \r\n+  // Updated regex to capture the folder and public_id for both image and raw uploads.\r\n+  // It will capture any characters after the folder until the last dot before the extension.\r\n+  const match = url.match(/\\/literalouge\\/(.+?)\\.(jpg|jpeg|png|gif|pdf|mp3|epub)$/);\r\n+  if (!match) {\r\n+    throw new Error('Failed to extract public ID from URL.');\r\n+  }\r\n+  \r\n+  // Rebuild the public ID using the folder and captured public_id.\r\n+  const publicId = `literalouge/${match[1]}`;\r\n+  console.log(`Extracted public ID: ${publicId}`);\r\n+\r\n+  try {\r\n+    console.log(`Attempting to delete file with public ID: ${publicId}`);\r\n+    const deletionResult = await cloudinary.uploader.destroy(publicId);\r\n+    console.log('Cloudinary deletion result:', deletionResult);\r\n+\r\n+    if (deletionResult.result === 'ok') {\r\n+      console.log(`Cloudinary file with public ID ${publicId} deleted successfully.`);\r\n+      return deletionResult;\r\n+    } else {\r\n+      throw new Error(`Failed to delete the file from Cloudinary. Response: ${JSON.stringify(deletionResult)}`);\r\n+    }\r\n+  } catch (error) {\r\n+    console.error(`Error deleting file from Cloudinary with public ID ${publicId}:`, error.message);\r\n+    throw new Error(`Cloudinary deletion error: ${error.message}`);\r\n+  }\r\n+};\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n"
                },
                {
                    "date": 1740476258075,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,99 @@\n+import { v2 as cloudinary } from 'cloudinary';\r\n+import dotenv from 'dotenv';\r\n+\r\n+dotenv.config();\r\n+\r\n+cloudinary.config({\r\n+  cloud_name: process.env.CLOUD_NAME,\r\n+  api_key: process.env.API_KEY,\r\n+  api_secret: process.env.SECRET_KEY,\r\n+  secure: true,\r\n+});\r\n+\r\n+\r\n+export const uploadToCloudinary = async (file) => {\r\n+  try {\r\n+    const { createReadStream, filename, mimetype } = await file;\r\n+    const fileExtension = filename.split('.').pop();\r\n+    const originalFileName = filename.replace(`.${fileExtension}`, '');\r\n+    \r\n+    let resourceType;\r\n+    if (mimetype.startsWith('image')) {\r\n+      resourceType = 'image';\r\n+    } else if (mimetype === 'application/pdf') {\r\n+      resourceType = 'raw'; \r\n+    } else {\r\n+      throw new Error(`Unsupported file type: ${mimetype}`);\r\n+    }\r\n+    \r\n+    const publicId = originalFileName;\r\n+\r\n+    return new Promise((resolve, reject) => {\r\n+      const stream = createReadStream();\r\n+      const cloudinaryStream = cloudinary.uploader.upload_stream(\r\n+        {\r\n+          folder: 'literalouge',\r\n+          resource_type: resourceType,\r\n+          public_id: publicId,\r\n+        },\r\n+        (error, result) => {\r\n+          if (error) {\r\n+            console.error(`Cloudinary upload error for file ${filename}:`, error);\r\n+            return reject(new Error(`Cloudinary upload failed for ${filename}: ${error.message}`));\r\n+          }\r\n+          console.log(`File ${filename} uploaded successfully. Secure URL:`, result.secure_url);\r\n+          resolve(result.secure_url);\r\n+        }\r\n+      );\r\n+      stream.pipe(cloudinaryStream);\r\n+    });\r\n+  } catch (err) {\r\n+    console.error('Error in file upload process:', err);\r\n+    throw new Error('File upload process failed');\r\n+  }\r\n+};\r\n+\r\n+\r\n+\r\n+\r\n+export const deleteFileFromCloudinary = async (url) => {\r\n+  if (!url) {\r\n+    throw new Error('No URL provided.');\r\n+  }\r\n+  console.log(`Extracting public ID from URL: ${url}`);\r\n+  \r\n+  // Updated regex to capture the folder and public_id for both image and raw uploads.\r\n+  // It will capture any characters after the folder until the last dot before the extension.\r\n+  const match = url.match(/\\/literalouge\\/(.+?)\\.(jpg|jpeg|png|gif|pdf|mp3|epub)$/);\r\n+  if (!match) {\r\n+    throw new Error('Failed to extract public ID from URL.');\r\n+  }\r\n+  \r\n+  // Rebuild the public ID using the folder and captured public_id.\r\n+  const publicId = `literalouge/${match[1]}`;\r\n+  console.log(`Extracted public ID: ${publicId}`);\r\n+\r\n+  try {\r\n+    console.log(`Attempting to delete file with public ID: ${publicId}`);\r\n+    const deletionResult = await cloudinary.uploader.destroy(publicId);\r\n+    console.log('Cloudinary deletion result:', deletionResult);\r\n+\r\n+    if (deletionResult.result === 'ok') {\r\n+      console.log(`Cloudinary file with public ID ${publicId} deleted successfully.`);\r\n+      return deletionResult;\r\n+    } else {\r\n+      throw new Error(`Failed to delete the file from Cloudinary. Response: ${JSON.stringify(deletionResult)}`);\r\n+    }\r\n+  } catch (error) {\r\n+    console.error(`Error deleting file from Cloudinary with public ID ${publicId}:`, error.message);\r\n+    throw new Error(`Cloudinary deletion error: ${error.message}`);\r\n+  }\r\n+};\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n"
                },
                {
                    "date": 1740476267511,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -15,215 +15,20 @@\n   try {\r\n     const { createReadStream, filename, mimetype } = await file;\r\n     const fileExtension = filename.split('.').pop();\r\n     const originalFileName = filename.replace(`.${fileExtension}`, '');\r\n-    \r\n-    let resourceType;\r\n-    if (mimetype.startsWith('image')) {\r\n-      resourceType = 'image';\r\n-    } else if (mimetype === 'application/pdf') {\r\n-      resourceType = 'raw'; \r\n-    } else {\r\n-      throw new Error(`Unsupported file type: ${mimetype}`);\r\n-    }\r\n-    \r\n-    const publicId = originalFileName;\r\n \r\n-    return new Promise((resolve, reject) => {\r\n-      const stream = createReadStream();\r\n-      const cloudinaryStream = cloudinary.uploader.upload_stream(\r\n-        {\r\n-          folder: 'literalouge',\r\n-          resource_type: resourceType,\r\n-          public_id: publicId,\r\n-        },\r\n-        (error, result) => {\r\n-          if (error) {\r\n-            console.error(`Cloudinary upload error for file ${filename}:`, error);\r\n-            return reject(new Error(`Cloudinary upload failed for ${filename}: ${error.message}`));\r\n-          }\r\n-          console.log(`File ${filename} uploaded successfully. Secure URL:`, result.secure_url);\r\n-          resolve(result.secure_url);\r\n-        }\r\n-      );\r\n-      stream.pipe(cloudinaryStream);\r\n-    });\r\n-  } catch (err) {\r\n-    console.error('Error in file upload process:', err);\r\n-    throw new Error('File upload process failed');\r\n-  }\r\n-};\r\n-\r\n-\r\n-\r\n-\r\n-export const deleteFileFromCloudinary = async (url) => {\r\n-  if (!url) {\r\n-    throw new Error('No URL provided.');\r\n-  }\r\n-  console.log(`Extracting public ID from URL: ${url}`);\r\n-  \r\n-  // Updated regex to capture the folder and public_id for both image and raw uploads.\r\n-  // It will capture any characters after the folder until the last dot before the extension.\r\n-  const match = url.match(/\\/literalouge\\/(.+?)\\.(jpg|jpeg|png|gif|pdf|mp3|epub)$/);\r\n-  if (!match) {\r\n-    throw new Error('Failed to extract public ID from URL.');\r\n-  }\r\n-  \r\n-  // Rebuild the public ID using the folder and captured public_id.\r\n-  const publicId = `literalouge/${match[1]}`;\r\n-  console.log(`Extracted public ID: ${publicId}`);\r\n-\r\n-  try {\r\n-    console.log(`Attempting to delete file with public ID: ${publicId}`);\r\n-    const deletionResult = await cloudinary.uploader.destroy(publicId);\r\n-    console.log('Cloudinary deletion result:', deletionResult);\r\n-\r\n-    if (deletionResult.result === 'ok') {\r\n-      console.log(`Cloudinary file with public ID ${publicId} deleted successfully.`);\r\n-      return deletionResult;\r\n-    } else {\r\n-      throw new Error(`Failed to delete the file from Cloudinary. Response: ${JSON.stringify(deletionResult)}`);\r\n-    }\r\n-  } catch (error) {\r\n-    console.error(`Error deleting file from Cloudinary with public ID ${publicId}:`, error.message);\r\n-    throw new Error(`Cloudinary deletion error: ${error.message}`);\r\n-  }\r\n-};\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-import { v2 as cloudinary } from 'cloudinary';\r\n-import dotenv from 'dotenv';\r\n-\r\n-dotenv.config();\r\n-\r\n-cloudinary.config({\r\n-  cloud_name: process.env.CLOUD_NAME,\r\n-  api_key: process.env.API_KEY,\r\n-  api_secret: process.env.SECRET_KEY,\r\n-  secure: true,\r\n-});\r\n-\r\n-\r\n-export const uploadToCloudinary = async (file) => {\r\n-  try {\r\n-    const { createReadStream, filename, mimetype } = await file;\r\n-    const fileExtension = filename.split('.').pop();\r\n-    const originalFileName = filename.replace(`.${fileExtension}`, '');\r\n-    \r\n     let resourceType;\r\n     if (mimetype.startsWith('image')) {\r\n       resourceType = 'image';\r\n-    } else if (mimetype === 'application/pdf') {\r\n-      resourceType = 'raw'; \r\n+    } else if (\r\n+    CCC\r\n+    ) {\r\n+      resourceType = 'raw';\r\n     } else {\r\n       throw new Error(`Unsupported file type: ${mimetype}`);\r\n     }\r\n-    \r\n-    const publicId = originalFileName;\r\n \r\n-    return new Promise((resolve, reject) => {\r\n-      const stream = createReadStream();\r\n-      const cloudinaryStream = cloudinary.uploader.upload_stream(\r\n-        {\r\n-          folder: 'literalouge',\r\n-          resource_type: resourceType,\r\n-          public_id: publicId,\r\n-        },\r\n-        (error, result) => {\r\n-          if (error) {\r\n-            console.error(`Cloudinary upload error for file ${filename}:`, error);\r\n-            return reject(new Error(`Cloudinary upload failed for ${filename}: ${error.message}`));\r\n-          }\r\n-          console.log(`File ${filename} uploaded successfully. Secure URL:`, result.secure_url);\r\n-          resolve(result.secure_url);\r\n-        }\r\n-      );\r\n-      stream.pipe(cloudinaryStream);\r\n-    });\r\n-  } catch (err) {\r\n-    console.error('Error in file upload process:', err);\r\n-    throw new Error('File upload process failed');\r\n-  }\r\n-};\r\n-\r\n-\r\n-\r\n-export const deleteFileFromCloudinary = async (url) => {\r\n-  if (!url) {\r\n-    throw new Error('No URL provided.');\r\n-  }\r\n-  console.log(`Extracting public ID from URL: ${url}`);\r\n-  \r\n-  // Updated regex to capture the folder and public_id for both image and raw uploads.\r\n-  // It will capture any characters after the folder until the last dot before the extension.\r\n-  const match = url.match(/\\/literalouge\\/(.+?)\\.(jpg|jpeg|png|gif|pdf|mp3|epub)$/);\r\n-  if (!match) {\r\n-    throw new Error('Failed to extract public ID from URL.');\r\n-  }\r\n-  \r\n-  // Rebuild the public ID using the folder and captured public_id.\r\n-  const publicId = `literalouge/${match[1]}`;\r\n-  console.log(`Extracted public ID: ${publicId}`);\r\n-\r\n-  try {\r\n-    console.log(`Attempting to delete file with public ID: ${publicId}`);\r\n-    const deletionResult = await cloudinary.uploader.destroy(publicId);\r\n-    console.log('Cloudinary deletion result:', deletionResult);\r\n-\r\n-    if (deletionResult.result === 'ok') {\r\n-      console.log(`Cloudinary file with public ID ${publicId} deleted successfully.`);\r\n-      return deletionResult;\r\n-    } else {\r\n-      throw new Error(`Failed to delete the file from Cloudinary. Response: ${JSON.stringify(deletionResult)}`);\r\n-    }\r\n-  } catch (error) {\r\n-    console.error(`Error deleting file from Cloudinary with public ID ${publicId}:`, error.message);\r\n-    throw new Error(`Cloudinary deletion error: ${error.message}`);\r\n-  }\r\n-};\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-import { v2 as cloudinary } from 'cloudinary';\r\n-import dotenv from 'dotenv';\r\n-\r\n-dotenv.config();\r\n-\r\n-cloudinary.config({\r\n-  cloud_name: process.env.CLOUD_NAME,\r\n-  api_key: process.env.API_KEY,\r\n-  api_secret: process.env.SECRET_KEY,\r\n-  secure: true,\r\n-});\r\n-\r\n-\r\n-export const uploadToCloudinary = async (file) => {\r\n-  try {\r\n-    const { createReadStream, filename, mimetype } = await file;\r\n-    const fileExtension = filename.split('.').pop();\r\n-    const originalFileName = filename.replace(`.${fileExtension}`, '');\r\n-    \r\n-    let resourceType;\r\n-    if (mimetype.startsWith('image')) {\r\n-      resourceType = 'image';\r\n-    } else if (mimetype === 'application/pdf') {\r\n-      resourceType = 'raw'; \r\n-    } else {\r\n-      throw new Error(`Unsupported file type: ${mimetype}`);\r\n-    }\r\n-    \r\n     const publicId = originalFileName;\r\n \r\n     return new Promise((resolve, reject) => {\r\n       const stream = createReadStream();\r\n@@ -235,9 +40,9 @@\n         },\r\n         (error, result) => {\r\n           if (error) {\r\n             console.error(`Cloudinary upload error for file ${filename}:`, error);\r\n-            return reject(new Error(`Cloudinary upload failed for ${filename}: ${error.message}`));\r\n+            return reject(new Error(`Cloudinary upload failed: ${error.message}`));\r\n           }\r\n           console.log(`File ${filename} uploaded successfully. Secure URL:`, result.secure_url);\r\n           resolve(result.secure_url);\r\n         }\r\n"
                },
                {
                    "date": 1740476274455,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,103 @@\n+import { v2 as cloudinary } from 'cloudinary';\r\n+import dotenv from 'dotenv';\r\n+\r\n+dotenv.config();\r\n+\r\n+cloudinary.config({\r\n+  cloud_name: process.env.CLOUD_NAME,\r\n+  api_key: process.env.API_KEY,\r\n+  api_secret: process.env.SECRET_KEY,\r\n+  secure: true,\r\n+});\r\n+\r\n+\r\n+export const uploadToCloudinary = async (file) => {\r\n+  try {\r\n+    const { createReadStream, filename, mimetype } = await file;\r\n+    const fileExtension = filename.split('.').pop();\r\n+    const originalFileName = filename.replace(`.${fileExtension}`, '');\r\n+\r\n+    let resourceType;\r\n+    if (mimetype.startsWith('image')) {\r\n+      resourceType = 'image';\r\n+    } else if (\r\n+      mimetype === 'application/pdf' ||\r\n+      mimetype === 'application/pdf' ||\r\n+      mimetype === 'application/epub+zip'\r\n+    ) {\r\n+      resourceType = 'raw';\r\n+    } else {\r\n+      throw new Error(`Unsupported file type: ${mimetype}`);\r\n+    }\r\n+\r\n+    const publicId = originalFileName;\r\n+\r\n+    return new Promise((resolve, reject) => {\r\n+      const stream = createReadStream();\r\n+      const cloudinaryStream = cloudinary.uploader.upload_stream(\r\n+        {\r\n+          folder: 'literalouge',\r\n+          resource_type: resourceType,\r\n+          public_id: publicId,\r\n+        },\r\n+        (error, result) => {\r\n+          if (error) {\r\n+            console.error(`Cloudinary upload error for file ${filename}:`, error);\r\n+            return reject(new Error(`Cloudinary upload failed: ${error.message}`));\r\n+          }\r\n+          console.log(`File ${filename} uploaded successfully. Secure URL:`, result.secure_url);\r\n+          resolve(result.secure_url);\r\n+        }\r\n+      );\r\n+      stream.pipe(cloudinaryStream);\r\n+    });\r\n+  } catch (err) {\r\n+    console.error('Error in file upload process:', err);\r\n+    throw new Error('File upload process failed');\r\n+  }\r\n+};\r\n+\r\n+\r\n+\r\n+\r\n+export const deleteFileFromCloudinary = async (url) => {\r\n+  if (!url) {\r\n+    throw new Error('No URL provided.');\r\n+  }\r\n+  console.log(`Extracting public ID from URL: ${url}`);\r\n+  \r\n+  // Updated regex to capture the folder and public_id for both image and raw uploads.\r\n+  // It will capture any characters after the folder until the last dot before the extension.\r\n+  const match = url.match(/\\/literalouge\\/(.+?)\\.(jpg|jpeg|png|gif|pdf|mp3|epub)$/);\r\n+  if (!match) {\r\n+    throw new Error('Failed to extract public ID from URL.');\r\n+  }\r\n+  \r\n+  // Rebuild the public ID using the folder and captured public_id.\r\n+  const publicId = `literalouge/${match[1]}`;\r\n+  console.log(`Extracted public ID: ${publicId}`);\r\n+\r\n+  try {\r\n+    console.log(`Attempting to delete file with public ID: ${publicId}`);\r\n+    const deletionResult = await cloudinary.uploader.destroy(publicId);\r\n+    console.log('Cloudinary deletion result:', deletionResult);\r\n+\r\n+    if (deletionResult.result === 'ok') {\r\n+      console.log(`Cloudinary file with public ID ${publicId} deleted successfully.`);\r\n+      return deletionResult;\r\n+    } else {\r\n+      throw new Error(`Failed to delete the file from Cloudinary. Response: ${JSON.stringify(deletionResult)}`);\r\n+    }\r\n+  } catch (error) {\r\n+    console.error(`Error deleting file from Cloudinary with public ID ${publicId}:`, error.message);\r\n+    throw new Error(`Cloudinary deletion error: ${error.message}`);\r\n+  }\r\n+};\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n"
                },
                {
                    "date": 1740476284238,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -10,57 +10,12 @@\n   secure: true,\r\n });\r\n \r\n \r\n-export const uploadToCloudinary = async (file) => {\r\n-  try {\r\n-    const { createReadStream, filename, mimetype } = await file;\r\n-    const fileExtension = filename.split('.').pop();\r\n-    const originalFileName = filename.replace(`.${fileExtension}`, '');\r\n \r\n-    let resourceType;\r\n-    if (mimetype.startsWith('image')) {\r\n-      resourceType = 'image';\r\n-    } else if (\r\n-      mimetype === 'application/pdf' ||\r\n-      mimetype === 'application/pdf' ||\r\n-      mimetype === 'application/epub+zip'\r\n-    ) {\r\n-      resourceType = 'raw';\r\n-    } else {\r\n-      throw new Error(`Unsupported file type: ${mimetype}`);\r\n-    }\r\n \r\n-    const publicId = originalFileName;\r\n \r\n-    return new Promise((resolve, reject) => {\r\n-      const stream = createReadStream();\r\n-      const cloudinaryStream = cloudinary.uploader.upload_stream(\r\n-        {\r\n-          folder: 'literalouge',\r\n-          resource_type: resourceType,\r\n-          public_id: publicId,\r\n-        },\r\n-        (error, result) => {\r\n-          if (error) {\r\n-            console.error(`Cloudinary upload error for file ${filename}:`, error);\r\n-            return reject(new Error(`Cloudinary upload failed: ${error.message}`));\r\n-          }\r\n-          console.log(`File ${filename} uploaded successfully. Secure URL:`, result.secure_url);\r\n-          resolve(result.secure_url);\r\n-        }\r\n-      );\r\n-      stream.pipe(cloudinaryStream);\r\n-    });\r\n-  } catch (err) {\r\n-    console.error('Error in file upload process:', err);\r\n-    throw new Error('File upload process failed');\r\n-  }\r\n-};\r\n \r\n-\r\n-\r\n-\r\n export const deleteFileFromCloudinary = async (url) => {\r\n   if (!url) {\r\n     throw new Error('No URL provided.');\r\n   }\r\n@@ -100,105 +55,4 @@\n \r\n \r\n \r\n \r\n-import { v2 as cloudinary } from 'cloudinary';\r\n-import dotenv from 'dotenv';\r\n-\r\n-dotenv.config();\r\n-\r\n-cloudinary.config({\r\n-  cloud_name: process.env.CLOUD_NAME,\r\n-  api_key: process.env.API_KEY,\r\n-  api_secret: process.env.SECRET_KEY,\r\n-  secure: true,\r\n-});\r\n-\r\n-\r\n-export const uploadToCloudinary = async (file) => {\r\n-  try {\r\n-    const { createReadStream, filename, mimetype } = await file;\r\n-    const fileExtension = filename.split('.').pop();\r\n-    const originalFileName = filename.replace(`.${fileExtension}`, '');\r\n-\r\n-    let resourceType;\r\n-    if (mimetype.startsWith('image')) {\r\n-      resourceType = 'image';\r\n-    } else if (\r\n-    CCC\r\n-    ) {\r\n-      resourceType = 'raw';\r\n-    } else {\r\n-      throw new Error(`Unsupported file type: ${mimetype}`);\r\n-    }\r\n-\r\n-    const publicId = originalFileName;\r\n-\r\n-    return new Promise((resolve, reject) => {\r\n-      const stream = createReadStream();\r\n-      const cloudinaryStream = cloudinary.uploader.upload_stream(\r\n-        {\r\n-          folder: 'literalouge',\r\n-          resource_type: resourceType,\r\n-          public_id: publicId,\r\n-        },\r\n-        (error, result) => {\r\n-          if (error) {\r\n-            console.error(`Cloudinary upload error for file ${filename}:`, error);\r\n-            return reject(new Error(`Cloudinary upload failed: ${error.message}`));\r\n-          }\r\n-          console.log(`File ${filename} uploaded successfully. Secure URL:`, result.secure_url);\r\n-          resolve(result.secure_url);\r\n-        }\r\n-      );\r\n-      stream.pipe(cloudinaryStream);\r\n-    });\r\n-  } catch (err) {\r\n-    console.error('Error in file upload process:', err);\r\n-    throw new Error('File upload process failed');\r\n-  }\r\n-};\r\n-\r\n-\r\n-\r\n-\r\n-export const deleteFileFromCloudinary = async (url) => {\r\n-  if (!url) {\r\n-    throw new Error('No URL provided.');\r\n-  }\r\n-  console.log(`Extracting public ID from URL: ${url}`);\r\n-  \r\n-  // Updated regex to capture the folder and public_id for both image and raw uploads.\r\n-  // It will capture any characters after the folder until the last dot before the extension.\r\n-  const match = url.match(/\\/literalouge\\/(.+?)\\.(jpg|jpeg|png|gif|pdf|mp3|epub)$/);\r\n-  if (!match) {\r\n-    throw new Error('Failed to extract public ID from URL.');\r\n-  }\r\n-  \r\n-  // Rebuild the public ID using the folder and captured public_id.\r\n-  const publicId = `literalouge/${match[1]}`;\r\n-  console.log(`Extracted public ID: ${publicId}`);\r\n-\r\n-  try {\r\n-    console.log(`Attempting to delete file with public ID: ${publicId}`);\r\n-    const deletionResult = await cloudinary.uploader.destroy(publicId);\r\n-    console.log('Cloudinary deletion result:', deletionResult);\r\n-\r\n-    if (deletionResult.result === 'ok') {\r\n-      console.log(`Cloudinary file with public ID ${publicId} deleted successfully.`);\r\n-      return deletionResult;\r\n-    } else {\r\n-      throw new Error(`Failed to delete the file from Cloudinary. Response: ${JSON.stringify(deletionResult)}`);\r\n-    }\r\n-  } catch (error) {\r\n-    console.error(`Error deleting file from Cloudinary with public ID ${publicId}:`, error.message);\r\n-    throw new Error(`Cloudinary deletion error: ${error.message}`);\r\n-  }\r\n-};\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n"
                },
                {
                    "date": 1740476292519,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -10,12 +10,62 @@\n   secure: true,\r\n });\r\n \r\n \r\n+export const uploadToCloudinary = async (file) => {\r\n+  try {\r\n+    const { createReadStream, filename, mimetype } = await file;\r\n+    const fileExtension = filename.split('.').pop();\r\n+    const originalFileName = filename.replace(`.${fileExtension}`, '');\r\n \r\n+    // Determine resource type\r\n+    let resourceType = 'raw'; // Default to raw for non-image/video files\r\n+    if (mimetype.startsWith('image')) {\r\n+      resourceType = 'image';\r\n+    } else if (mimetype.startsWith('video')) {\r\n+      resourceType = 'video';\r\n+    }\r\n \r\n+    const publicId = originalFileName;\r\n \r\n+    return new Promise((resolve, reject) => {\r\n+      const stream = createReadStream();\r\n+      const cloudinaryStream = cloudinary.v2.uploader.upload_stream(\r\n+        {\r\n+          folder: 'literalouge',\r\n+          resource_type: resourceType,\r\n+          public_id: publicId,\r\n+          use_filename: true, // Uses original filename\r\n+          unique_filename: false, // Prevents Cloudinary from renaming\r\n+        },\r\n+        (error, result) => {\r\n+          if (error) {\r\n+            console.error(\r\n+              `Cloudinary upload error for file ${filename}:`,\r\n+              error\r\n+            );\r\n+            return reject(\r\n+              new Error(\r\n+                `Cloudinary upload failed for ${filename}: ${error.message}`\r\n+              )\r\n+            );\r\n+          }\r\n+          console.log(\r\n+            `File ${filename} uploaded successfully. Secure URL:`,\r\n+            result.secure_url\r\n+          );\r\n+          resolve(result.secure_url);\r\n+        }\r\n+      );\r\n+      stream.pipe(cloudinaryStream);\r\n+    });\r\n+  } catch (err) {\r\n+    console.error('Error in file upload process:', err);\r\n+    throw new Error('File upload process failed');\r\n+  }\r\n+};\r\n \r\n+\r\n export const deleteFileFromCloudinary = async (url) => {\r\n   if (!url) {\r\n     throw new Error('No URL provided.');\r\n   }\r\n"
                },
                {
                    "date": 1740476301405,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -9,34 +9,35 @@\n   api_secret: process.env.SECRET_KEY,\r\n   secure: true,\r\n });\r\n \r\n-\r\n export const uploadToCloudinary = async (file) => {\r\n   try {\r\n     const { createReadStream, filename, mimetype } = await file;\r\n     const fileExtension = filename.split('.').pop();\r\n     const originalFileName = filename.replace(`.${fileExtension}`, '');\r\n \r\n-    // Determine resource type\r\n-    let resourceType = 'raw'; // Default to raw for non-image/video files\r\n+    let resourceType;\r\n     if (mimetype.startsWith('image')) {\r\n       resourceType = 'image';\r\n-    } else if (mimetype.startsWith('video')) {\r\n-      resourceType = 'video';\r\n+    } else if (\r\n+      mimetype === 'application/pdf' ||\r\n+      mimetype === 'application/epub+zip'\r\n+    ) {\r\n+      resourceType = 'raw';\r\n+    } else {\r\n+      throw new Error(`Unsupported file type: ${mimetype}`);\r\n     }\r\n \r\n     const publicId = originalFileName;\r\n \r\n     return new Promise((resolve, reject) => {\r\n       const stream = createReadStream();\r\n-      const cloudinaryStream = cloudinary.v2.uploader.upload_stream(\r\n+      const cloudinaryStream = cloudinary.uploader.upload_stream(\r\n         {\r\n           folder: 'literalouge',\r\n           resource_type: resourceType,\r\n           public_id: publicId,\r\n-          use_filename: true, // Uses original filename\r\n-          unique_filename: false, // Prevents Cloudinary from renaming\r\n         },\r\n         (error, result) => {\r\n           if (error) {\r\n             console.error(\r\n"
                },
                {
                    "date": 1740476307511,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -9,64 +9,12 @@\n   api_secret: process.env.SECRET_KEY,\r\n   secure: true,\r\n });\r\n \r\n-export const uploadToCloudinary = async (file) => {\r\n-  try {\r\n-    const { createReadStream, filename, mimetype } = await file;\r\n-    const fileExtension = filename.split('.').pop();\r\n-    const originalFileName = filename.replace(`.${fileExtension}`, '');\r\n-\r\n-    let resourceType;\r\n-    if (mimetype.startsWith('image')) {\r\n-      resourceType = 'image';\r\n-    } else if (\r\n-      mimetype === 'application/pdf' ||\r\n+ mimetype === 'application/pdf' ||\r\n       mimetype === 'application/epub+zip'\r\n-    ) {\r\n-      resourceType = 'raw';\r\n-    } else {\r\n-      throw new Error(`Unsupported file type: ${mimetype}`);\r\n-    }\r\n \r\n-    const publicId = originalFileName;\r\n \r\n-    return new Promise((resolve, reject) => {\r\n-      const stream = createReadStream();\r\n-      const cloudinaryStream = cloudinary.uploader.upload_stream(\r\n-        {\r\n-          folder: 'literalouge',\r\n-          resource_type: resourceType,\r\n-          public_id: publicId,\r\n-        },\r\n-        (error, result) => {\r\n-          if (error) {\r\n-            console.error(\r\n-              `Cloudinary upload error for file ${filename}:`,\r\n-              error\r\n-            );\r\n-            return reject(\r\n-              new Error(\r\n-                `Cloudinary upload failed for ${filename}: ${error.message}`\r\n-              )\r\n-            );\r\n-          }\r\n-          console.log(\r\n-            `File ${filename} uploaded successfully. Secure URL:`,\r\n-            result.secure_url\r\n-          );\r\n-          resolve(result.secure_url);\r\n-        }\r\n-      );\r\n-      stream.pipe(cloudinaryStream);\r\n-    });\r\n-  } catch (err) {\r\n-    console.error('Error in file upload process:', err);\r\n-    throw new Error('File upload process failed');\r\n-  }\r\n-};\r\n-\r\n-\r\n export const deleteFileFromCloudinary = async (url) => {\r\n   if (!url) {\r\n     throw new Error('No URL provided.');\r\n   }\r\n"
                },
                {
                    "date": 1740476332326,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -13,11 +13,51 @@\n  mimetype === 'application/pdf' ||\r\n       mimetype === 'application/epub+zip'\r\n \r\n \r\n+      export const uploadToCloudinary = async (file) => {\r\n+        try {\r\n+          const { createReadStream, filename, mimetype } = await file;\r\n+          const fileExtension = filename.split('.').pop();\r\n+          const originalFileName = filename.replace(`.${fileExtension}`, '');\r\n+          \r\n+          let resourceType;\r\n+          if (mimetype.startsWith('image')) {\r\n+            resourceType = 'image';\r\n+          } else if (mimetype === 'application/pdf') {\r\n+            resourceType = 'raw'; \r\n+          } else {\r\n+            throw new Error(`Unsupported file type: ${mimetype}`);\r\n+          }\r\n+          \r\n+          const publicId = originalFileName;\r\n+      \r\n+          return new Promise((resolve, reject) => {\r\n+            const stream = createReadStream();\r\n+            const cloudinaryStream = cloudinary.uploader.upload_stream(\r\n+              {\r\n+                folder: 'literalouge',\r\n+                resource_type: resourceType,\r\n+                public_id: publicId,\r\n+              },\r\n+              (error, result) => {\r\n+                if (error) {\r\n+                  console.error(`Cloudinary upload error for file ${filename}:`, error);\r\n+                  return reject(new Error(`Cloudinary upload failed for ${filename}: ${error.message}`));\r\n+                }\r\n+                console.log(`File ${filename} uploaded successfully. Secure URL:`, result.secure_url);\r\n+                resolve(result.secure_url);\r\n+              }\r\n+            );\r\n+            stream.pipe(cloudinaryStream);\r\n+          });\r\n+        } catch (err) {\r\n+          console.error('Error in file upload process:', err);\r\n+          throw new Error('File upload process failed');\r\n+        }\r\n+      };\r\n \r\n \r\n-\r\n export const deleteFileFromCloudinary = async (url) => {\r\n   if (!url) {\r\n     throw new Error('No URL provided.');\r\n   }\r\n"
                },
                {
                    "date": 1741794852181,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -101,9 +101,9 @@\n             throw new Error('No URL provided.');\r\n           }\r\n           console.log(`Extracting public ID from URL: ${url}`);\r\n           const decodedUrl = decodeURIComponent(url)\r\n-          const publicId = \"literalouge/\"; // Assuming it's stored under this public ID in Cloudinary\r\n+          const publicId = \"literalouge/d\"; // Assuming it's stored under this public ID in Cloudinary\r\n       \r\n           console.log(`Attempting to delete Cloudinary file with public ID: ${publicId}`);\r\n       \r\n           const deletionResult = await cloudinary.uploader.destroy(publicId, {\r\n"
                }
            ],
            "date": 1740473351490,
            "name": "Commit-0",
            "content": "import dotenv from 'dotenv';\r\nimport fs from 'fs';\r\nimport fetch from 'node-fetch';\r\nimport FormData from 'form-data';\r\n\r\ndotenv.config();\r\n\r\nconst PUBLIC_KEY = process.env.UPLOADCARE_PUBLIC_KEY;\r\nconst SECRET_KEY = process.env.UPLOADCARE_SECRET_KEY;\r\n\r\n// Function to upload file to Uploadcare\r\nexport const uploadToUploadcare = async (file) => {\r\n  try {\r\n    // Destructure file properties from your file object\r\n    const { createReadStream, filename, mimetype } = await file;\r\n    const fileExtension = filename.split('.').pop();\r\n    const originalFileName = filename.replace(`.${fileExtension}`, '');\r\n\r\n    // Create a FormData instance\r\n    const form = new FormData();\r\n    form.append('UPLOADCARE_PUB_KEY', PUBLIC_KEY);\r\n    form.append('UPLOADCARE_STORE', 'auto'); // auto, yes, or no depending on your needs\r\n\r\n    // Append file stream. Note: Uploadcare accepts any file type.\r\n    // We donâ€™t need to specify a resource type like Cloudinary.\r\n    form.append('file', createReadStream(), { filename });\r\n\r\n    // Upload endpoint (base)\r\n    const uploadUrl = 'https://upload.uploadcare.com/base/';\r\n\r\n    const response = await fetch(uploadUrl, {\r\n      method: 'POST',\r\n      body: form,\r\n    });\r\n\r\n    const result = await response.json();\r\n\r\n    if (!response.ok) {\r\n      console.error(`Uploadcare error for file ${filename}:`, result);\r\n      throw new Error(`Uploadcare upload failed for ${filename}: ${JSON.stringify(result)}`);\r\n    }\r\n\r\n    console.log(`File ${filename} uploaded successfully. File UUID:`, result.file);\r\n    // You can construct the CDN URL as follows:\r\n    const cdnUrl = `https://ucarecdn.com/${result.file}/`;\r\n    return cdnUrl;\r\n  } catch (err) {\r\n    console.error('Error in file upload process:', err);\r\n    throw new Error('File upload process failed');\r\n  }\r\n};\r\n\r\n/**\r\n * NOTE: Uploadcare does not provide a simple file deletion API similar to Cloudinary's destroy.\r\n * To \"delete\" a file, you typically need to remove it from your storage in the Uploadcare dashboard.\r\n * There is an API endpoint for file removal (https://uploadcare.com/api-refs/upload-api/#remove-file),\r\n * but it requires additional authentication and is often managed via your account settings.\r\n *\r\n * If you need to remove a file via API, see:\r\n * https://uploadcare.com/docs/api_reference/console/#/files-delete-file\r\n *\r\n * For demonstration, here is a basic deletion function using node-fetch.\r\n */\r\nexport const deleteFileFromUploadcare = async (uuid) => {\r\n  if (!uuid) {\r\n    throw new Error('No file UUID provided.');\r\n  }\r\n\r\n  // Build deletion URL:\r\n  const deletionUrl = `https://api.uploadcare.com/files/${uuid}/`;\r\n\r\n  try {\r\n    const response = await fetch(deletionUrl, {\r\n      method: 'DELETE',\r\n      headers: {\r\n        'Accept': 'application/vnd.uploadcare-v0.6+json',\r\n        'Authorization': `Uploadcare.Simple ${PUBLIC_KEY}:${SECRET_KEY}`,\r\n      },\r\n    });\r\n\r\n    const result = await response.json();\r\n\r\n    if (!response.ok) {\r\n      console.error(`Error deleting file with UUID ${uuid}:`, result);\r\n      throw new Error(`Uploadcare deletion failed for UUID ${uuid}: ${JSON.stringify(result)}`);\r\n    }\r\n\r\n    console.log(`File with UUID ${uuid} deleted successfully.`, result);\r\n    return result;\r\n  } catch (error) {\r\n    console.error(`Error deleting file with UUID ${uuid}:`, error.message);\r\n    throw new Error(`Uploadcare deletion error: ${error.message}`);\r\n  }\r\n};\r\n"
        }
    ]
}