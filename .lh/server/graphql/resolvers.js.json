{
    "sourceFile": "server/graphql/resolvers.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 19,
            "patches": [
                {
                    "date": 1736577786099,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1736577810176,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -85,9 +85,9 @@\n   },\r\n \r\n   Mutation: {\r\n \r\n-    addBook: async (_,  { addbook }) => {\r\n+    addBook: async ( applyTokenChecker,_, { addbook }) => {\r\n       try {\r\n         const {\r\n           bookCover,\r\n           bookName,\r\n"
                },
                {
                    "date": 1736577824756,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -85,9 +85,9 @@\n   },\r\n \r\n   Mutation: {\r\n \r\n-    addBook: async ( applyTokenChecker,_, { addbook }) => {\r\n+    addBook: async (_,  { addbook }) => {\r\n       try {\r\n         const {\r\n           bookCover,\r\n           bookName,\r\n"
                },
                {
                    "date": 1736577831673,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -85,9 +85,9 @@\n   },\r\n \r\n   Mutation: {\r\n \r\n-    addBook: async (_,  { addbook }) => {\r\n+    addBook: (async (_, { addbook }) => {\r\n       try {\r\n         const {\r\n           bookCover,\r\n           bookName,\r\n"
                },
                {
                    "date": 1736577837219,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,287 @@\n+import Book from \"../models/book.js\";\r\n+import User from \"../models/user.js\";\r\n+import bcrypt from \"bcrypt\";\r\n+import { GraphQLUpload } from 'graphql-upload';\r\n+import { Op } from 'sequelize';   \r\n+import jwt from'jsonwebtoken';\r\n+import { applyTokenChecker, uploadToCloudinary, deleteOldFileFromCloudinary, extractPublicId } from \"../config/cloudinary.js\";\r\n+\r\n+\r\n+\r\n+\r\n+export const resolvers = {\r\n+  Upload: GraphQLUpload,\r\n+\r\n+  Query: {\r\n+    books: async (_, { page = 1, perPage = 9 }) => {\r\n+      try {\r\n+          const offset = (page - 1) * perPage;\r\n+          const { rows: allBooks, count: totalBooks } = await Book.findAndCountAll({\r\n+              order: [['createdAt', 'DESC']],\r\n+              limit: perPage,\r\n+          offset: offset,\r\n+          });\r\n+          const lastPage = Math.ceil(totalBooks / perPage);\r\n+        const currentPage = page;\r\n+        const previousPage = currentPage-1;\r\n+        const nextPage = currentPage+1; \r\n+          return {\r\n+              allBooks,\r\n+             currentPage,\r\n+              previousPage,\r\n+              nextPage,\r\n+              lastPage,\r\n+          };\r\n+      } catch (error) {\r\n+          console.error('Error fetching books:', error);\r\n+          throw new Error('Unable to fetch books at the moment');\r\n+      }\r\n+  },\r\n+  \r\n+    book: async (_, args) => {\r\n+      try {\r\n+        const data = await Book.findOne({ where: { id: args.id } });\r\n+        return data;\r\n+      } catch (error) {\r\n+        throw new Error(error.message);\r\n+      }\r\n+    },\r\n+\r\n+    users: async () => {\r\n+      try {\r\n+        const data = await User.findAll();\r\n+        return data;\r\n+      } catch (error) {\r\n+        throw new Error(error.message);\r\n+      }\r\n+    },\r\n+\r\n+    user: async (_, args) => {\r\n+      try {\r\n+        const data = await User.findOne({ where: { id: args.id } });\r\n+        return data;\r\n+      } catch (error) {\r\n+        throw new Error(error.message);\r\n+      }\r\n+    },\r\n+\r\n+    searchBooks: async (_, { searchTerm }) => {\r\n+      try {\r\n+        const lowerCaseSearchTerm = `%${searchTerm.toLowerCase()}%`; \r\n+        const books = await Book.findAll({\r\n+          where: {\r\n+            [Op.or]: [\r\n+              { bookName: { [Op.like]: lowerCaseSearchTerm } },\r\n+              { bookAuthor: { [Op.like]: lowerCaseSearchTerm } },\r\n+              { bookDescription: { [Op.like]: lowerCaseSearchTerm } }\r\n+            ]\r\n+          }\r\n+        });\r\n+        return books;\r\n+      } catch (error) {\r\n+        throw new Error(\"Error fetching books: \" + error.message);\r\n+      }\r\n+    }\r\n+  },\r\n+\r\n+  Mutation: {\r\n+\r\n+    addBook: (applyTokenChecker, async (_, { addbook }) => {\r\n+      try {\r\n+        const {\r\n+          bookCover,\r\n+          bookName,\r\n+          bookDescription,\r\n+          bookAuthor,\r\n+          bookCategory,\r\n+          bookLanguage,\r\n+          bookFile,\r\n+        } = addbook;\r\n+        if (!bookName || !bookDescription || !bookAuthor || !bookCategory || !bookLanguage) {\r\n+          throw new Error(\"All required fields (except files) must be provided.\");\r\n+        }\r\n+        const bookCoverUrl = bookCover ? await uploadToCloudinary(bookCover) : null;\r\n+        const bookFileUrl = bookFile ? await uploadToCloudinary(bookFile) : null;\r\n+        const newBook = await Book.create({\r\n+          bookCover: bookCoverUrl,\r\n+          bookName,\r\n+          bookDescription,\r\n+          bookAuthor,\r\n+          bookCategory,\r\n+          bookLanguage,\r\n+          bookFile: bookFileUrl,\r\n+          // postedBy:req.adminId\r\n+        });\r\n+        console.log(newBook)\r\n+      //   return newBook;\r\n+      } catch (error) {\r\n+        console.error(\"Error adding book:\", error.message);\r\n+        throw new Error(\"Failed to add book. Please try again.\");\r\n+      }\r\n+    },\r\n+     \r\n+\r\n+    // Update a book\r\n+    updateBook: async (_, args) => {\r\n+      try {\r\n+        const { bookCover, bookName, bookDescription, bookAuthor, bookCategory, bookLanguage, bookFile } = args.updatebook;\r\n+        const existingBook = await Book.findOne({ where: { id: args.id } });\r\n+        if (!existingBook) {\r\n+          throw new Error('Book not found');\r\n+        }\r\n+        const bookCoverUrl = bookCover ? await uploadToCloudinary(bookCover) : existingBook.bookCover;\r\n+        const bookFileUrl = bookFile ? await uploadToCloudinary(bookFile) : existingBook.bookFile;\r\n+        const [updateCount] = await Book.update(\r\n+          {\r\n+            bookCover: bookCoverUrl || existingBook.bookCover,\r\n+            bookName: bookName || existingBook.bookName,\r\n+            bookDescription: bookDescription || existingBook.bookDescription,\r\n+            bookAuthor: bookAuthor || existingBook.bookAuthor,\r\n+            bookCategory: bookCategory || existingBook.bookCategory,\r\n+            bookLanguage: bookLanguage || existingBook.bookLanguage,\r\n+            bookFile: bookFileUrl || existingBook.bookFile\r\n+          },\r\n+          { where: { id: args.id } }\r\n+        );\r\n+        if (updateCount === 0) {\r\n+          throw new Error('No changes detected');\r\n+        }\r\n+        const updatedBook = await Book.findOne({ where: { id: args.id } });\r\n+        return {success: true, message: `Boook info updated successfully` };\r\n+      } catch (error) {\r\n+        console.error('Error during deleteBook operation:', error.message);\r\n+        return {success: false, message: `Error deleting book: ${error.message}`};\r\n+      }\r\n+    },\r\n+  \r\n+    \r\n+    deleteBook: async (_, { id }) => {\r\n+      try {\r\n+        const book = await Book.findByPk(id);\r\n+        if (!book) {\r\n+          throw new Error('Book not found.');\r\n+        }\r\n+     if (book.bookCover) {\r\n+    const coverPublicId = extractPublicId(book.bookCover);\r\n+    if (coverPublicId) {\r\n+      console.log(`Deleting book cover with public ID: ${coverPublicId}`);\r\n+      try {\r\n+        await deleteOldFileFromCloudinary(coverPublicId);\r\n+      } catch (error) {\r\n+        console.error(`Failed to delete book cover: ${error.message}`);\r\n+      }\r\n+    } else {\r\n+      console.warn('No valid public ID found for book cover.');\r\n+        }\r\n+      }\r\n+  if (book.bookFile) {\r\n+    const filePublicId = extractPublicId(book.bookFile);\r\n+    if (filePublicId) {\r\n+      console.log(`Deleting book file with public ID: ${filePublicId}`);\r\n+      try {\r\n+        await deleteOldFileFromCloudinary(filePublicId);\r\n+      } catch (error) {\r\n+        console.error(`Failed to delete book file: ${error.message}`);\r\n+      }\r\n+    } else {\r\n+      console.warn('No valid public ID found for book file.');\r\n+    }\r\n+  }\r\n+        const deleteCount = await Book.destroy({ where: { id } });\r\n+        if (deleteCount === 0) {\r\n+          throw new Error('Failed to delete book from the database.');\r\n+        }\r\n+        return {\r\n+          success: true,\r\n+          message: 'Book and associated files deleted successfully.',\r\n+        };\r\n+      } catch (error) {\r\n+        console.error('Error during deleteBook operation:', error.message);\r\n+        return {\r\n+          success: false,\r\n+          message: `Error deleting book: ${error.message}`,\r\n+        };\r\n+      }\r\n+    },\r\n+    \r\n+    \r\n+\r\n+    // User signup\r\n+    signup: async (_, args) => {\r\n+      try {\r\n+        const { username, phoneNumber, email, password } = args.signupuser;\r\n+        const hashedPassword = await bcrypt.hash(password, 10);\r\n+        const data = await User.create({\r\n+          username,\r\n+          phoneNumber,\r\n+          email,\r\n+          password: hashedPassword\r\n+        });\r\n+        return data;\r\n+      } catch (error) {\r\n+        throw new Error(error.message);\r\n+      }\r\n+    },\r\n+    \r\n+    login: async (_, args, context) => {\r\n+      const { req } = context;\r\n+      const { username, password } = args.loginuser;\r\n+      try {\r\n+        const user = await User.findOne({ where: { username } });\r\n+        if (!user) {\r\n+         throw new Error('Incorrect username or password'); \r\n+        }\r\n+        const passwordMatch = await bcrypt.compare(password, user.password);   \r\n+              if (!passwordMatch) {\r\n+               throw new Error('Incorrect username or password'); \r\n+              }\r\n+              const token = jwt.sign({ userId: user.id, email:user.email }, process.env.SECRET_STRING, {expiresIn:'5h'})\r\n+              \r\n+            return { role: user.role, userId: user.id, token };\r\n+      } catch (error) {\r\n+        console.error(\"Error logging in:\", error.message);\r\n+        throw new Error(\"Login unsuccessful. Please try again.\");\r\n+      }\r\n+    },\r\n+\r\n+  \r\n+    updateUser: async (_, args) => {\r\n+      try {\r\n+        const existingUser =  User.findOne({where: {}})\r\n+        const { profilePic, fullName, username, phoneNumber, email } = args.updateuser;\r\n+        const profilePicUrl = profilePic ? await uploadToCloudinary(profilePic) : existingUser.profilePic;\r\n+        const [updateCount] = await User.update(\r\n+          {  \r\n+            profilePic: profilePicUrl, \r\n+             fullName: fullName || existingUser.fullName, \r\n+             username: username || existingUser.username, \r\n+             phoneNumber: phoneNumber || existingUser.phoneNumber, \r\n+             email: email || existingUser.email,\r\n+         },\r\n+          { where: { id: args.id } }\r\n+        );\r\n+        if (updateCount === 0) {\r\n+          throw new Error('User not found or nothing to update');\r\n+        }\r\n+        return { success: true, message: `User info updated successfully` };\r\n+      } catch (error) {\r\n+        return { success: false, message: `Error updating user: ${error.message}` };\r\n+      }\r\n+    },\r\n+\r\n+\r\n+    deleteUser: async (_, { id }) => {\r\n+      try {\r\n+        const user = await User.findByPk(id);\r\n+        if (!user) throw new Error(\"User not found\");\r\n+        const del = await User.destroy({ where: { id } });\r\n+        if (!del) throw new Error(\"Deletion not successful\");\r\n+        return { success: true, message: \"User info deleted successfully.\" };\r\n+      } catch (error) {\r\n+        return { success: false, message: `Error deleting user: ${error.message}` };\r\n+      }\r\n+    },\r\n+\r\n+\r\n+  }\r\n+};\r\n"
                },
                {
                    "date": 1736577843241,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,287 @@\n+import Book from \"../models/book.js\";\r\n+import User from \"../models/user.js\";\r\n+import bcrypt from \"bcrypt\";\r\n+import { GraphQLUpload } from 'graphql-upload';\r\n+import { Op } from 'sequelize';   \r\n+import jwt from'jsonwebtoken';\r\n+import { applyTokenChecker, uploadToCloudinary, deleteOldFileFromCloudinary, extractPublicId } from \"../config/cloudinary.js\";\r\n+\r\n+\r\n+\r\n+\r\n+export const resolvers = {\r\n+  Upload: GraphQLUpload,\r\n+\r\n+  Query: {\r\n+    books: async (_, { page = 1, perPage = 9 }) => {\r\n+      try {\r\n+          const offset = (page - 1) * perPage;\r\n+          const { rows: allBooks, count: totalBooks } = await Book.findAndCountAll({\r\n+              order: [['createdAt', 'DESC']],\r\n+              limit: perPage,\r\n+          offset: offset,\r\n+          });\r\n+          const lastPage = Math.ceil(totalBooks / perPage);\r\n+        const currentPage = page;\r\n+        const previousPage = currentPage-1;\r\n+        const nextPage = currentPage+1; \r\n+          return {\r\n+              allBooks,\r\n+             currentPage,\r\n+              previousPage,\r\n+              nextPage,\r\n+              lastPage,\r\n+          };\r\n+      } catch (error) {\r\n+          console.error('Error fetching books:', error);\r\n+          throw new Error('Unable to fetch books at the moment');\r\n+      }\r\n+  },\r\n+  \r\n+    book: async (_, args) => {\r\n+      try {\r\n+        const data = await Book.findOne({ where: { id: args.id } });\r\n+        return data;\r\n+      } catch (error) {\r\n+        throw new Error(error.message);\r\n+      }\r\n+    },\r\n+\r\n+    users: async () => {\r\n+      try {\r\n+        const data = await User.findAll();\r\n+        return data;\r\n+      } catch (error) {\r\n+        throw new Error(error.message);\r\n+      }\r\n+    },\r\n+\r\n+    user: async (_, args) => {\r\n+      try {\r\n+        const data = await User.findOne({ where: { id: args.id } });\r\n+        return data;\r\n+      } catch (error) {\r\n+        throw new Error(error.message);\r\n+      }\r\n+    },\r\n+\r\n+    searchBooks: async (_, { searchTerm }) => {\r\n+      try {\r\n+        const lowerCaseSearchTerm = `%${searchTerm.toLowerCase()}%`; \r\n+        const books = await Book.findAll({\r\n+          where: {\r\n+            [Op.or]: [\r\n+              { bookName: { [Op.like]: lowerCaseSearchTerm } },\r\n+              { bookAuthor: { [Op.like]: lowerCaseSearchTerm } },\r\n+              { bookDescription: { [Op.like]: lowerCaseSearchTerm } }\r\n+            ]\r\n+          }\r\n+        });\r\n+        return books;\r\n+      } catch (error) {\r\n+        throw new Error(\"Error fetching books: \" + error.message);\r\n+      }\r\n+    }\r\n+  },\r\n+\r\n+  Mutation: {\r\n+\r\n+    addBook: (applyTokenChecker, async (_, { addbook }) => {\r\n+      try {\r\n+        const {\r\n+          bookCover,\r\n+          bookName,\r\n+          bookDescription,\r\n+          bookAuthor,\r\n+          bookCategory,\r\n+          bookLanguage,\r\n+          bookFile,\r\n+        } = addbook;\r\n+        if (!bookName || !bookDescription || !bookAuthor || !bookCategory || !bookLanguage) {\r\n+          throw new Error(\"All required fields (except files) must be provided.\");\r\n+        }\r\n+        const bookCoverUrl = bookCover ? await uploadToCloudinary(bookCover) : null;\r\n+        const bookFileUrl = bookFile ? await uploadToCloudinary(bookFile) : null;\r\n+        const newBook = await Book.create({\r\n+          bookCover: bookCoverUrl,\r\n+          bookName,\r\n+          bookDescription,\r\n+          bookAuthor,\r\n+          bookCategory,\r\n+          bookLanguage,\r\n+          bookFile: bookFileUrl,\r\n+          // postedBy:req.adminId\r\n+        });\r\n+        console.log(newBook)\r\n+      //   return newBook;\r\n+      } catch (error) {\r\n+        console.error(\"Error adding book:\", error.message);\r\n+        throw new Error(\"Failed to add book. Please try again.\");\r\n+      }\r\n+    }),\r\n+     \r\n+\r\n+    // Update a book\r\n+    updateBook: async (_, args) => {\r\n+      try {\r\n+        const { bookCover, bookName, bookDescription, bookAuthor, bookCategory, bookLanguage, bookFile } = args.updatebook;\r\n+        const existingBook = await Book.findOne({ where: { id: args.id } });\r\n+        if (!existingBook) {\r\n+          throw new Error('Book not found');\r\n+        }\r\n+        const bookCoverUrl = bookCover ? await uploadToCloudinary(bookCover) : existingBook.bookCover;\r\n+        const bookFileUrl = bookFile ? await uploadToCloudinary(bookFile) : existingBook.bookFile;\r\n+        const [updateCount] = await Book.update(\r\n+          {\r\n+            bookCover: bookCoverUrl || existingBook.bookCover,\r\n+            bookName: bookName || existingBook.bookName,\r\n+            bookDescription: bookDescription || existingBook.bookDescription,\r\n+            bookAuthor: bookAuthor || existingBook.bookAuthor,\r\n+            bookCategory: bookCategory || existingBook.bookCategory,\r\n+            bookLanguage: bookLanguage || existingBook.bookLanguage,\r\n+            bookFile: bookFileUrl || existingBook.bookFile\r\n+          },\r\n+          { where: { id: args.id } }\r\n+        );\r\n+        if (updateCount === 0) {\r\n+          throw new Error('No changes detected');\r\n+        }\r\n+        const updatedBook = await Book.findOne({ where: { id: args.id } });\r\n+        return {success: true, message: `Boook info updated successfully` };\r\n+      } catch (error) {\r\n+        console.error('Error during deleteBook operation:', error.message);\r\n+        return {success: false, message: `Error deleting book: ${error.message}`};\r\n+      }\r\n+    },\r\n+  \r\n+    \r\n+    deleteBook: async (_, { id }) => {\r\n+      try {\r\n+        const book = await Book.findByPk(id);\r\n+        if (!book) {\r\n+          throw new Error('Book not found.');\r\n+        }\r\n+     if (book.bookCover) {\r\n+    const coverPublicId = extractPublicId(book.bookCover);\r\n+    if (coverPublicId) {\r\n+      console.log(`Deleting book cover with public ID: ${coverPublicId}`);\r\n+      try {\r\n+        await deleteOldFileFromCloudinary(coverPublicId);\r\n+      } catch (error) {\r\n+        console.error(`Failed to delete book cover: ${error.message}`);\r\n+      }\r\n+    } else {\r\n+      console.warn('No valid public ID found for book cover.');\r\n+        }\r\n+      }\r\n+  if (book.bookFile) {\r\n+    const filePublicId = extractPublicId(book.bookFile);\r\n+    if (filePublicId) {\r\n+      console.log(`Deleting book file with public ID: ${filePublicId}`);\r\n+      try {\r\n+        await deleteOldFileFromCloudinary(filePublicId);\r\n+      } catch (error) {\r\n+        console.error(`Failed to delete book file: ${error.message}`);\r\n+      }\r\n+    } else {\r\n+      console.warn('No valid public ID found for book file.');\r\n+    }\r\n+  }\r\n+        const deleteCount = await Book.destroy({ where: { id } });\r\n+        if (deleteCount === 0) {\r\n+          throw new Error('Failed to delete book from the database.');\r\n+        }\r\n+        return {\r\n+          success: true,\r\n+          message: 'Book and associated files deleted successfully.',\r\n+        };\r\n+      } catch (error) {\r\n+        console.error('Error during deleteBook operation:', error.message);\r\n+        return {\r\n+          success: false,\r\n+          message: `Error deleting book: ${error.message}`,\r\n+        };\r\n+      }\r\n+    },\r\n+    \r\n+    \r\n+\r\n+    // User signup\r\n+    signup: async (_, args) => {\r\n+      try {\r\n+        const { username, phoneNumber, email, password } = args.signupuser;\r\n+        const hashedPassword = await bcrypt.hash(password, 10);\r\n+        const data = await User.create({\r\n+          username,\r\n+          phoneNumber,\r\n+          email,\r\n+          password: hashedPassword\r\n+        });\r\n+        return data;\r\n+      } catch (error) {\r\n+        throw new Error(error.message);\r\n+      }\r\n+    },\r\n+    \r\n+    login: async (_, args, context) => {\r\n+      const { req } = context;\r\n+      const { username, password } = args.loginuser;\r\n+      try {\r\n+        const user = await User.findOne({ where: { username } });\r\n+        if (!user) {\r\n+         throw new Error('Incorrect username or password'); \r\n+        }\r\n+        const passwordMatch = await bcrypt.compare(password, user.password);   \r\n+              if (!passwordMatch) {\r\n+               throw new Error('Incorrect username or password'); \r\n+              }\r\n+              const token = jwt.sign({ userId: user.id, email:user.email }, process.env.SECRET_STRING, {expiresIn:'5h'})\r\n+              \r\n+            return { role: user.role, userId: user.id, token };\r\n+      } catch (error) {\r\n+        console.error(\"Error logging in:\", error.message);\r\n+        throw new Error(\"Login unsuccessful. Please try again.\");\r\n+      }\r\n+    },\r\n+\r\n+  \r\n+    updateUser: async (_, args) => {\r\n+      try {\r\n+        const existingUser =  User.findOne({where: {}})\r\n+        const { profilePic, fullName, username, phoneNumber, email } = args.updateuser;\r\n+        const profilePicUrl = profilePic ? await uploadToCloudinary(profilePic) : existingUser.profilePic;\r\n+        const [updateCount] = await User.update(\r\n+          {  \r\n+            profilePic: profilePicUrl, \r\n+             fullName: fullName || existingUser.fullName, \r\n+             username: username || existingUser.username, \r\n+             phoneNumber: phoneNumber || existingUser.phoneNumber, \r\n+             email: email || existingUser.email,\r\n+         },\r\n+          { where: { id: args.id } }\r\n+        );\r\n+        if (updateCount === 0) {\r\n+          throw new Error('User not found or nothing to update');\r\n+        }\r\n+        return { success: true, message: `User info updated successfully` };\r\n+      } catch (error) {\r\n+        return { success: false, message: `Error updating user: ${error.message}` };\r\n+      }\r\n+    },\r\n+\r\n+\r\n+    deleteUser: async (_, { id }) => {\r\n+      try {\r\n+        const user = await User.findByPk(id);\r\n+        if (!user) throw new Error(\"User not found\");\r\n+        const del = await User.destroy({ where: { id } });\r\n+        if (!del) throw new Error(\"Deletion not successful\");\r\n+        return { success: true, message: \"User info deleted successfully.\" };\r\n+      } catch (error) {\r\n+        return { success: false, message: `Error deleting user: ${error.message}` };\r\n+      }\r\n+    },\r\n+\r\n+\r\n+  }\r\n+};\r\n"
                },
                {
                    "date": 1736577866114,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -283,5 +283,5 @@\n     },\r\n \r\n \r\n   }\r\n-};\r\n\\ No newline at end of file\n+};\r\n"
                },
                {
                    "date": 1736577877565,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -121,9 +121,9 @@\n     }),\r\n      \r\n \r\n     // Update a book\r\n-    updateBook: async (_, args) => {\r\n+    updateBook: (applyTokenChecker, async (_, args) => {\r\n       try {\r\n         const { bookCover, bookName, bookDescription, bookAuthor, bookCategory, bookLanguage, bookFile } = args.updatebook;\r\n         const existingBook = await Book.findOne({ where: { id: args.id } });\r\n         if (!existingBook) {\r\n@@ -151,9 +151,9 @@\n       } catch (error) {\r\n         console.error('Error during deleteBook operation:', error.message);\r\n         return {success: false, message: `Error deleting book: ${error.message}`};\r\n       }\r\n-    },\r\n+    }),\r\n   \r\n     \r\n     deleteBook: async (_, { id }) => {\r\n       try {\r\n@@ -284,579 +284,4 @@\n \r\n \r\n   }\r\n };\r\n-import Book from \"../models/book.js\";\r\n-import User from \"../models/user.js\";\r\n-import bcrypt from \"bcrypt\";\r\n-import { GraphQLUpload } from 'graphql-upload';\r\n-import { Op } from 'sequelize';   \r\n-import jwt from'jsonwebtoken';\r\n-import { applyTokenChecker, uploadToCloudinary, deleteOldFileFromCloudinary, extractPublicId } from \"../config/cloudinary.js\";\r\n-\r\n-\r\n-\r\n-\r\n-export const resolvers = {\r\n-  Upload: GraphQLUpload,\r\n-\r\n-  Query: {\r\n-    books: async (_, { page = 1, perPage = 9 }) => {\r\n-      try {\r\n-          const offset = (page - 1) * perPage;\r\n-          const { rows: allBooks, count: totalBooks } = await Book.findAndCountAll({\r\n-              order: [['createdAt', 'DESC']],\r\n-              limit: perPage,\r\n-          offset: offset,\r\n-          });\r\n-          const lastPage = Math.ceil(totalBooks / perPage);\r\n-        const currentPage = page;\r\n-        const previousPage = currentPage-1;\r\n-        const nextPage = currentPage+1; \r\n-          return {\r\n-              allBooks,\r\n-             currentPage,\r\n-              previousPage,\r\n-              nextPage,\r\n-              lastPage,\r\n-          };\r\n-      } catch (error) {\r\n-          console.error('Error fetching books:', error);\r\n-          throw new Error('Unable to fetch books at the moment');\r\n-      }\r\n-  },\r\n-  \r\n-    book: async (_, args) => {\r\n-      try {\r\n-        const data = await Book.findOne({ where: { id: args.id } });\r\n-        return data;\r\n-      } catch (error) {\r\n-        throw new Error(error.message);\r\n-      }\r\n-    },\r\n-\r\n-    users: async () => {\r\n-      try {\r\n-        const data = await User.findAll();\r\n-        return data;\r\n-      } catch (error) {\r\n-        throw new Error(error.message);\r\n-      }\r\n-    },\r\n-\r\n-    user: async (_, args) => {\r\n-      try {\r\n-        const data = await User.findOne({ where: { id: args.id } });\r\n-        return data;\r\n-      } catch (error) {\r\n-        throw new Error(error.message);\r\n-      }\r\n-    },\r\n-\r\n-    searchBooks: async (_, { searchTerm }) => {\r\n-      try {\r\n-        const lowerCaseSearchTerm = `%${searchTerm.toLowerCase()}%`; \r\n-        const books = await Book.findAll({\r\n-          where: {\r\n-            [Op.or]: [\r\n-              { bookName: { [Op.like]: lowerCaseSearchTerm } },\r\n-              { bookAuthor: { [Op.like]: lowerCaseSearchTerm } },\r\n-              { bookDescription: { [Op.like]: lowerCaseSearchTerm } }\r\n-            ]\r\n-          }\r\n-        });\r\n-        return books;\r\n-      } catch (error) {\r\n-        throw new Error(\"Error fetching books: \" + error.message);\r\n-      }\r\n-    }\r\n-  },\r\n-\r\n-  Mutation: {\r\n-\r\n-    addBook: (applyTokenChecker, async (_, { addbook }) => {\r\n-      try {\r\n-        const {\r\n-          bookCover,\r\n-          bookName,\r\n-          bookDescription,\r\n-          bookAuthor,\r\n-          bookCategory,\r\n-          bookLanguage,\r\n-          bookFile,\r\n-        } = addbook;\r\n-        if (!bookName || !bookDescription || !bookAuthor || !bookCategory || !bookLanguage) {\r\n-          throw new Error(\"All required fields (except files) must be provided.\");\r\n-        }\r\n-        const bookCoverUrl = bookCover ? await uploadToCloudinary(bookCover) : null;\r\n-        const bookFileUrl = bookFile ? await uploadToCloudinary(bookFile) : null;\r\n-        const newBook = await Book.create({\r\n-          bookCover: bookCoverUrl,\r\n-          bookName,\r\n-          bookDescription,\r\n-          bookAuthor,\r\n-          bookCategory,\r\n-          bookLanguage,\r\n-          bookFile: bookFileUrl,\r\n-          // postedBy:req.adminId\r\n-        });\r\n-        console.log(newBook)\r\n-      //   return newBook;\r\n-      } catch (error) {\r\n-        console.error(\"Error adding book:\", error.message);\r\n-        throw new Error(\"Failed to add book. Please try again.\");\r\n-      }\r\n-    },\r\n-     \r\n-\r\n-    // Update a book\r\n-    updateBook: async (_, args) => {\r\n-      try {\r\n-        const { bookCover, bookName, bookDescription, bookAuthor, bookCategory, bookLanguage, bookFile } = args.updatebook;\r\n-        const existingBook = await Book.findOne({ where: { id: args.id } });\r\n-        if (!existingBook) {\r\n-          throw new Error('Book not found');\r\n-        }\r\n-        const bookCoverUrl = bookCover ? await uploadToCloudinary(bookCover) : existingBook.bookCover;\r\n-        const bookFileUrl = bookFile ? await uploadToCloudinary(bookFile) : existingBook.bookFile;\r\n-        const [updateCount] = await Book.update(\r\n-          {\r\n-            bookCover: bookCoverUrl || existingBook.bookCover,\r\n-            bookName: bookName || existingBook.bookName,\r\n-            bookDescription: bookDescription || existingBook.bookDescription,\r\n-            bookAuthor: bookAuthor || existingBook.bookAuthor,\r\n-            bookCategory: bookCategory || existingBook.bookCategory,\r\n-            bookLanguage: bookLanguage || existingBook.bookLanguage,\r\n-            bookFile: bookFileUrl || existingBook.bookFile\r\n-          },\r\n-          { where: { id: args.id } }\r\n-        );\r\n-        if (updateCount === 0) {\r\n-          throw new Error('No changes detected');\r\n-        }\r\n-        const updatedBook = await Book.findOne({ where: { id: args.id } });\r\n-        return {success: true, message: `Boook info updated successfully` };\r\n-      } catch (error) {\r\n-        console.error('Error during deleteBook operation:', error.message);\r\n-        return {success: false, message: `Error deleting book: ${error.message}`};\r\n-      }\r\n-    },\r\n-  \r\n-    \r\n-    deleteBook: async (_, { id }) => {\r\n-      try {\r\n-        const book = await Book.findByPk(id);\r\n-        if (!book) {\r\n-          throw new Error('Book not found.');\r\n-        }\r\n-     if (book.bookCover) {\r\n-    const coverPublicId = extractPublicId(book.bookCover);\r\n-    if (coverPublicId) {\r\n-      console.log(`Deleting book cover with public ID: ${coverPublicId}`);\r\n-      try {\r\n-        await deleteOldFileFromCloudinary(coverPublicId);\r\n-      } catch (error) {\r\n-        console.error(`Failed to delete book cover: ${error.message}`);\r\n-      }\r\n-    } else {\r\n-      console.warn('No valid public ID found for book cover.');\r\n-        }\r\n-      }\r\n-  if (book.bookFile) {\r\n-    const filePublicId = extractPublicId(book.bookFile);\r\n-    if (filePublicId) {\r\n-      console.log(`Deleting book file with public ID: ${filePublicId}`);\r\n-      try {\r\n-        await deleteOldFileFromCloudinary(filePublicId);\r\n-      } catch (error) {\r\n-        console.error(`Failed to delete book file: ${error.message}`);\r\n-      }\r\n-    } else {\r\n-      console.warn('No valid public ID found for book file.');\r\n-    }\r\n-  }\r\n-        const deleteCount = await Book.destroy({ where: { id } });\r\n-        if (deleteCount === 0) {\r\n-          throw new Error('Failed to delete book from the database.');\r\n-        }\r\n-        return {\r\n-          success: true,\r\n-          message: 'Book and associated files deleted successfully.',\r\n-        };\r\n-      } catch (error) {\r\n-        console.error('Error during deleteBook operation:', error.message);\r\n-        return {\r\n-          success: false,\r\n-          message: `Error deleting book: ${error.message}`,\r\n-        };\r\n-      }\r\n-    },\r\n-    \r\n-    \r\n-\r\n-    // User signup\r\n-    signup: async (_, args) => {\r\n-      try {\r\n-        const { username, phoneNumber, email, password } = args.signupuser;\r\n-        const hashedPassword = await bcrypt.hash(password, 10);\r\n-        const data = await User.create({\r\n-          username,\r\n-          phoneNumber,\r\n-          email,\r\n-          password: hashedPassword\r\n-        });\r\n-        return data;\r\n-      } catch (error) {\r\n-        throw new Error(error.message);\r\n-      }\r\n-    },\r\n-    \r\n-    login: async (_, args, context) => {\r\n-      const { req } = context;\r\n-      const { username, password } = args.loginuser;\r\n-      try {\r\n-        const user = await User.findOne({ where: { username } });\r\n-        if (!user) {\r\n-         throw new Error('Incorrect username or password'); \r\n-        }\r\n-        const passwordMatch = await bcrypt.compare(password, user.password);   \r\n-              if (!passwordMatch) {\r\n-               throw new Error('Incorrect username or password'); \r\n-              }\r\n-              const token = jwt.sign({ userId: user.id, email:user.email }, process.env.SECRET_STRING, {expiresIn:'5h'})\r\n-              \r\n-            return { role: user.role, userId: user.id, token };\r\n-      } catch (error) {\r\n-        console.error(\"Error logging in:\", error.message);\r\n-        throw new Error(\"Login unsuccessful. Please try again.\");\r\n-      }\r\n-    },\r\n-\r\n-  \r\n-    updateUser: async (_, args) => {\r\n-      try {\r\n-        const existingUser =  User.findOne({where: {}})\r\n-        const { profilePic, fullName, username, phoneNumber, email } = args.updateuser;\r\n-        const profilePicUrl = profilePic ? await uploadToCloudinary(profilePic) : existingUser.profilePic;\r\n-        const [updateCount] = await User.update(\r\n-          {  \r\n-            profilePic: profilePicUrl, \r\n-             fullName: fullName || existingUser.fullName, \r\n-             username: username || existingUser.username, \r\n-             phoneNumber: phoneNumber || existingUser.phoneNumber, \r\n-             email: email || existingUser.email,\r\n-         },\r\n-          { where: { id: args.id } }\r\n-        );\r\n-        if (updateCount === 0) {\r\n-          throw new Error('User not found or nothing to update');\r\n-        }\r\n-        return { success: true, message: `User info updated successfully` };\r\n-      } catch (error) {\r\n-        return { success: false, message: `Error updating user: ${error.message}` };\r\n-      }\r\n-    },\r\n-\r\n-\r\n-    deleteUser: async (_, { id }) => {\r\n-      try {\r\n-        const user = await User.findByPk(id);\r\n-        if (!user) throw new Error(\"User not found\");\r\n-        const del = await User.destroy({ where: { id } });\r\n-        if (!del) throw new Error(\"Deletion not successful\");\r\n-        return { success: true, message: \"User info deleted successfully.\" };\r\n-      } catch (error) {\r\n-        return { success: false, message: `Error deleting user: ${error.message}` };\r\n-      }\r\n-    },\r\n-\r\n-\r\n-  }\r\n-};\r\n-import Book from \"../models/book.js\";\r\n-import User from \"../models/user.js\";\r\n-import bcrypt from \"bcrypt\";\r\n-import { GraphQLUpload } from 'graphql-upload';\r\n-import { Op } from 'sequelize';   \r\n-import jwt from'jsonwebtoken';\r\n-import { applyTokenChecker, uploadToCloudinary, deleteOldFileFromCloudinary, extractPublicId } from \"../config/cloudinary.js\";\r\n-\r\n-\r\n-\r\n-\r\n-export const resolvers = {\r\n-  Upload: GraphQLUpload,\r\n-\r\n-  Query: {\r\n-    books: async (_, { page = 1, perPage = 9 }) => {\r\n-      try {\r\n-          const offset = (page - 1) * perPage;\r\n-          const { rows: allBooks, count: totalBooks } = await Book.findAndCountAll({\r\n-              order: [['createdAt', 'DESC']],\r\n-              limit: perPage,\r\n-          offset: offset,\r\n-          });\r\n-          const lastPage = Math.ceil(totalBooks / perPage);\r\n-        const currentPage = page;\r\n-        const previousPage = currentPage-1;\r\n-        const nextPage = currentPage+1; \r\n-          return {\r\n-              allBooks,\r\n-             currentPage,\r\n-              previousPage,\r\n-              nextPage,\r\n-              lastPage,\r\n-          };\r\n-      } catch (error) {\r\n-          console.error('Error fetching books:', error);\r\n-          throw new Error('Unable to fetch books at the moment');\r\n-      }\r\n-  },\r\n-  \r\n-    book: async (_, args) => {\r\n-      try {\r\n-        const data = await Book.findOne({ where: { id: args.id } });\r\n-        return data;\r\n-      } catch (error) {\r\n-        throw new Error(error.message);\r\n-      }\r\n-    },\r\n-\r\n-    users: async () => {\r\n-      try {\r\n-        const data = await User.findAll();\r\n-        return data;\r\n-      } catch (error) {\r\n-        throw new Error(error.message);\r\n-      }\r\n-    },\r\n-\r\n-    user: async (_, args) => {\r\n-      try {\r\n-        const data = await User.findOne({ where: { id: args.id } });\r\n-        return data;\r\n-      } catch (error) {\r\n-        throw new Error(error.message);\r\n-      }\r\n-    },\r\n-\r\n-    searchBooks: async (_, { searchTerm }) => {\r\n-      try {\r\n-        const lowerCaseSearchTerm = `%${searchTerm.toLowerCase()}%`; \r\n-        const books = await Book.findAll({\r\n-          where: {\r\n-            [Op.or]: [\r\n-              { bookName: { [Op.like]: lowerCaseSearchTerm } },\r\n-              { bookAuthor: { [Op.like]: lowerCaseSearchTerm } },\r\n-              { bookDescription: { [Op.like]: lowerCaseSearchTerm } }\r\n-            ]\r\n-          }\r\n-        });\r\n-        return books;\r\n-      } catch (error) {\r\n-        throw new Error(\"Error fetching books: \" + error.message);\r\n-      }\r\n-    }\r\n-  },\r\n-\r\n-  Mutation: {\r\n-\r\n-    addBook: (async (_, { addbook }) => {\r\n-      try {\r\n-        const {\r\n-          bookCover,\r\n-          bookName,\r\n-          bookDescription,\r\n-          bookAuthor,\r\n-          bookCategory,\r\n-          bookLanguage,\r\n-          bookFile,\r\n-        } = addbook;\r\n-        if (!bookName || !bookDescription || !bookAuthor || !bookCategory || !bookLanguage) {\r\n-          throw new Error(\"All required fields (except files) must be provided.\");\r\n-        }\r\n-        const bookCoverUrl = bookCover ? await uploadToCloudinary(bookCover) : null;\r\n-        const bookFileUrl = bookFile ? await uploadToCloudinary(bookFile) : null;\r\n-        const newBook = await Book.create({\r\n-          bookCover: bookCoverUrl,\r\n-          bookName,\r\n-          bookDescription,\r\n-          bookAuthor,\r\n-          bookCategory,\r\n-          bookLanguage,\r\n-          bookFile: bookFileUrl,\r\n-          // postedBy:req.adminId\r\n-        });\r\n-        console.log(newBook)\r\n-      //   return newBook;\r\n-      } catch (error) {\r\n-        console.error(\"Error adding book:\", error.message);\r\n-        throw new Error(\"Failed to add book. Please try again.\");\r\n-      }\r\n-    },\r\n-     \r\n-\r\n-    // Update a book\r\n-    updateBook: async (_, args) => {\r\n-      try {\r\n-        const { bookCover, bookName, bookDescription, bookAuthor, bookCategory, bookLanguage, bookFile } = args.updatebook;\r\n-        const existingBook = await Book.findOne({ where: { id: args.id } });\r\n-        if (!existingBook) {\r\n-          throw new Error('Book not found');\r\n-        }\r\n-        const bookCoverUrl = bookCover ? await uploadToCloudinary(bookCover) : existingBook.bookCover;\r\n-        const bookFileUrl = bookFile ? await uploadToCloudinary(bookFile) : existingBook.bookFile;\r\n-        const [updateCount] = await Book.update(\r\n-          {\r\n-            bookCover: bookCoverUrl || existingBook.bookCover,\r\n-            bookName: bookName || existingBook.bookName,\r\n-            bookDescription: bookDescription || existingBook.bookDescription,\r\n-            bookAuthor: bookAuthor || existingBook.bookAuthor,\r\n-            bookCategory: bookCategory || existingBook.bookCategory,\r\n-            bookLanguage: bookLanguage || existingBook.bookLanguage,\r\n-            bookFile: bookFileUrl || existingBook.bookFile\r\n-          },\r\n-          { where: { id: args.id } }\r\n-        );\r\n-        if (updateCount === 0) {\r\n-          throw new Error('No changes detected');\r\n-        }\r\n-        const updatedBook = await Book.findOne({ where: { id: args.id } });\r\n-        return {success: true, message: `Boook info updated successfully` };\r\n-      } catch (error) {\r\n-        console.error('Error during deleteBook operation:', error.message);\r\n-        return {success: false, message: `Error deleting book: ${error.message}`};\r\n-      }\r\n-    },\r\n-  \r\n-    \r\n-    deleteBook: async (_, { id }) => {\r\n-      try {\r\n-        const book = await Book.findByPk(id);\r\n-        if (!book) {\r\n-          throw new Error('Book not found.');\r\n-        }\r\n-     if (book.bookCover) {\r\n-    const coverPublicId = extractPublicId(book.bookCover);\r\n-    if (coverPublicId) {\r\n-      console.log(`Deleting book cover with public ID: ${coverPublicId}`);\r\n-      try {\r\n-        await deleteOldFileFromCloudinary(coverPublicId);\r\n-      } catch (error) {\r\n-        console.error(`Failed to delete book cover: ${error.message}`);\r\n-      }\r\n-    } else {\r\n-      console.warn('No valid public ID found for book cover.');\r\n-        }\r\n-      }\r\n-  if (book.bookFile) {\r\n-    const filePublicId = extractPublicId(book.bookFile);\r\n-    if (filePublicId) {\r\n-      console.log(`Deleting book file with public ID: ${filePublicId}`);\r\n-      try {\r\n-        await deleteOldFileFromCloudinary(filePublicId);\r\n-      } catch (error) {\r\n-        console.error(`Failed to delete book file: ${error.message}`);\r\n-      }\r\n-    } else {\r\n-      console.warn('No valid public ID found for book file.');\r\n-    }\r\n-  }\r\n-        const deleteCount = await Book.destroy({ where: { id } });\r\n-        if (deleteCount === 0) {\r\n-          throw new Error('Failed to delete book from the database.');\r\n-        }\r\n-        return {\r\n-          success: true,\r\n-          message: 'Book and associated files deleted successfully.',\r\n-        };\r\n-      } catch (error) {\r\n-        console.error('Error during deleteBook operation:', error.message);\r\n-        return {\r\n-          success: false,\r\n-          message: `Error deleting book: ${error.message}`,\r\n-        };\r\n-      }\r\n-    },\r\n-    \r\n-    \r\n-\r\n-    // User signup\r\n-    signup: async (_, args) => {\r\n-      try {\r\n-        const { username, phoneNumber, email, password } = args.signupuser;\r\n-        const hashedPassword = await bcrypt.hash(password, 10);\r\n-        const data = await User.create({\r\n-          username,\r\n-          phoneNumber,\r\n-          email,\r\n-          password: hashedPassword\r\n-        });\r\n-        return data;\r\n-      } catch (error) {\r\n-        throw new Error(error.message);\r\n-      }\r\n-    },\r\n-    \r\n-    login: async (_, args, context) => {\r\n-      const { req } = context;\r\n-      const { username, password } = args.loginuser;\r\n-      try {\r\n-        const user = await User.findOne({ where: { username } });\r\n-        if (!user) {\r\n-         throw new Error('Incorrect username or password'); \r\n-        }\r\n-        const passwordMatch = await bcrypt.compare(password, user.password);   \r\n-              if (!passwordMatch) {\r\n-               throw new Error('Incorrect username or password'); \r\n-              }\r\n-              const token = jwt.sign({ userId: user.id, email:user.email }, process.env.SECRET_STRING, {expiresIn:'5h'})\r\n-              \r\n-            return { role: user.role, userId: user.id, token };\r\n-      } catch (error) {\r\n-        console.error(\"Error logging in:\", error.message);\r\n-        throw new Error(\"Login unsuccessful. Please try again.\");\r\n-      }\r\n-    },\r\n-\r\n-  \r\n-    updateUser: async (_, args) => {\r\n-      try {\r\n-        const existingUser =  User.findOne({where: {}})\r\n-        const { profilePic, fullName, username, phoneNumber, email } = args.updateuser;\r\n-        const profilePicUrl = profilePic ? await uploadToCloudinary(profilePic) : existingUser.profilePic;\r\n-        const [updateCount] = await User.update(\r\n-          {  \r\n-            profilePic: profilePicUrl, \r\n-             fullName: fullName || existingUser.fullName, \r\n-             username: username || existingUser.username, \r\n-             phoneNumber: phoneNumber || existingUser.phoneNumber, \r\n-             email: email || existingUser.email,\r\n-         },\r\n-          { where: { id: args.id } }\r\n-        );\r\n-        if (updateCount === 0) {\r\n-          throw new Error('User not found or nothing to update');\r\n-        }\r\n-        return { success: true, message: `User info updated successfully` };\r\n-      } catch (error) {\r\n-        return { success: false, message: `Error updating user: ${error.message}` };\r\n-      }\r\n-    },\r\n-\r\n-\r\n-    deleteUser: async (_, { id }) => {\r\n-      try {\r\n-        const user = await User.findByPk(id);\r\n-        if (!user) throw new Error(\"User not found\");\r\n-        const del = await User.destroy({ where: { id } });\r\n-        if (!del) throw new Error(\"Deletion not successful\");\r\n-        return { success: true, message: \"User info deleted successfully.\" };\r\n-      } catch (error) {\r\n-        return { success: false, message: `Error deleting user: ${error.message}` };\r\n-      }\r\n-    },\r\n-\r\n-\r\n-  }\r\n-};\r\n-\n"
                },
                {
                    "date": 1736577899938,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,287 @@\n+import Book from \"../models/book.js\";\r\n+import User from \"../models/user.js\";\r\n+import bcrypt from \"bcrypt\";\r\n+import { GraphQLUpload } from 'graphql-upload';\r\n+import { Op } from 'sequelize';   \r\n+import jwt from'jsonwebtoken';\r\n+import { applyTokenChecker, uploadToCloudinary, deleteOldFileFromCloudinary, extractPublicId } from \"../config/cloudinary.js\";\r\n+\r\n+\r\n+\r\n+\r\n+export const resolvers = {\r\n+  Upload: GraphQLUpload,\r\n+\r\n+  Query: {\r\n+    books: async (_, { page = 1, perPage = 9 }) => {\r\n+      try {\r\n+          const offset = (page - 1) * perPage;\r\n+          const { rows: allBooks, count: totalBooks } = await Book.findAndCountAll({\r\n+              order: [['createdAt', 'DESC']],\r\n+              limit: perPage,\r\n+          offset: offset,\r\n+          });\r\n+          const lastPage = Math.ceil(totalBooks / perPage);\r\n+        const currentPage = page;\r\n+        const previousPage = currentPage-1;\r\n+        const nextPage = currentPage+1; \r\n+          return {\r\n+              allBooks,\r\n+             currentPage,\r\n+              previousPage,\r\n+              nextPage,\r\n+              lastPage,\r\n+          };\r\n+      } catch (error) {\r\n+          console.error('Error fetching books:', error);\r\n+          throw new Error('Unable to fetch books at the moment');\r\n+      }\r\n+  },\r\n+  \r\n+    book: async (_, args) => {\r\n+      try {\r\n+        const data = await Book.findOne({ where: { id: args.id } });\r\n+        return data;\r\n+      } catch (error) {\r\n+        throw new Error(error.message);\r\n+      }\r\n+    },\r\n+\r\n+    users: async () => {\r\n+      try {\r\n+        const data = await User.findAll();\r\n+        return data;\r\n+      } catch (error) {\r\n+        throw new Error(error.message);\r\n+      }\r\n+    },\r\n+\r\n+    user: async (_, args) => {\r\n+      try {\r\n+        const data = await User.findOne({ where: { id: args.id } });\r\n+        return data;\r\n+      } catch (error) {\r\n+        throw new Error(error.message);\r\n+      }\r\n+    },\r\n+\r\n+    searchBooks: async (_, { searchTerm }) => {\r\n+      try {\r\n+        const lowerCaseSearchTerm = `%${searchTerm.toLowerCase()}%`; \r\n+        const books = await Book.findAll({\r\n+          where: {\r\n+            [Op.or]: [\r\n+              { bookName: { [Op.like]: lowerCaseSearchTerm } },\r\n+              { bookAuthor: { [Op.like]: lowerCaseSearchTerm } },\r\n+              { bookDescription: { [Op.like]: lowerCaseSearchTerm } }\r\n+            ]\r\n+          }\r\n+        });\r\n+        return books;\r\n+      } catch (error) {\r\n+        throw new Error(\"Error fetching books: \" + error.message);\r\n+      }\r\n+    }\r\n+  },\r\n+\r\n+  Mutation: {\r\n+\r\n+    addBook: (applyTokenChecker, async (_, { addbook }) => {\r\n+      try {\r\n+        const {\r\n+          bookCover,\r\n+          bookName,\r\n+          bookDescription,\r\n+          bookAuthor,\r\n+          bookCategory,\r\n+          bookLanguage,\r\n+          bookFile,\r\n+        } = addbook;\r\n+        if (!bookName || !bookDescription || !bookAuthor || !bookCategory || !bookLanguage) {\r\n+          throw new Error(\"All required fields (except files) must be provided.\");\r\n+        }\r\n+        const bookCoverUrl = bookCover ? await uploadToCloudinary(bookCover) : null;\r\n+        const bookFileUrl = bookFile ? await uploadToCloudinary(bookFile) : null;\r\n+        const newBook = await Book.create({\r\n+          bookCover: bookCoverUrl,\r\n+          bookName,\r\n+          bookDescription,\r\n+          bookAuthor,\r\n+          bookCategory,\r\n+          bookLanguage,\r\n+          bookFile: bookFileUrl,\r\n+          // postedBy:req.adminId\r\n+        });\r\n+        console.log(newBook)\r\n+      //   return newBook;\r\n+      } catch (error) {\r\n+        console.error(\"Error adding book:\", error.message);\r\n+        throw new Error(\"Failed to add book. Please try again.\");\r\n+      }\r\n+    }),\r\n+     \r\n+\r\n+    // Update a book\r\n+    updateBook: (applyTokenChecker, async (_, args) => {\r\n+      try {\r\n+        const { bookCover, bookName, bookDescription, bookAuthor, bookCategory, bookLanguage, bookFile } = args.updatebook;\r\n+        const existingBook = await Book.findOne({ where: { id: args.id } });\r\n+        if (!existingBook) {\r\n+          throw new Error('Book not found');\r\n+        }\r\n+        const bookCoverUrl = bookCover ? await uploadToCloudinary(bookCover) : existingBook.bookCover;\r\n+        const bookFileUrl = bookFile ? await uploadToCloudinary(bookFile) : existingBook.bookFile;\r\n+        const [updateCount] = await Book.update(\r\n+          {\r\n+            bookCover: bookCoverUrl || existingBook.bookCover,\r\n+            bookName: bookName || existingBook.bookName,\r\n+            bookDescription: bookDescription || existingBook.bookDescription,\r\n+            bookAuthor: bookAuthor || existingBook.bookAuthor,\r\n+            bookCategory: bookCategory || existingBook.bookCategory,\r\n+            bookLanguage: bookLanguage || existingBook.bookLanguage,\r\n+            bookFile: bookFileUrl || existingBook.bookFile\r\n+          },\r\n+          { where: { id: args.id } }\r\n+        );\r\n+        if (updateCount === 0) {\r\n+          throw new Error('No changes detected');\r\n+        }\r\n+        const updatedBook = await Book.findOne({ where: { id: args.id } });\r\n+        return {success: true, message: `Boook info updated successfully` };\r\n+      } catch (error) {\r\n+        console.error('Error during deleteBook operation:', error.message);\r\n+        return {success: false, message: `Error deleting book: ${error.message}`};\r\n+      }\r\n+    }),\r\n+  \r\n+    \r\n+    deleteBook: (async (_, { id }) => {\r\n+      try {\r\n+        const book = await Book.findByPk(id);\r\n+        if (!book) {\r\n+          throw new Error('Book not found.');\r\n+        }\r\n+     if (book.bookCover) {\r\n+    const coverPublicId = extractPublicId(book.bookCover);\r\n+    if (coverPublicId) {\r\n+      console.log(`Deleting book cover with public ID: ${coverPublicId}`);\r\n+      try {\r\n+        await deleteOldFileFromCloudinary(coverPublicId);\r\n+      } catch (error) {\r\n+        console.error(`Failed to delete book cover: ${error.message}`);\r\n+      }\r\n+    } else {\r\n+      console.warn('No valid public ID found for book cover.');\r\n+        }\r\n+      }\r\n+  if (book.bookFile) {\r\n+    const filePublicId = extractPublicId(book.bookFile);\r\n+    if (filePublicId) {\r\n+      console.log(`Deleting book file with public ID: ${filePublicId}`);\r\n+      try {\r\n+        await deleteOldFileFromCloudinary(filePublicId);\r\n+      } catch (error) {\r\n+        console.error(`Failed to delete book file: ${error.message}`);\r\n+      }\r\n+    } else {\r\n+      console.warn('No valid public ID found for book file.');\r\n+    }\r\n+  }\r\n+        const deleteCount = await Book.destroy({ where: { id } });\r\n+        if (deleteCount === 0) {\r\n+          throw new Error('Failed to delete book from the database.');\r\n+        }\r\n+        return {\r\n+          success: true,\r\n+          message: 'Book and associated files deleted successfully.',\r\n+        };\r\n+      } catch (error) {\r\n+        console.error('Error during deleteBook operation:', error.message);\r\n+        return {\r\n+          success: false,\r\n+          message: `Error deleting book: ${error.message}`,\r\n+        };\r\n+      }\r\n+    },\r\n+    \r\n+    \r\n+\r\n+    // User signup\r\n+    signup: async (_, args) => {\r\n+      try {\r\n+        const { username, phoneNumber, email, password } = args.signupuser;\r\n+        const hashedPassword = await bcrypt.hash(password, 10);\r\n+        const data = await User.create({\r\n+          username,\r\n+          phoneNumber,\r\n+          email,\r\n+          password: hashedPassword\r\n+        });\r\n+        return data;\r\n+      } catch (error) {\r\n+        throw new Error(error.message);\r\n+      }\r\n+    },\r\n+    \r\n+    login: async (_, args, context) => {\r\n+      const { req } = context;\r\n+      const { username, password } = args.loginuser;\r\n+      try {\r\n+        const user = await User.findOne({ where: { username } });\r\n+        if (!user) {\r\n+         throw new Error('Incorrect username or password'); \r\n+        }\r\n+        const passwordMatch = await bcrypt.compare(password, user.password);   \r\n+              if (!passwordMatch) {\r\n+               throw new Error('Incorrect username or password'); \r\n+              }\r\n+              const token = jwt.sign({ userId: user.id, email:user.email }, process.env.SECRET_STRING, {expiresIn:'5h'})\r\n+              \r\n+            return { role: user.role, userId: user.id, token };\r\n+      } catch (error) {\r\n+        console.error(\"Error logging in:\", error.message);\r\n+        throw new Error(\"Login unsuccessful. Please try again.\");\r\n+      }\r\n+    },\r\n+\r\n+  \r\n+    updateUser: async (_, args) => {\r\n+      try {\r\n+        const existingUser =  User.findOne({where: {}})\r\n+        const { profilePic, fullName, username, phoneNumber, email } = args.updateuser;\r\n+        const profilePicUrl = profilePic ? await uploadToCloudinary(profilePic) : existingUser.profilePic;\r\n+        const [updateCount] = await User.update(\r\n+          {  \r\n+            profilePic: profilePicUrl, \r\n+             fullName: fullName || existingUser.fullName, \r\n+             username: username || existingUser.username, \r\n+             phoneNumber: phoneNumber || existingUser.phoneNumber, \r\n+             email: email || existingUser.email,\r\n+         },\r\n+          { where: { id: args.id } }\r\n+        );\r\n+        if (updateCount === 0) {\r\n+          throw new Error('User not found or nothing to update');\r\n+        }\r\n+        return { success: true, message: `User info updated successfully` };\r\n+      } catch (error) {\r\n+        return { success: false, message: `Error updating user: ${error.message}` };\r\n+      }\r\n+    },\r\n+\r\n+\r\n+    deleteUser: async (_, { id }) => {\r\n+      try {\r\n+        const user = await User.findByPk(id);\r\n+        if (!user) throw new Error(\"User not found\");\r\n+        const del = await User.destroy({ where: { id } });\r\n+        if (!del) throw new Error(\"Deletion not successful\");\r\n+        return { success: true, message: \"User info deleted successfully.\" };\r\n+      } catch (error) {\r\n+        return { success: false, message: `Error deleting user: ${error.message}` };\r\n+      }\r\n+    },\r\n+\r\n+\r\n+  }\r\n+};\r\n"
                },
                {
                    "date": 1736577913083,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -154,9 +154,9 @@\n       }\r\n     }),\r\n   \r\n     \r\n-    deleteBook: (async (_, { id }) => {\r\n+    deleteBook: (applyTokenChecker, async (_, { id }) => {\r\n       try {\r\n         const book = await Book.findByPk(id);\r\n         if (!book) {\r\n           throw new Error('Book not found.');\r\n@@ -201,298 +201,11 @@\n           success: false,\r\n           message: `Error deleting book: ${error.message}`,\r\n         };\r\n       }\r\n-    },\r\n-    \r\n-    \r\n-\r\n-    // User signup\r\n-    signup: async (_, args) => {\r\n-      try {\r\n-        const { username, phoneNumber, email, password } = args.signupuser;\r\n-        const hashedPassword = await bcrypt.hash(password, 10);\r\n-        const data = await User.create({\r\n-          username,\r\n-          phoneNumber,\r\n-          email,\r\n-          password: hashedPassword\r\n-        });\r\n-        return data;\r\n-      } catch (error) {\r\n-        throw new Error(error.message);\r\n-      }\r\n-    },\r\n-    \r\n-    login: async (_, args, context) => {\r\n-      const { req } = context;\r\n-      const { username, password } = args.loginuser;\r\n-      try {\r\n-        const user = await User.findOne({ where: { username } });\r\n-        if (!user) {\r\n-         throw new Error('Incorrect username or password'); \r\n-        }\r\n-        const passwordMatch = await bcrypt.compare(password, user.password);   \r\n-              if (!passwordMatch) {\r\n-               throw new Error('Incorrect username or password'); \r\n-              }\r\n-              const token = jwt.sign({ userId: user.id, email:user.email }, process.env.SECRET_STRING, {expiresIn:'5h'})\r\n-              \r\n-            return { role: user.role, userId: user.id, token };\r\n-      } catch (error) {\r\n-        console.error(\"Error logging in:\", error.message);\r\n-        throw new Error(\"Login unsuccessful. Please try again.\");\r\n-      }\r\n-    },\r\n-\r\n-  \r\n-    updateUser: async (_, args) => {\r\n-      try {\r\n-        const existingUser =  User.findOne({where: {}})\r\n-        const { profilePic, fullName, username, phoneNumber, email } = args.updateuser;\r\n-        const profilePicUrl = profilePic ? await uploadToCloudinary(profilePic) : existingUser.profilePic;\r\n-        const [updateCount] = await User.update(\r\n-          {  \r\n-            profilePic: profilePicUrl, \r\n-             fullName: fullName || existingUser.fullName, \r\n-             username: username || existingUser.username, \r\n-             phoneNumber: phoneNumber || existingUser.phoneNumber, \r\n-             email: email || existingUser.email,\r\n-         },\r\n-          { where: { id: args.id } }\r\n-        );\r\n-        if (updateCount === 0) {\r\n-          throw new Error('User not found or nothing to update');\r\n-        }\r\n-        return { success: true, message: `User info updated successfully` };\r\n-      } catch (error) {\r\n-        return { success: false, message: `Error updating user: ${error.message}` };\r\n-      }\r\n-    },\r\n-\r\n-\r\n-    deleteUser: async (_, { id }) => {\r\n-      try {\r\n-        const user = await User.findByPk(id);\r\n-        if (!user) throw new Error(\"User not found\");\r\n-        const del = await User.destroy({ where: { id } });\r\n-        if (!del) throw new Error(\"Deletion not successful\");\r\n-        return { success: true, message: \"User info deleted successfully.\" };\r\n-      } catch (error) {\r\n-        return { success: false, message: `Error deleting user: ${error.message}` };\r\n-      }\r\n-    },\r\n-\r\n-\r\n-  }\r\n-};\r\n-import Book from \"../models/book.js\";\r\n-import User from \"../models/user.js\";\r\n-import bcrypt from \"bcrypt\";\r\n-import { GraphQLUpload } from 'graphql-upload';\r\n-import { Op } from 'sequelize';   \r\n-import jwt from'jsonwebtoken';\r\n-import { applyTokenChecker, uploadToCloudinary, deleteOldFileFromCloudinary, extractPublicId } from \"../config/cloudinary.js\";\r\n-\r\n-\r\n-\r\n-\r\n-export const resolvers = {\r\n-  Upload: GraphQLUpload,\r\n-\r\n-  Query: {\r\n-    books: async (_, { page = 1, perPage = 9 }) => {\r\n-      try {\r\n-          const offset = (page - 1) * perPage;\r\n-          const { rows: allBooks, count: totalBooks } = await Book.findAndCountAll({\r\n-              order: [['createdAt', 'DESC']],\r\n-              limit: perPage,\r\n-          offset: offset,\r\n-          });\r\n-          const lastPage = Math.ceil(totalBooks / perPage);\r\n-        const currentPage = page;\r\n-        const previousPage = currentPage-1;\r\n-        const nextPage = currentPage+1; \r\n-          return {\r\n-              allBooks,\r\n-             currentPage,\r\n-              previousPage,\r\n-              nextPage,\r\n-              lastPage,\r\n-          };\r\n-      } catch (error) {\r\n-          console.error('Error fetching books:', error);\r\n-          throw new Error('Unable to fetch books at the moment');\r\n-      }\r\n-  },\r\n-  \r\n-    book: async (_, args) => {\r\n-      try {\r\n-        const data = await Book.findOne({ where: { id: args.id } });\r\n-        return data;\r\n-      } catch (error) {\r\n-        throw new Error(error.message);\r\n-      }\r\n-    },\r\n-\r\n-    users: async () => {\r\n-      try {\r\n-        const data = await User.findAll();\r\n-        return data;\r\n-      } catch (error) {\r\n-        throw new Error(error.message);\r\n-      }\r\n-    },\r\n-\r\n-    user: async (_, args) => {\r\n-      try {\r\n-        const data = await User.findOne({ where: { id: args.id } });\r\n-        return data;\r\n-      } catch (error) {\r\n-        throw new Error(error.message);\r\n-      }\r\n-    },\r\n-\r\n-    searchBooks: async (_, { searchTerm }) => {\r\n-      try {\r\n-        const lowerCaseSearchTerm = `%${searchTerm.toLowerCase()}%`; \r\n-        const books = await Book.findAll({\r\n-          where: {\r\n-            [Op.or]: [\r\n-              { bookName: { [Op.like]: lowerCaseSearchTerm } },\r\n-              { bookAuthor: { [Op.like]: lowerCaseSearchTerm } },\r\n-              { bookDescription: { [Op.like]: lowerCaseSearchTerm } }\r\n-            ]\r\n-          }\r\n-        });\r\n-        return books;\r\n-      } catch (error) {\r\n-        throw new Error(\"Error fetching books: \" + error.message);\r\n-      }\r\n-    }\r\n-  },\r\n-\r\n-  Mutation: {\r\n-\r\n-    addBook: (applyTokenChecker, async (_, { addbook }) => {\r\n-      try {\r\n-        const {\r\n-          bookCover,\r\n-          bookName,\r\n-          bookDescription,\r\n-          bookAuthor,\r\n-          bookCategory,\r\n-          bookLanguage,\r\n-          bookFile,\r\n-        } = addbook;\r\n-        if (!bookName || !bookDescription || !bookAuthor || !bookCategory || !bookLanguage) {\r\n-          throw new Error(\"All required fields (except files) must be provided.\");\r\n-        }\r\n-        const bookCoverUrl = bookCover ? await uploadToCloudinary(bookCover) : null;\r\n-        const bookFileUrl = bookFile ? await uploadToCloudinary(bookFile) : null;\r\n-        const newBook = await Book.create({\r\n-          bookCover: bookCoverUrl,\r\n-          bookName,\r\n-          bookDescription,\r\n-          bookAuthor,\r\n-          bookCategory,\r\n-          bookLanguage,\r\n-          bookFile: bookFileUrl,\r\n-          // postedBy:req.adminId\r\n-        });\r\n-        console.log(newBook)\r\n-      //   return newBook;\r\n-      } catch (error) {\r\n-        console.error(\"Error adding book:\", error.message);\r\n-        throw new Error(\"Failed to add book. Please try again.\");\r\n-      }\r\n     }),\r\n-     \r\n-\r\n-    // Update a book\r\n-    updateBook: (applyTokenChecker, async (_, args) => {\r\n-      try {\r\n-        const { bookCover, bookName, bookDescription, bookAuthor, bookCategory, bookLanguage, bookFile } = args.updatebook;\r\n-        const existingBook = await Book.findOne({ where: { id: args.id } });\r\n-        if (!existingBook) {\r\n-          throw new Error('Book not found');\r\n-        }\r\n-        const bookCoverUrl = bookCover ? await uploadToCloudinary(bookCover) : existingBook.bookCover;\r\n-        const bookFileUrl = bookFile ? await uploadToCloudinary(bookFile) : existingBook.bookFile;\r\n-        const [updateCount] = await Book.update(\r\n-          {\r\n-            bookCover: bookCoverUrl || existingBook.bookCover,\r\n-            bookName: bookName || existingBook.bookName,\r\n-            bookDescription: bookDescription || existingBook.bookDescription,\r\n-            bookAuthor: bookAuthor || existingBook.bookAuthor,\r\n-            bookCategory: bookCategory || existingBook.bookCategory,\r\n-            bookLanguage: bookLanguage || existingBook.bookLanguage,\r\n-            bookFile: bookFileUrl || existingBook.bookFile\r\n-          },\r\n-          { where: { id: args.id } }\r\n-        );\r\n-        if (updateCount === 0) {\r\n-          throw new Error('No changes detected');\r\n-        }\r\n-        const updatedBook = await Book.findOne({ where: { id: args.id } });\r\n-        return {success: true, message: `Boook info updated successfully` };\r\n-      } catch (error) {\r\n-        console.error('Error during deleteBook operation:', error.message);\r\n-        return {success: false, message: `Error deleting book: ${error.message}`};\r\n-      }\r\n-    }),\r\n-  \r\n     \r\n-    deleteBook: async (_, { id }) => {\r\n-      try {\r\n-        const book = await Book.findByPk(id);\r\n-        if (!book) {\r\n-          throw new Error('Book not found.');\r\n-        }\r\n-     if (book.bookCover) {\r\n-    const coverPublicId = extractPublicId(book.bookCover);\r\n-    if (coverPublicId) {\r\n-      console.log(`Deleting book cover with public ID: ${coverPublicId}`);\r\n-      try {\r\n-        await deleteOldFileFromCloudinary(coverPublicId);\r\n-      } catch (error) {\r\n-        console.error(`Failed to delete book cover: ${error.message}`);\r\n-      }\r\n-    } else {\r\n-      console.warn('No valid public ID found for book cover.');\r\n-        }\r\n-      }\r\n-  if (book.bookFile) {\r\n-    const filePublicId = extractPublicId(book.bookFile);\r\n-    if (filePublicId) {\r\n-      console.log(`Deleting book file with public ID: ${filePublicId}`);\r\n-      try {\r\n-        await deleteOldFileFromCloudinary(filePublicId);\r\n-      } catch (error) {\r\n-        console.error(`Failed to delete book file: ${error.message}`);\r\n-      }\r\n-    } else {\r\n-      console.warn('No valid public ID found for book file.');\r\n-    }\r\n-  }\r\n-        const deleteCount = await Book.destroy({ where: { id } });\r\n-        if (deleteCount === 0) {\r\n-          throw new Error('Failed to delete book from the database.');\r\n-        }\r\n-        return {\r\n-          success: true,\r\n-          message: 'Book and associated files deleted successfully.',\r\n-        };\r\n-      } catch (error) {\r\n-        console.error('Error during deleteBook operation:', error.message);\r\n-        return {\r\n-          success: false,\r\n-          message: `Error deleting book: ${error.message}`,\r\n-        };\r\n-      }\r\n-    },\r\n     \r\n-    \r\n \r\n     // User signup\r\n     signup: async (_, args) => {\r\n       try {\r\n"
                },
                {
                    "date": 1736577983756,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,287 @@\n+import Book from \"../models/book.js\";\r\n+import User from \"../models/user.js\";\r\n+import bcrypt from \"bcrypt\";\r\n+import { GraphQLUpload } from 'graphql-upload';\r\n+import { Op } from 'sequelize';   \r\n+import jwt from'jsonwebtoken';\r\n+import { applyTokenChecker, uploadToCloudinary, deleteOldFileFromCloudinary, extractPublicId } from \"../config/cloudinary.js\";\r\n+\r\n+\r\n+\r\n+\r\n+export const resolvers = {\r\n+  Upload: GraphQLUpload,\r\n+\r\n+  Query: {\r\n+    books: async (_, { page = 1, perPage = 9 }) => {\r\n+      try {\r\n+          const offset = (page - 1) * perPage;\r\n+          const { rows: allBooks, count: totalBooks } = await Book.findAndCountAll({\r\n+              order: [['createdAt', 'DESC']],\r\n+              limit: perPage,\r\n+          offset: offset,\r\n+          });\r\n+          const lastPage = Math.ceil(totalBooks / perPage);\r\n+        const currentPage = page;\r\n+        const previousPage = currentPage-1;\r\n+        const nextPage = currentPage+1; \r\n+          return {\r\n+              allBooks,\r\n+             currentPage,\r\n+              previousPage,\r\n+              nextPage,\r\n+              lastPage,\r\n+          };\r\n+      } catch (error) {\r\n+          console.error('Error fetching books:', error);\r\n+          throw new Error('Unable to fetch books at the moment');\r\n+      }\r\n+  },\r\n+  \r\n+    book: async (_, args) => {\r\n+      try {\r\n+        const data = await Book.findOne({ where: { id: args.id } });\r\n+        return data;\r\n+      } catch (error) {\r\n+        throw new Error(error.message);\r\n+      }\r\n+    },\r\n+\r\n+    users: (async () => {\r\n+      try {\r\n+        const data = await User.findAll();\r\n+        return data;\r\n+      } catch (error) {\r\n+        throw new Error(error.message);\r\n+      }\r\n+    },\r\n+\r\n+    user: async (_, args) => {\r\n+      try {\r\n+        const data = await User.findOne({ where: { id: args.id } });\r\n+        return data;\r\n+      } catch (error) {\r\n+        throw new Error(error.message);\r\n+      }\r\n+    },\r\n+\r\n+    searchBooks: async (_, { searchTerm }) => {\r\n+      try {\r\n+        const lowerCaseSearchTerm = `%${searchTerm.toLowerCase()}%`; \r\n+        const books = await Book.findAll({\r\n+          where: {\r\n+            [Op.or]: [\r\n+              { bookName: { [Op.like]: lowerCaseSearchTerm } },\r\n+              { bookAuthor: { [Op.like]: lowerCaseSearchTerm } },\r\n+              { bookDescription: { [Op.like]: lowerCaseSearchTerm } }\r\n+            ]\r\n+          }\r\n+        });\r\n+        return books;\r\n+      } catch (error) {\r\n+        throw new Error(\"Error fetching books: \" + error.message);\r\n+      }\r\n+    }\r\n+  },\r\n+\r\n+  Mutation: {\r\n+\r\n+    addBook: (applyTokenChecker, async (_, { addbook }) => {\r\n+      try {\r\n+        const {\r\n+          bookCover,\r\n+          bookName,\r\n+          bookDescription,\r\n+          bookAuthor,\r\n+          bookCategory,\r\n+          bookLanguage,\r\n+          bookFile,\r\n+        } = addbook;\r\n+        if (!bookName || !bookDescription || !bookAuthor || !bookCategory || !bookLanguage) {\r\n+          throw new Error(\"All required fields (except files) must be provided.\");\r\n+        }\r\n+        const bookCoverUrl = bookCover ? await uploadToCloudinary(bookCover) : null;\r\n+        const bookFileUrl = bookFile ? await uploadToCloudinary(bookFile) : null;\r\n+        const newBook = await Book.create({\r\n+          bookCover: bookCoverUrl,\r\n+          bookName,\r\n+          bookDescription,\r\n+          bookAuthor,\r\n+          bookCategory,\r\n+          bookLanguage,\r\n+          bookFile: bookFileUrl,\r\n+          // postedBy:req.adminId\r\n+        });\r\n+        console.log(newBook)\r\n+      //   return newBook;\r\n+      } catch (error) {\r\n+        console.error(\"Error adding book:\", error.message);\r\n+        throw new Error(\"Failed to add book. Please try again.\");\r\n+      }\r\n+    }),\r\n+     \r\n+\r\n+    // Update a book\r\n+    updateBook: (applyTokenChecker, async (_, args) => {\r\n+      try {\r\n+        const { bookCover, bookName, bookDescription, bookAuthor, bookCategory, bookLanguage, bookFile } = args.updatebook;\r\n+        const existingBook = await Book.findOne({ where: { id: args.id } });\r\n+        if (!existingBook) {\r\n+          throw new Error('Book not found');\r\n+        }\r\n+        const bookCoverUrl = bookCover ? await uploadToCloudinary(bookCover) : existingBook.bookCover;\r\n+        const bookFileUrl = bookFile ? await uploadToCloudinary(bookFile) : existingBook.bookFile;\r\n+        const [updateCount] = await Book.update(\r\n+          {\r\n+            bookCover: bookCoverUrl || existingBook.bookCover,\r\n+            bookName: bookName || existingBook.bookName,\r\n+            bookDescription: bookDescription || existingBook.bookDescription,\r\n+            bookAuthor: bookAuthor || existingBook.bookAuthor,\r\n+            bookCategory: bookCategory || existingBook.bookCategory,\r\n+            bookLanguage: bookLanguage || existingBook.bookLanguage,\r\n+            bookFile: bookFileUrl || existingBook.bookFile\r\n+          },\r\n+          { where: { id: args.id } }\r\n+        );\r\n+        if (updateCount === 0) {\r\n+          throw new Error('No changes detected');\r\n+        }\r\n+        const updatedBook = await Book.findOne({ where: { id: args.id } });\r\n+        return {success: true, message: `Boook info updated successfully` };\r\n+      } catch (error) {\r\n+        console.error('Error during deleteBook operation:', error.message);\r\n+        return {success: false, message: `Error deleting book: ${error.message}`};\r\n+      }\r\n+    }),\r\n+  \r\n+    \r\n+    deleteBook: (applyTokenChecker, async (_, { id }) => {\r\n+      try {\r\n+        const book = await Book.findByPk(id);\r\n+        if (!book) {\r\n+          throw new Error('Book not found.');\r\n+        }\r\n+     if (book.bookCover) {\r\n+    const coverPublicId = extractPublicId(book.bookCover);\r\n+    if (coverPublicId) {\r\n+      console.log(`Deleting book cover with public ID: ${coverPublicId}`);\r\n+      try {\r\n+        await deleteOldFileFromCloudinary(coverPublicId);\r\n+      } catch (error) {\r\n+        console.error(`Failed to delete book cover: ${error.message}`);\r\n+      }\r\n+    } else {\r\n+      console.warn('No valid public ID found for book cover.');\r\n+        }\r\n+      }\r\n+  if (book.bookFile) {\r\n+    const filePublicId = extractPublicId(book.bookFile);\r\n+    if (filePublicId) {\r\n+      console.log(`Deleting book file with public ID: ${filePublicId}`);\r\n+      try {\r\n+        await deleteOldFileFromCloudinary(filePublicId);\r\n+      } catch (error) {\r\n+        console.error(`Failed to delete book file: ${error.message}`);\r\n+      }\r\n+    } else {\r\n+      console.warn('No valid public ID found for book file.');\r\n+    }\r\n+  }\r\n+        const deleteCount = await Book.destroy({ where: { id } });\r\n+        if (deleteCount === 0) {\r\n+          throw new Error('Failed to delete book from the database.');\r\n+        }\r\n+        return {\r\n+          success: true,\r\n+          message: 'Book and associated files deleted successfully.',\r\n+        };\r\n+      } catch (error) {\r\n+        console.error('Error during deleteBook operation:', error.message);\r\n+        return {\r\n+          success: false,\r\n+          message: `Error deleting book: ${error.message}`,\r\n+        };\r\n+      }\r\n+    }),\r\n+    \r\n+    \r\n+\r\n+    // User signup\r\n+    signup: async (_, args) => {\r\n+      try {\r\n+        const { username, phoneNumber, email, password } = args.signupuser;\r\n+        const hashedPassword = await bcrypt.hash(password, 10);\r\n+        const data = await User.create({\r\n+          username,\r\n+          phoneNumber,\r\n+          email,\r\n+          password: hashedPassword\r\n+        });\r\n+        return data;\r\n+      } catch (error) {\r\n+        throw new Error(error.message);\r\n+      }\r\n+    },\r\n+    \r\n+    login: async (_, args, context) => {\r\n+      const { req } = context;\r\n+      const { username, password } = args.loginuser;\r\n+      try {\r\n+        const user = await User.findOne({ where: { username } });\r\n+        if (!user) {\r\n+         throw new Error('Incorrect username or password'); \r\n+        }\r\n+        const passwordMatch = await bcrypt.compare(password, user.password);   \r\n+              if (!passwordMatch) {\r\n+               throw new Error('Incorrect username or password'); \r\n+              }\r\n+              const token = jwt.sign({ userId: user.id, email:user.email }, process.env.SECRET_STRING, {expiresIn:'5h'})\r\n+              \r\n+            return { role: user.role, userId: user.id, token };\r\n+      } catch (error) {\r\n+        console.error(\"Error logging in:\", error.message);\r\n+        throw new Error(\"Login unsuccessful. Please try again.\");\r\n+      }\r\n+    },\r\n+\r\n+  \r\n+    updateUser: async (_, args) => {\r\n+      try {\r\n+        const existingUser =  User.findOne({where: {}})\r\n+        const { profilePic, fullName, username, phoneNumber, email } = args.updateuser;\r\n+        const profilePicUrl = profilePic ? await uploadToCloudinary(profilePic) : existingUser.profilePic;\r\n+        const [updateCount] = await User.update(\r\n+          {  \r\n+            profilePic: profilePicUrl, \r\n+             fullName: fullName || existingUser.fullName, \r\n+             username: username || existingUser.username, \r\n+             phoneNumber: phoneNumber || existingUser.phoneNumber, \r\n+             email: email || existingUser.email,\r\n+         },\r\n+          { where: { id: args.id } }\r\n+        );\r\n+        if (updateCount === 0) {\r\n+          throw new Error('User not found or nothing to update');\r\n+        }\r\n+        return { success: true, message: `User info updated successfully` };\r\n+      } catch (error) {\r\n+        return { success: false, message: `Error updating user: ${error.message}` };\r\n+      }\r\n+    },\r\n+\r\n+\r\n+    deleteUser: async (_, { id }) => {\r\n+      try {\r\n+        const user = await User.findByPk(id);\r\n+        if (!user) throw new Error(\"User not found\");\r\n+        const del = await User.destroy({ where: { id } });\r\n+        if (!del) throw new Error(\"Deletion not successful\");\r\n+        return { success: true, message: \"User info deleted successfully.\" };\r\n+      } catch (error) {\r\n+        return { success: false, message: `Error deleting user: ${error.message}` };\r\n+      }\r\n+    },\r\n+\r\n+\r\n+  }\r\n+};\r\n"
                },
                {
                    "date": 1736577996728,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,287 @@\n+import Book from \"../models/book.js\";\r\n+import User from \"../models/user.js\";\r\n+import bcrypt from \"bcrypt\";\r\n+import { GraphQLUpload } from 'graphql-upload';\r\n+import { Op } from 'sequelize';   \r\n+import jwt from'jsonwebtoken';\r\n+import { applyTokenChecker, uploadToCloudinary, deleteOldFileFromCloudinary, extractPublicId } from \"../config/cloudinary.js\";\r\n+\r\n+\r\n+\r\n+\r\n+export const resolvers = {\r\n+  Upload: GraphQLUpload,\r\n+\r\n+  Query: {\r\n+    books: async (_, { page = 1, perPage = 9 }) => {\r\n+      try {\r\n+          const offset = (page - 1) * perPage;\r\n+          const { rows: allBooks, count: totalBooks } = await Book.findAndCountAll({\r\n+              order: [['createdAt', 'DESC']],\r\n+              limit: perPage,\r\n+          offset: offset,\r\n+          });\r\n+          const lastPage = Math.ceil(totalBooks / perPage);\r\n+        const currentPage = page;\r\n+        const previousPage = currentPage-1;\r\n+        const nextPage = currentPage+1; \r\n+          return {\r\n+              allBooks,\r\n+             currentPage,\r\n+              previousPage,\r\n+              nextPage,\r\n+              lastPage,\r\n+          };\r\n+      } catch (error) {\r\n+          console.error('Error fetching books:', error);\r\n+          throw new Error('Unable to fetch books at the moment');\r\n+      }\r\n+  },\r\n+  \r\n+    book: async (_, args) => {\r\n+      try {\r\n+        const data = await Book.findOne({ where: { id: args.id } });\r\n+        return data;\r\n+      } catch (error) {\r\n+        throw new Error(error.message);\r\n+      }\r\n+    },\r\n+\r\n+    users: (applyTokenChecker, async () => {\r\n+      try {\r\n+        const data = await User.findAll();\r\n+        return data;\r\n+      } catch (error) {\r\n+        throw new Error(error.message);\r\n+      }\r\n+    }),\r\n+\r\n+    user: async (_, args) => {\r\n+      try {\r\n+        const data = await User.findOne({ where: { id: args.id } });\r\n+        return data;\r\n+      } catch (error) {\r\n+        throw new Error(error.message);\r\n+      }\r\n+    },\r\n+\r\n+    searchBooks: async (_, { searchTerm }) => {\r\n+      try {\r\n+        const lowerCaseSearchTerm = `%${searchTerm.toLowerCase()}%`; \r\n+        const books = await Book.findAll({\r\n+          where: {\r\n+            [Op.or]: [\r\n+              { bookName: { [Op.like]: lowerCaseSearchTerm } },\r\n+              { bookAuthor: { [Op.like]: lowerCaseSearchTerm } },\r\n+              { bookDescription: { [Op.like]: lowerCaseSearchTerm } }\r\n+            ]\r\n+          }\r\n+        });\r\n+        return books;\r\n+      } catch (error) {\r\n+        throw new Error(\"Error fetching books: \" + error.message);\r\n+      }\r\n+    }\r\n+  },\r\n+\r\n+  Mutation: {\r\n+\r\n+    addBook: (applyTokenChecker, async (_, { addbook }) => {\r\n+      try {\r\n+        const {\r\n+          bookCover,\r\n+          bookName,\r\n+          bookDescription,\r\n+          bookAuthor,\r\n+          bookCategory,\r\n+          bookLanguage,\r\n+          bookFile,\r\n+        } = addbook;\r\n+        if (!bookName || !bookDescription || !bookAuthor || !bookCategory || !bookLanguage) {\r\n+          throw new Error(\"All required fields (except files) must be provided.\");\r\n+        }\r\n+        const bookCoverUrl = bookCover ? await uploadToCloudinary(bookCover) : null;\r\n+        const bookFileUrl = bookFile ? await uploadToCloudinary(bookFile) : null;\r\n+        const newBook = await Book.create({\r\n+          bookCover: bookCoverUrl,\r\n+          bookName,\r\n+          bookDescription,\r\n+          bookAuthor,\r\n+          bookCategory,\r\n+          bookLanguage,\r\n+          bookFile: bookFileUrl,\r\n+          // postedBy:req.adminId\r\n+        });\r\n+        console.log(newBook)\r\n+      //   return newBook;\r\n+      } catch (error) {\r\n+        console.error(\"Error adding book:\", error.message);\r\n+        throw new Error(\"Failed to add book. Please try again.\");\r\n+      }\r\n+    }),\r\n+     \r\n+\r\n+    // Update a book\r\n+    updateBook: (applyTokenChecker, async (_, args) => {\r\n+      try {\r\n+        const { bookCover, bookName, bookDescription, bookAuthor, bookCategory, bookLanguage, bookFile } = args.updatebook;\r\n+        const existingBook = await Book.findOne({ where: { id: args.id } });\r\n+        if (!existingBook) {\r\n+          throw new Error('Book not found');\r\n+        }\r\n+        const bookCoverUrl = bookCover ? await uploadToCloudinary(bookCover) : existingBook.bookCover;\r\n+        const bookFileUrl = bookFile ? await uploadToCloudinary(bookFile) : existingBook.bookFile;\r\n+        const [updateCount] = await Book.update(\r\n+          {\r\n+            bookCover: bookCoverUrl || existingBook.bookCover,\r\n+            bookName: bookName || existingBook.bookName,\r\n+            bookDescription: bookDescription || existingBook.bookDescription,\r\n+            bookAuthor: bookAuthor || existingBook.bookAuthor,\r\n+            bookCategory: bookCategory || existingBook.bookCategory,\r\n+            bookLanguage: bookLanguage || existingBook.bookLanguage,\r\n+            bookFile: bookFileUrl || existingBook.bookFile\r\n+          },\r\n+          { where: { id: args.id } }\r\n+        );\r\n+        if (updateCount === 0) {\r\n+          throw new Error('No changes detected');\r\n+        }\r\n+        const updatedBook = await Book.findOne({ where: { id: args.id } });\r\n+        return {success: true, message: `Boook info updated successfully` };\r\n+      } catch (error) {\r\n+        console.error('Error during deleteBook operation:', error.message);\r\n+        return {success: false, message: `Error deleting book: ${error.message}`};\r\n+      }\r\n+    }),\r\n+  \r\n+    \r\n+    deleteBook: (applyTokenChecker, async (_, { id }) => {\r\n+      try {\r\n+        const book = await Book.findByPk(id);\r\n+        if (!book) {\r\n+          throw new Error('Book not found.');\r\n+        }\r\n+     if (book.bookCover) {\r\n+    const coverPublicId = extractPublicId(book.bookCover);\r\n+    if (coverPublicId) {\r\n+      console.log(`Deleting book cover with public ID: ${coverPublicId}`);\r\n+      try {\r\n+        await deleteOldFileFromCloudinary(coverPublicId);\r\n+      } catch (error) {\r\n+        console.error(`Failed to delete book cover: ${error.message}`);\r\n+      }\r\n+    } else {\r\n+      console.warn('No valid public ID found for book cover.');\r\n+        }\r\n+      }\r\n+  if (book.bookFile) {\r\n+    const filePublicId = extractPublicId(book.bookFile);\r\n+    if (filePublicId) {\r\n+      console.log(`Deleting book file with public ID: ${filePublicId}`);\r\n+      try {\r\n+        await deleteOldFileFromCloudinary(filePublicId);\r\n+      } catch (error) {\r\n+        console.error(`Failed to delete book file: ${error.message}`);\r\n+      }\r\n+    } else {\r\n+      console.warn('No valid public ID found for book file.');\r\n+    }\r\n+  }\r\n+        const deleteCount = await Book.destroy({ where: { id } });\r\n+        if (deleteCount === 0) {\r\n+          throw new Error('Failed to delete book from the database.');\r\n+        }\r\n+        return {\r\n+          success: true,\r\n+          message: 'Book and associated files deleted successfully.',\r\n+        };\r\n+      } catch (error) {\r\n+        console.error('Error during deleteBook operation:', error.message);\r\n+        return {\r\n+          success: false,\r\n+          message: `Error deleting book: ${error.message}`,\r\n+        };\r\n+      }\r\n+    }),\r\n+    \r\n+    \r\n+\r\n+    // User signup\r\n+    signup: async (_, args) => {\r\n+      try {\r\n+        const { username, phoneNumber, email, password } = args.signupuser;\r\n+        const hashedPassword = await bcrypt.hash(password, 10);\r\n+        const data = await User.create({\r\n+          username,\r\n+          phoneNumber,\r\n+          email,\r\n+          password: hashedPassword\r\n+        });\r\n+        return data;\r\n+      } catch (error) {\r\n+        throw new Error(error.message);\r\n+      }\r\n+    },\r\n+    \r\n+    login: async (_, args, context) => {\r\n+      const { req } = context;\r\n+      const { username, password } = args.loginuser;\r\n+      try {\r\n+        const user = await User.findOne({ where: { username } });\r\n+        if (!user) {\r\n+         throw new Error('Incorrect username or password'); \r\n+        }\r\n+        const passwordMatch = await bcrypt.compare(password, user.password);   \r\n+              if (!passwordMatch) {\r\n+               throw new Error('Incorrect username or password'); \r\n+              }\r\n+              const token = jwt.sign({ userId: user.id, email:user.email }, process.env.SECRET_STRING, {expiresIn:'5h'})\r\n+              \r\n+            return { role: user.role, userId: user.id, token };\r\n+      } catch (error) {\r\n+        console.error(\"Error logging in:\", error.message);\r\n+        throw new Error(\"Login unsuccessful. Please try again.\");\r\n+      }\r\n+    },\r\n+\r\n+  \r\n+    updateUser: async (_, args) => {\r\n+      try {\r\n+        const existingUser =  User.findOne({where: {}})\r\n+        const { profilePic, fullName, username, phoneNumber, email } = args.updateuser;\r\n+        const profilePicUrl = profilePic ? await uploadToCloudinary(profilePic) : existingUser.profilePic;\r\n+        const [updateCount] = await User.update(\r\n+          {  \r\n+            profilePic: profilePicUrl, \r\n+             fullName: fullName || existingUser.fullName, \r\n+             username: username || existingUser.username, \r\n+             phoneNumber: phoneNumber || existingUser.phoneNumber, \r\n+             email: email || existingUser.email,\r\n+         },\r\n+          { where: { id: args.id } }\r\n+        );\r\n+        if (updateCount === 0) {\r\n+          throw new Error('User not found or nothing to update');\r\n+        }\r\n+        return { success: true, message: `User info updated successfully` };\r\n+      } catch (error) {\r\n+        return { success: false, message: `Error updating user: ${error.message}` };\r\n+      }\r\n+    },\r\n+\r\n+\r\n+    deleteUser: async (_, { id }) => {\r\n+      try {\r\n+        const user = await User.findByPk(id);\r\n+        if (!user) throw new Error(\"User not found\");\r\n+        const del = await User.destroy({ where: { id } });\r\n+        if (!del) throw new Error(\"Deletion not successful\");\r\n+        return { success: true, message: \"User info deleted successfully.\" };\r\n+      } catch (error) {\r\n+        return { success: false, message: `Error deleting user: ${error.message}` };\r\n+      }\r\n+    },\r\n+\r\n+\r\n+  }\r\n+};\r\n"
                },
                {
                    "date": 1736578002999,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,287 @@\n+import Book from \"../models/book.js\";\r\n+import User from \"../models/user.js\";\r\n+import bcrypt from \"bcrypt\";\r\n+import { GraphQLUpload } from 'graphql-upload';\r\n+import { Op } from 'sequelize';   \r\n+import jwt from'jsonwebtoken';\r\n+import { applyTokenChecker, uploadToCloudinary, deleteOldFileFromCloudinary, extractPublicId } from \"../config/cloudinary.js\";\r\n+\r\n+\r\n+\r\n+\r\n+export const resolvers = {\r\n+  Upload: GraphQLUpload,\r\n+\r\n+  Query: {\r\n+    books: async (_, { page = 1, perPage = 9 }) => {\r\n+      try {\r\n+          const offset = (page - 1) * perPage;\r\n+          const { rows: allBooks, count: totalBooks } = await Book.findAndCountAll({\r\n+              order: [['createdAt', 'DESC']],\r\n+              limit: perPage,\r\n+          offset: offset,\r\n+          });\r\n+          const lastPage = Math.ceil(totalBooks / perPage);\r\n+        const currentPage = page;\r\n+        const previousPage = currentPage-1;\r\n+        const nextPage = currentPage+1; \r\n+          return {\r\n+              allBooks,\r\n+             currentPage,\r\n+              previousPage,\r\n+              nextPage,\r\n+              lastPage,\r\n+          };\r\n+      } catch (error) {\r\n+          console.error('Error fetching books:', error);\r\n+          throw new Error('Unable to fetch books at the moment');\r\n+      }\r\n+  },\r\n+  \r\n+    book: async (_, args) => {\r\n+      try {\r\n+        const data = await Book.findOne({ where: { id: args.id } });\r\n+        return data;\r\n+      } catch (error) {\r\n+        throw new Error(error.message);\r\n+      }\r\n+    },\r\n+\r\n+    users: (applyTokenChecker, async () => {\r\n+      try {\r\n+        const data = await User.findAll();\r\n+        return data;\r\n+      } catch (error) {\r\n+        throw new Error(error.message);\r\n+      }\r\n+    }),\r\n+\r\n+    user:(applyTokenChecker) async (_, args) => {\r\n+      try {\r\n+        const data = await User.findOne({ where: { id: args.id } });\r\n+        return data;\r\n+      } catch (error) {\r\n+        throw new Error(error.message);\r\n+      }\r\n+    },\r\n+\r\n+    searchBooks: async (_, { searchTerm }) => {\r\n+      try {\r\n+        const lowerCaseSearchTerm = `%${searchTerm.toLowerCase()}%`; \r\n+        const books = await Book.findAll({\r\n+          where: {\r\n+            [Op.or]: [\r\n+              { bookName: { [Op.like]: lowerCaseSearchTerm } },\r\n+              { bookAuthor: { [Op.like]: lowerCaseSearchTerm } },\r\n+              { bookDescription: { [Op.like]: lowerCaseSearchTerm } }\r\n+            ]\r\n+          }\r\n+        });\r\n+        return books;\r\n+      } catch (error) {\r\n+        throw new Error(\"Error fetching books: \" + error.message);\r\n+      }\r\n+    }\r\n+  },\r\n+\r\n+  Mutation: {\r\n+\r\n+    addBook: (applyTokenChecker, async (_, { addbook }) => {\r\n+      try {\r\n+        const {\r\n+          bookCover,\r\n+          bookName,\r\n+          bookDescription,\r\n+          bookAuthor,\r\n+          bookCategory,\r\n+          bookLanguage,\r\n+          bookFile,\r\n+        } = addbook;\r\n+        if (!bookName || !bookDescription || !bookAuthor || !bookCategory || !bookLanguage) {\r\n+          throw new Error(\"All required fields (except files) must be provided.\");\r\n+        }\r\n+        const bookCoverUrl = bookCover ? await uploadToCloudinary(bookCover) : null;\r\n+        const bookFileUrl = bookFile ? await uploadToCloudinary(bookFile) : null;\r\n+        const newBook = await Book.create({\r\n+          bookCover: bookCoverUrl,\r\n+          bookName,\r\n+          bookDescription,\r\n+          bookAuthor,\r\n+          bookCategory,\r\n+          bookLanguage,\r\n+          bookFile: bookFileUrl,\r\n+          // postedBy:req.adminId\r\n+        });\r\n+        console.log(newBook)\r\n+      //   return newBook;\r\n+      } catch (error) {\r\n+        console.error(\"Error adding book:\", error.message);\r\n+        throw new Error(\"Failed to add book. Please try again.\");\r\n+      }\r\n+    }),\r\n+     \r\n+\r\n+    // Update a book\r\n+    updateBook: (applyTokenChecker, async (_, args) => {\r\n+      try {\r\n+        const { bookCover, bookName, bookDescription, bookAuthor, bookCategory, bookLanguage, bookFile } = args.updatebook;\r\n+        const existingBook = await Book.findOne({ where: { id: args.id } });\r\n+        if (!existingBook) {\r\n+          throw new Error('Book not found');\r\n+        }\r\n+        const bookCoverUrl = bookCover ? await uploadToCloudinary(bookCover) : existingBook.bookCover;\r\n+        const bookFileUrl = bookFile ? await uploadToCloudinary(bookFile) : existingBook.bookFile;\r\n+        const [updateCount] = await Book.update(\r\n+          {\r\n+            bookCover: bookCoverUrl || existingBook.bookCover,\r\n+            bookName: bookName || existingBook.bookName,\r\n+            bookDescription: bookDescription || existingBook.bookDescription,\r\n+            bookAuthor: bookAuthor || existingBook.bookAuthor,\r\n+            bookCategory: bookCategory || existingBook.bookCategory,\r\n+            bookLanguage: bookLanguage || existingBook.bookLanguage,\r\n+            bookFile: bookFileUrl || existingBook.bookFile\r\n+          },\r\n+          { where: { id: args.id } }\r\n+        );\r\n+        if (updateCount === 0) {\r\n+          throw new Error('No changes detected');\r\n+        }\r\n+        const updatedBook = await Book.findOne({ where: { id: args.id } });\r\n+        return {success: true, message: `Boook info updated successfully` };\r\n+      } catch (error) {\r\n+        console.error('Error during deleteBook operation:', error.message);\r\n+        return {success: false, message: `Error deleting book: ${error.message}`};\r\n+      }\r\n+    }),\r\n+  \r\n+    \r\n+    deleteBook: (applyTokenChecker, async (_, { id }) => {\r\n+      try {\r\n+        const book = await Book.findByPk(id);\r\n+        if (!book) {\r\n+          throw new Error('Book not found.');\r\n+        }\r\n+     if (book.bookCover) {\r\n+    const coverPublicId = extractPublicId(book.bookCover);\r\n+    if (coverPublicId) {\r\n+      console.log(`Deleting book cover with public ID: ${coverPublicId}`);\r\n+      try {\r\n+        await deleteOldFileFromCloudinary(coverPublicId);\r\n+      } catch (error) {\r\n+        console.error(`Failed to delete book cover: ${error.message}`);\r\n+      }\r\n+    } else {\r\n+      console.warn('No valid public ID found for book cover.');\r\n+        }\r\n+      }\r\n+  if (book.bookFile) {\r\n+    const filePublicId = extractPublicId(book.bookFile);\r\n+    if (filePublicId) {\r\n+      console.log(`Deleting book file with public ID: ${filePublicId}`);\r\n+      try {\r\n+        await deleteOldFileFromCloudinary(filePublicId);\r\n+      } catch (error) {\r\n+        console.error(`Failed to delete book file: ${error.message}`);\r\n+      }\r\n+    } else {\r\n+      console.warn('No valid public ID found for book file.');\r\n+    }\r\n+  }\r\n+        const deleteCount = await Book.destroy({ where: { id } });\r\n+        if (deleteCount === 0) {\r\n+          throw new Error('Failed to delete book from the database.');\r\n+        }\r\n+        return {\r\n+          success: true,\r\n+          message: 'Book and associated files deleted successfully.',\r\n+        };\r\n+      } catch (error) {\r\n+        console.error('Error during deleteBook operation:', error.message);\r\n+        return {\r\n+          success: false,\r\n+          message: `Error deleting book: ${error.message}`,\r\n+        };\r\n+      }\r\n+    }),\r\n+    \r\n+    \r\n+\r\n+    // User signup\r\n+    signup: async (_, args) => {\r\n+      try {\r\n+        const { username, phoneNumber, email, password } = args.signupuser;\r\n+        const hashedPassword = await bcrypt.hash(password, 10);\r\n+        const data = await User.create({\r\n+          username,\r\n+          phoneNumber,\r\n+          email,\r\n+          password: hashedPassword\r\n+        });\r\n+        return data;\r\n+      } catch (error) {\r\n+        throw new Error(error.message);\r\n+      }\r\n+    },\r\n+    \r\n+    login: async (_, args, context) => {\r\n+      const { req } = context;\r\n+      const { username, password } = args.loginuser;\r\n+      try {\r\n+        const user = await User.findOne({ where: { username } });\r\n+        if (!user) {\r\n+         throw new Error('Incorrect username or password'); \r\n+        }\r\n+        const passwordMatch = await bcrypt.compare(password, user.password);   \r\n+              if (!passwordMatch) {\r\n+               throw new Error('Incorrect username or password'); \r\n+              }\r\n+              const token = jwt.sign({ userId: user.id, email:user.email }, process.env.SECRET_STRING, {expiresIn:'5h'})\r\n+              \r\n+            return { role: user.role, userId: user.id, token };\r\n+      } catch (error) {\r\n+        console.error(\"Error logging in:\", error.message);\r\n+        throw new Error(\"Login unsuccessful. Please try again.\");\r\n+      }\r\n+    },\r\n+\r\n+  \r\n+    updateUser: async (_, args) => {\r\n+      try {\r\n+        const existingUser =  User.findOne({where: {}})\r\n+        const { profilePic, fullName, username, phoneNumber, email } = args.updateuser;\r\n+        const profilePicUrl = profilePic ? await uploadToCloudinary(profilePic) : existingUser.profilePic;\r\n+        const [updateCount] = await User.update(\r\n+          {  \r\n+            profilePic: profilePicUrl, \r\n+             fullName: fullName || existingUser.fullName, \r\n+             username: username || existingUser.username, \r\n+             phoneNumber: phoneNumber || existingUser.phoneNumber, \r\n+             email: email || existingUser.email,\r\n+         },\r\n+          { where: { id: args.id } }\r\n+        );\r\n+        if (updateCount === 0) {\r\n+          throw new Error('User not found or nothing to update');\r\n+        }\r\n+        return { success: true, message: `User info updated successfully` };\r\n+      } catch (error) {\r\n+        return { success: false, message: `Error updating user: ${error.message}` };\r\n+      }\r\n+    },\r\n+\r\n+\r\n+    deleteUser: async (_, { id }) => {\r\n+      try {\r\n+        const user = await User.findByPk(id);\r\n+        if (!user) throw new Error(\"User not found\");\r\n+        const del = await User.destroy({ where: { id } });\r\n+        if (!del) throw new Error(\"Deletion not successful\");\r\n+        return { success: true, message: \"User info deleted successfully.\" };\r\n+      } catch (error) {\r\n+        return { success: false, message: `Error deleting user: ${error.message}` };\r\n+      }\r\n+    },\r\n+\r\n+\r\n+  }\r\n+};\r\n"
                },
                {
                    "date": 1736578014099,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,287 @@\n+import Book from \"../models/book.js\";\r\n+import User from \"../models/user.js\";\r\n+import bcrypt from \"bcrypt\";\r\n+import { GraphQLUpload } from 'graphql-upload';\r\n+import { Op } from 'sequelize';   \r\n+import jwt from'jsonwebtoken';\r\n+import { applyTokenChecker, uploadToCloudinary, deleteOldFileFromCloudinary, extractPublicId } from \"../config/cloudinary.js\";\r\n+\r\n+\r\n+\r\n+\r\n+export const resolvers = {\r\n+  Upload: GraphQLUpload,\r\n+\r\n+  Query: {\r\n+    books: async (_, { page = 1, perPage = 9 }) => {\r\n+      try {\r\n+          const offset = (page - 1) * perPage;\r\n+          const { rows: allBooks, count: totalBooks } = await Book.findAndCountAll({\r\n+              order: [['createdAt', 'DESC']],\r\n+              limit: perPage,\r\n+          offset: offset,\r\n+          });\r\n+          const lastPage = Math.ceil(totalBooks / perPage);\r\n+        const currentPage = page;\r\n+        const previousPage = currentPage-1;\r\n+        const nextPage = currentPage+1; \r\n+          return {\r\n+              allBooks,\r\n+             currentPage,\r\n+              previousPage,\r\n+              nextPage,\r\n+              lastPage,\r\n+          };\r\n+      } catch (error) {\r\n+          console.error('Error fetching books:', error);\r\n+          throw new Error('Unable to fetch books at the moment');\r\n+      }\r\n+  },\r\n+  \r\n+    book: async (_, args) => {\r\n+      try {\r\n+        const data = await Book.findOne({ where: { id: args.id } });\r\n+        return data;\r\n+      } catch (error) {\r\n+        throw new Error(error.message);\r\n+      }\r\n+    },\r\n+\r\n+    users: (applyTokenChecker, async () => {\r\n+      try {\r\n+        const data = await User.findAll();\r\n+        return data;\r\n+      } catch (error) {\r\n+        throw new Error(error.message);\r\n+      }\r\n+    }),\r\n+\r\n+    user:(applyTokenCheckerasync (_, args) => {\r\n+      try {\r\n+        const data = await User.findOne({ where: { id: args.id } });\r\n+        return data;\r\n+      } catch (error) {\r\n+        throw new Error(error.message);\r\n+      }\r\n+    }) ,\r\n+\r\n+    searchBooks: async (_, { searchTerm }) => {\r\n+      try {\r\n+        const lowerCaseSearchTerm = `%${searchTerm.toLowerCase()}%`; \r\n+        const books = await Book.findAll({\r\n+          where: {\r\n+            [Op.or]: [\r\n+              { bookName: { [Op.like]: lowerCaseSearchTerm } },\r\n+              { bookAuthor: { [Op.like]: lowerCaseSearchTerm } },\r\n+              { bookDescription: { [Op.like]: lowerCaseSearchTerm } }\r\n+            ]\r\n+          }\r\n+        });\r\n+        return books;\r\n+      } catch (error) {\r\n+        throw new Error(\"Error fetching books: \" + error.message);\r\n+      }\r\n+    }\r\n+  },\r\n+\r\n+  Mutation: {\r\n+\r\n+    addBook: (applyTokenChecker, async (_, { addbook }) => {\r\n+      try {\r\n+        const {\r\n+          bookCover,\r\n+          bookName,\r\n+          bookDescription,\r\n+          bookAuthor,\r\n+          bookCategory,\r\n+          bookLanguage,\r\n+          bookFile,\r\n+        } = addbook;\r\n+        if (!bookName || !bookDescription || !bookAuthor || !bookCategory || !bookLanguage) {\r\n+          throw new Error(\"All required fields (except files) must be provided.\");\r\n+        }\r\n+        const bookCoverUrl = bookCover ? await uploadToCloudinary(bookCover) : null;\r\n+        const bookFileUrl = bookFile ? await uploadToCloudinary(bookFile) : null;\r\n+        const newBook = await Book.create({\r\n+          bookCover: bookCoverUrl,\r\n+          bookName,\r\n+          bookDescription,\r\n+          bookAuthor,\r\n+          bookCategory,\r\n+          bookLanguage,\r\n+          bookFile: bookFileUrl,\r\n+          // postedBy:req.adminId\r\n+        });\r\n+        console.log(newBook)\r\n+      //   return newBook;\r\n+      } catch (error) {\r\n+        console.error(\"Error adding book:\", error.message);\r\n+        throw new Error(\"Failed to add book. Please try again.\");\r\n+      }\r\n+    }),\r\n+     \r\n+\r\n+    // Update a book\r\n+    updateBook: (applyTokenChecker, async (_, args) => {\r\n+      try {\r\n+        const { bookCover, bookName, bookDescription, bookAuthor, bookCategory, bookLanguage, bookFile } = args.updatebook;\r\n+        const existingBook = await Book.findOne({ where: { id: args.id } });\r\n+        if (!existingBook) {\r\n+          throw new Error('Book not found');\r\n+        }\r\n+        const bookCoverUrl = bookCover ? await uploadToCloudinary(bookCover) : existingBook.bookCover;\r\n+        const bookFileUrl = bookFile ? await uploadToCloudinary(bookFile) : existingBook.bookFile;\r\n+        const [updateCount] = await Book.update(\r\n+          {\r\n+            bookCover: bookCoverUrl || existingBook.bookCover,\r\n+            bookName: bookName || existingBook.bookName,\r\n+            bookDescription: bookDescription || existingBook.bookDescription,\r\n+            bookAuthor: bookAuthor || existingBook.bookAuthor,\r\n+            bookCategory: bookCategory || existingBook.bookCategory,\r\n+            bookLanguage: bookLanguage || existingBook.bookLanguage,\r\n+            bookFile: bookFileUrl || existingBook.bookFile\r\n+          },\r\n+          { where: { id: args.id } }\r\n+        );\r\n+        if (updateCount === 0) {\r\n+          throw new Error('No changes detected');\r\n+        }\r\n+        const updatedBook = await Book.findOne({ where: { id: args.id } });\r\n+        return {success: true, message: `Boook info updated successfully` };\r\n+      } catch (error) {\r\n+        console.error('Error during deleteBook operation:', error.message);\r\n+        return {success: false, message: `Error deleting book: ${error.message}`};\r\n+      }\r\n+    }),\r\n+  \r\n+    \r\n+    deleteBook: (applyTokenChecker, async (_, { id }) => {\r\n+      try {\r\n+        const book = await Book.findByPk(id);\r\n+        if (!book) {\r\n+          throw new Error('Book not found.');\r\n+        }\r\n+     if (book.bookCover) {\r\n+    const coverPublicId = extractPublicId(book.bookCover);\r\n+    if (coverPublicId) {\r\n+      console.log(`Deleting book cover with public ID: ${coverPublicId}`);\r\n+      try {\r\n+        await deleteOldFileFromCloudinary(coverPublicId);\r\n+      } catch (error) {\r\n+        console.error(`Failed to delete book cover: ${error.message}`);\r\n+      }\r\n+    } else {\r\n+      console.warn('No valid public ID found for book cover.');\r\n+        }\r\n+      }\r\n+  if (book.bookFile) {\r\n+    const filePublicId = extractPublicId(book.bookFile);\r\n+    if (filePublicId) {\r\n+      console.log(`Deleting book file with public ID: ${filePublicId}`);\r\n+      try {\r\n+        await deleteOldFileFromCloudinary(filePublicId);\r\n+      } catch (error) {\r\n+        console.error(`Failed to delete book file: ${error.message}`);\r\n+      }\r\n+    } else {\r\n+      console.warn('No valid public ID found for book file.');\r\n+    }\r\n+  }\r\n+        const deleteCount = await Book.destroy({ where: { id } });\r\n+        if (deleteCount === 0) {\r\n+          throw new Error('Failed to delete book from the database.');\r\n+        }\r\n+        return {\r\n+          success: true,\r\n+          message: 'Book and associated files deleted successfully.',\r\n+        };\r\n+      } catch (error) {\r\n+        console.error('Error during deleteBook operation:', error.message);\r\n+        return {\r\n+          success: false,\r\n+          message: `Error deleting book: ${error.message}`,\r\n+        };\r\n+      }\r\n+    }),\r\n+    \r\n+    \r\n+\r\n+    // User signup\r\n+    signup: async (_, args) => {\r\n+      try {\r\n+        const { username, phoneNumber, email, password } = args.signupuser;\r\n+        const hashedPassword = await bcrypt.hash(password, 10);\r\n+        const data = await User.create({\r\n+          username,\r\n+          phoneNumber,\r\n+          email,\r\n+          password: hashedPassword\r\n+        });\r\n+        return data;\r\n+      } catch (error) {\r\n+        throw new Error(error.message);\r\n+      }\r\n+    },\r\n+    \r\n+    login: async (_, args, context) => {\r\n+      const { req } = context;\r\n+      const { username, password } = args.loginuser;\r\n+      try {\r\n+        const user = await User.findOne({ where: { username } });\r\n+        if (!user) {\r\n+         throw new Error('Incorrect username or password'); \r\n+        }\r\n+        const passwordMatch = await bcrypt.compare(password, user.password);   \r\n+              if (!passwordMatch) {\r\n+               throw new Error('Incorrect username or password'); \r\n+              }\r\n+              const token = jwt.sign({ userId: user.id, email:user.email }, process.env.SECRET_STRING, {expiresIn:'5h'})\r\n+              \r\n+            return { role: user.role, userId: user.id, token };\r\n+      } catch (error) {\r\n+        console.error(\"Error logging in:\", error.message);\r\n+        throw new Error(\"Login unsuccessful. Please try again.\");\r\n+      }\r\n+    },\r\n+\r\n+  \r\n+    updateUser: async (_, args) => {\r\n+      try {\r\n+        const existingUser =  User.findOne({where: {}})\r\n+        const { profilePic, fullName, username, phoneNumber, email } = args.updateuser;\r\n+        const profilePicUrl = profilePic ? await uploadToCloudinary(profilePic) : existingUser.profilePic;\r\n+        const [updateCount] = await User.update(\r\n+          {  \r\n+            profilePic: profilePicUrl, \r\n+             fullName: fullName || existingUser.fullName, \r\n+             username: username || existingUser.username, \r\n+             phoneNumber: phoneNumber || existingUser.phoneNumber, \r\n+             email: email || existingUser.email,\r\n+         },\r\n+          { where: { id: args.id } }\r\n+        );\r\n+        if (updateCount === 0) {\r\n+          throw new Error('User not found or nothing to update');\r\n+        }\r\n+        return { success: true, message: `User info updated successfully` };\r\n+      } catch (error) {\r\n+        return { success: false, message: `Error updating user: ${error.message}` };\r\n+      }\r\n+    },\r\n+\r\n+\r\n+    deleteUser: async (_, { id }) => {\r\n+      try {\r\n+        const user = await User.findByPk(id);\r\n+        if (!user) throw new Error(\"User not found\");\r\n+        const del = await User.destroy({ where: { id } });\r\n+        if (!del) throw new Error(\"Deletion not successful\");\r\n+        return { success: true, message: \"User info deleted successfully.\" };\r\n+      } catch (error) {\r\n+        return { success: false, message: `Error deleting user: ${error.message}` };\r\n+      }\r\n+    },\r\n+\r\n+\r\n+  }\r\n+};\r\n"
                },
                {
                    "date": 1736578024640,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,287 @@\n+import Book from \"../models/book.js\";\r\n+import User from \"../models/user.js\";\r\n+import bcrypt from \"bcrypt\";\r\n+import { GraphQLUpload } from 'graphql-upload';\r\n+import { Op } from 'sequelize';   \r\n+import jwt from'jsonwebtoken';\r\n+import { applyTokenChecker, uploadToCloudinary, deleteOldFileFromCloudinary, extractPublicId } from \"../config/cloudinary.js\";\r\n+\r\n+\r\n+\r\n+\r\n+export const resolvers = {\r\n+  Upload: GraphQLUpload,\r\n+\r\n+  Query: {\r\n+    books: async (_, { page = 1, perPage = 9 }) => {\r\n+      try {\r\n+          const offset = (page - 1) * perPage;\r\n+          const { rows: allBooks, count: totalBooks } = await Book.findAndCountAll({\r\n+              order: [['createdAt', 'DESC']],\r\n+              limit: perPage,\r\n+          offset: offset,\r\n+          });\r\n+          const lastPage = Math.ceil(totalBooks / perPage);\r\n+        const currentPage = page;\r\n+        const previousPage = currentPage-1;\r\n+        const nextPage = currentPage+1; \r\n+          return {\r\n+              allBooks,\r\n+             currentPage,\r\n+              previousPage,\r\n+              nextPage,\r\n+              lastPage,\r\n+          };\r\n+      } catch (error) {\r\n+          console.error('Error fetching books:', error);\r\n+          throw new Error('Unable to fetch books at the moment');\r\n+      }\r\n+  },\r\n+  \r\n+    book: async (_, args) => {\r\n+      try {\r\n+        const data = await Book.findOne({ where: { id: args.id } });\r\n+        return data;\r\n+      } catch (error) {\r\n+        throw new Error(error.message);\r\n+      }\r\n+    },\r\n+\r\n+    users: (applyTokenChecker, async () => {\r\n+      try {\r\n+        const data = await User.findAll();\r\n+        return data;\r\n+      } catch (error) {\r\n+        throw new Error(error.message);\r\n+      }\r\n+    }),\r\n+\r\n+    user:(applyTokenChecker, async (_, args) => {\r\n+      try {\r\n+        const data = await User.findOne({ where: { id: args.id } });\r\n+        return data;\r\n+      } catch (error) {\r\n+        throw new Error(error.message);\r\n+      }\r\n+    }),\r\n+\r\n+    searchBooks: async (_, { searchTerm }) => {\r\n+      try {\r\n+        const lowerCaseSearchTerm = `%${searchTerm.toLowerCase()}%`; \r\n+        const books = await Book.findAll({\r\n+          where: {\r\n+            [Op.or]: [\r\n+              { bookName: { [Op.like]: lowerCaseSearchTerm } },\r\n+              { bookAuthor: { [Op.like]: lowerCaseSearchTerm } },\r\n+              { bookDescription: { [Op.like]: lowerCaseSearchTerm } }\r\n+            ]\r\n+          }\r\n+        });\r\n+        return books;\r\n+      } catch (error) {\r\n+        throw new Error(\"Error fetching books: \" + error.message);\r\n+      }\r\n+    }\r\n+  },\r\n+\r\n+  Mutation: {\r\n+\r\n+    addBook: (applyTokenChecker, async (_, { addbook }) => {\r\n+      try {\r\n+        const {\r\n+          bookCover,\r\n+          bookName,\r\n+          bookDescription,\r\n+          bookAuthor,\r\n+          bookCategory,\r\n+          bookLanguage,\r\n+          bookFile,\r\n+        } = addbook;\r\n+        if (!bookName || !bookDescription || !bookAuthor || !bookCategory || !bookLanguage) {\r\n+          throw new Error(\"All required fields (except files) must be provided.\");\r\n+        }\r\n+        const bookCoverUrl = bookCover ? await uploadToCloudinary(bookCover) : null;\r\n+        const bookFileUrl = bookFile ? await uploadToCloudinary(bookFile) : null;\r\n+        const newBook = await Book.create({\r\n+          bookCover: bookCoverUrl,\r\n+          bookName,\r\n+          bookDescription,\r\n+          bookAuthor,\r\n+          bookCategory,\r\n+          bookLanguage,\r\n+          bookFile: bookFileUrl,\r\n+          // postedBy:req.adminId\r\n+        });\r\n+        console.log(newBook)\r\n+      //   return newBook;\r\n+      } catch (error) {\r\n+        console.error(\"Error adding book:\", error.message);\r\n+        throw new Error(\"Failed to add book. Please try again.\");\r\n+      }\r\n+    }),\r\n+     \r\n+\r\n+    // Update a book\r\n+    updateBook: (applyTokenChecker, async (_, args) => {\r\n+      try {\r\n+        const { bookCover, bookName, bookDescription, bookAuthor, bookCategory, bookLanguage, bookFile } = args.updatebook;\r\n+        const existingBook = await Book.findOne({ where: { id: args.id } });\r\n+        if (!existingBook) {\r\n+          throw new Error('Book not found');\r\n+        }\r\n+        const bookCoverUrl = bookCover ? await uploadToCloudinary(bookCover) : existingBook.bookCover;\r\n+        const bookFileUrl = bookFile ? await uploadToCloudinary(bookFile) : existingBook.bookFile;\r\n+        const [updateCount] = await Book.update(\r\n+          {\r\n+            bookCover: bookCoverUrl || existingBook.bookCover,\r\n+            bookName: bookName || existingBook.bookName,\r\n+            bookDescription: bookDescription || existingBook.bookDescription,\r\n+            bookAuthor: bookAuthor || existingBook.bookAuthor,\r\n+            bookCategory: bookCategory || existingBook.bookCategory,\r\n+            bookLanguage: bookLanguage || existingBook.bookLanguage,\r\n+            bookFile: bookFileUrl || existingBook.bookFile\r\n+          },\r\n+          { where: { id: args.id } }\r\n+        );\r\n+        if (updateCount === 0) {\r\n+          throw new Error('No changes detected');\r\n+        }\r\n+        const updatedBook = await Book.findOne({ where: { id: args.id } });\r\n+        return {success: true, message: `Boook info updated successfully` };\r\n+      } catch (error) {\r\n+        console.error('Error during deleteBook operation:', error.message);\r\n+        return {success: false, message: `Error deleting book: ${error.message}`};\r\n+      }\r\n+    }),\r\n+  \r\n+    \r\n+    deleteBook: (applyTokenChecker, async (_, { id }) => {\r\n+      try {\r\n+        const book = await Book.findByPk(id);\r\n+        if (!book) {\r\n+          throw new Error('Book not found.');\r\n+        }\r\n+     if (book.bookCover) {\r\n+    const coverPublicId = extractPublicId(book.bookCover);\r\n+    if (coverPublicId) {\r\n+      console.log(`Deleting book cover with public ID: ${coverPublicId}`);\r\n+      try {\r\n+        await deleteOldFileFromCloudinary(coverPublicId);\r\n+      } catch (error) {\r\n+        console.error(`Failed to delete book cover: ${error.message}`);\r\n+      }\r\n+    } else {\r\n+      console.warn('No valid public ID found for book cover.');\r\n+        }\r\n+      }\r\n+  if (book.bookFile) {\r\n+    const filePublicId = extractPublicId(book.bookFile);\r\n+    if (filePublicId) {\r\n+      console.log(`Deleting book file with public ID: ${filePublicId}`);\r\n+      try {\r\n+        await deleteOldFileFromCloudinary(filePublicId);\r\n+      } catch (error) {\r\n+        console.error(`Failed to delete book file: ${error.message}`);\r\n+      }\r\n+    } else {\r\n+      console.warn('No valid public ID found for book file.');\r\n+    }\r\n+  }\r\n+        const deleteCount = await Book.destroy({ where: { id } });\r\n+        if (deleteCount === 0) {\r\n+          throw new Error('Failed to delete book from the database.');\r\n+        }\r\n+        return {\r\n+          success: true,\r\n+          message: 'Book and associated files deleted successfully.',\r\n+        };\r\n+      } catch (error) {\r\n+        console.error('Error during deleteBook operation:', error.message);\r\n+        return {\r\n+          success: false,\r\n+          message: `Error deleting book: ${error.message}`,\r\n+        };\r\n+      }\r\n+    }),\r\n+    \r\n+    \r\n+\r\n+    // User signup\r\n+    signup: async (_, args) => {\r\n+      try {\r\n+        const { username, phoneNumber, email, password } = args.signupuser;\r\n+        const hashedPassword = await bcrypt.hash(password, 10);\r\n+        const data = await User.create({\r\n+          username,\r\n+          phoneNumber,\r\n+          email,\r\n+          password: hashedPassword\r\n+        });\r\n+        return data;\r\n+      } catch (error) {\r\n+        throw new Error(error.message);\r\n+      }\r\n+    },\r\n+    \r\n+    login: async (_, args, context) => {\r\n+      const { req } = context;\r\n+      const { username, password } = args.loginuser;\r\n+      try {\r\n+        const user = await User.findOne({ where: { username } });\r\n+        if (!user) {\r\n+         throw new Error('Incorrect username or password'); \r\n+        }\r\n+        const passwordMatch = await bcrypt.compare(password, user.password);   \r\n+              if (!passwordMatch) {\r\n+               throw new Error('Incorrect username or password'); \r\n+              }\r\n+              const token = jwt.sign({ userId: user.id, email:user.email }, process.env.SECRET_STRING, {expiresIn:'5h'})\r\n+              \r\n+            return { role: user.role, userId: user.id, token };\r\n+      } catch (error) {\r\n+        console.error(\"Error logging in:\", error.message);\r\n+        throw new Error(\"Login unsuccessful. Please try again.\");\r\n+      }\r\n+    },\r\n+\r\n+  \r\n+    updateUser: async (_, args) => {\r\n+      try {\r\n+        const existingUser =  User.findOne({where: {}})\r\n+        const { profilePic, fullName, username, phoneNumber, email } = args.updateuser;\r\n+        const profilePicUrl = profilePic ? await uploadToCloudinary(profilePic) : existingUser.profilePic;\r\n+        const [updateCount] = await User.update(\r\n+          {  \r\n+            profilePic: profilePicUrl, \r\n+             fullName: fullName || existingUser.fullName, \r\n+             username: username || existingUser.username, \r\n+             phoneNumber: phoneNumber || existingUser.phoneNumber, \r\n+             email: email || existingUser.email,\r\n+         },\r\n+          { where: { id: args.id } }\r\n+        );\r\n+        if (updateCount === 0) {\r\n+          throw new Error('User not found or nothing to update');\r\n+        }\r\n+        return { success: true, message: `User info updated successfully` };\r\n+      } catch (error) {\r\n+        return { success: false, message: `Error updating user: ${error.message}` };\r\n+      }\r\n+    },\r\n+\r\n+\r\n+    deleteUser: async (_, { id }) => {\r\n+      try {\r\n+        const user = await User.findByPk(id);\r\n+        if (!user) throw new Error(\"User not found\");\r\n+        const del = await User.destroy({ where: { id } });\r\n+        if (!del) throw new Error(\"Deletion not successful\");\r\n+        return { success: true, message: \"User info deleted successfully.\" };\r\n+      } catch (error) {\r\n+        return { success: false, message: `Error deleting user: ${error.message}` };\r\n+      }\r\n+    },\r\n+\r\n+\r\n+  }\r\n+};\r\n"
                },
                {
                    "date": 1736578103451,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -244,9 +244,9 @@\n       }\r\n     },\r\n \r\n   \r\n-    updateUser: async (_, args) => {\r\n+    updateUser: (async (_, args) => {\r\n       try {\r\n         const existingUser =  User.findOne({where: {}})\r\n         const { profilePic, fullName, username, phoneNumber, email } = args.updateuser;\r\n         const profilePicUrl = profilePic ? await uploadToCloudinary(profilePic) : existingUser.profilePic;\r\n@@ -284,1439 +284,4 @@\n \r\n \r\n   }\r\n };\r\n-import Book from \"../models/book.js\";\r\n-import User from \"../models/user.js\";\r\n-import bcrypt from \"bcrypt\";\r\n-import { GraphQLUpload } from 'graphql-upload';\r\n-import { Op } from 'sequelize';   \r\n-import jwt from'jsonwebtoken';\r\n-import { applyTokenChecker, uploadToCloudinary, deleteOldFileFromCloudinary, extractPublicId } from \"../config/cloudinary.js\";\r\n-\r\n-\r\n-\r\n-\r\n-export const resolvers = {\r\n-  Upload: GraphQLUpload,\r\n-\r\n-  Query: {\r\n-    books: async (_, { page = 1, perPage = 9 }) => {\r\n-      try {\r\n-          const offset = (page - 1) * perPage;\r\n-          const { rows: allBooks, count: totalBooks } = await Book.findAndCountAll({\r\n-              order: [['createdAt', 'DESC']],\r\n-              limit: perPage,\r\n-          offset: offset,\r\n-          });\r\n-          const lastPage = Math.ceil(totalBooks / perPage);\r\n-        const currentPage = page;\r\n-        const previousPage = currentPage-1;\r\n-        const nextPage = currentPage+1; \r\n-          return {\r\n-              allBooks,\r\n-             currentPage,\r\n-              previousPage,\r\n-              nextPage,\r\n-              lastPage,\r\n-          };\r\n-      } catch (error) {\r\n-          console.error('Error fetching books:', error);\r\n-          throw new Error('Unable to fetch books at the moment');\r\n-      }\r\n-  },\r\n-  \r\n-    book: async (_, args) => {\r\n-      try {\r\n-        const data = await Book.findOne({ where: { id: args.id } });\r\n-        return data;\r\n-      } catch (error) {\r\n-        throw new Error(error.message);\r\n-      }\r\n-    },\r\n-\r\n-    users: (applyTokenChecker, async () => {\r\n-      try {\r\n-        const data = await User.findAll();\r\n-        return data;\r\n-      } catch (error) {\r\n-        throw new Error(error.message);\r\n-      }\r\n-    }),\r\n-\r\n-    user:(applyTokenCheckerasync (_, args) => {\r\n-      try {\r\n-        const data = await User.findOne({ where: { id: args.id } });\r\n-        return data;\r\n-      } catch (error) {\r\n-        throw new Error(error.message);\r\n-      }\r\n-    }) ,\r\n-\r\n-    searchBooks: async (_, { searchTerm }) => {\r\n-      try {\r\n-        const lowerCaseSearchTerm = `%${searchTerm.toLowerCase()}%`; \r\n-        const books = await Book.findAll({\r\n-          where: {\r\n-            [Op.or]: [\r\n-              { bookName: { [Op.like]: lowerCaseSearchTerm } },\r\n-              { bookAuthor: { [Op.like]: lowerCaseSearchTerm } },\r\n-              { bookDescription: { [Op.like]: lowerCaseSearchTerm } }\r\n-            ]\r\n-          }\r\n-        });\r\n-        return books;\r\n-      } catch (error) {\r\n-        throw new Error(\"Error fetching books: \" + error.message);\r\n-      }\r\n-    }\r\n-  },\r\n-\r\n-  Mutation: {\r\n-\r\n-    addBook: (applyTokenChecker, async (_, { addbook }) => {\r\n-      try {\r\n-        const {\r\n-          bookCover,\r\n-          bookName,\r\n-          bookDescription,\r\n-          bookAuthor,\r\n-          bookCategory,\r\n-          bookLanguage,\r\n-          bookFile,\r\n-        } = addbook;\r\n-        if (!bookName || !bookDescription || !bookAuthor || !bookCategory || !bookLanguage) {\r\n-          throw new Error(\"All required fields (except files) must be provided.\");\r\n-        }\r\n-        const bookCoverUrl = bookCover ? await uploadToCloudinary(bookCover) : null;\r\n-        const bookFileUrl = bookFile ? await uploadToCloudinary(bookFile) : null;\r\n-        const newBook = await Book.create({\r\n-          bookCover: bookCoverUrl,\r\n-          bookName,\r\n-          bookDescription,\r\n-          bookAuthor,\r\n-          bookCategory,\r\n-          bookLanguage,\r\n-          bookFile: bookFileUrl,\r\n-          // postedBy:req.adminId\r\n-        });\r\n-        console.log(newBook)\r\n-      //   return newBook;\r\n-      } catch (error) {\r\n-        console.error(\"Error adding book:\", error.message);\r\n-        throw new Error(\"Failed to add book. Please try again.\");\r\n-      }\r\n-    }),\r\n-     \r\n-\r\n-    // Update a book\r\n-    updateBook: (applyTokenChecker, async (_, args) => {\r\n-      try {\r\n-        const { bookCover, bookName, bookDescription, bookAuthor, bookCategory, bookLanguage, bookFile } = args.updatebook;\r\n-        const existingBook = await Book.findOne({ where: { id: args.id } });\r\n-        if (!existingBook) {\r\n-          throw new Error('Book not found');\r\n-        }\r\n-        const bookCoverUrl = bookCover ? await uploadToCloudinary(bookCover) : existingBook.bookCover;\r\n-        const bookFileUrl = bookFile ? await uploadToCloudinary(bookFile) : existingBook.bookFile;\r\n-        const [updateCount] = await Book.update(\r\n-          {\r\n-            bookCover: bookCoverUrl || existingBook.bookCover,\r\n-            bookName: bookName || existingBook.bookName,\r\n-            bookDescription: bookDescription || existingBook.bookDescription,\r\n-            bookAuthor: bookAuthor || existingBook.bookAuthor,\r\n-            bookCategory: bookCategory || existingBook.bookCategory,\r\n-            bookLanguage: bookLanguage || existingBook.bookLanguage,\r\n-            bookFile: bookFileUrl || existingBook.bookFile\r\n-          },\r\n-          { where: { id: args.id } }\r\n-        );\r\n-        if (updateCount === 0) {\r\n-          throw new Error('No changes detected');\r\n-        }\r\n-        const updatedBook = await Book.findOne({ where: { id: args.id } });\r\n-        return {success: true, message: `Boook info updated successfully` };\r\n-      } catch (error) {\r\n-        console.error('Error during deleteBook operation:', error.message);\r\n-        return {success: false, message: `Error deleting book: ${error.message}`};\r\n-      }\r\n-    }),\r\n-  \r\n-    \r\n-    deleteBook: (applyTokenChecker, async (_, { id }) => {\r\n-      try {\r\n-        const book = await Book.findByPk(id);\r\n-        if (!book) {\r\n-          throw new Error('Book not found.');\r\n-        }\r\n-     if (book.bookCover) {\r\n-    const coverPublicId = extractPublicId(book.bookCover);\r\n-    if (coverPublicId) {\r\n-      console.log(`Deleting book cover with public ID: ${coverPublicId}`);\r\n-      try {\r\n-        await deleteOldFileFromCloudinary(coverPublicId);\r\n-      } catch (error) {\r\n-        console.error(`Failed to delete book cover: ${error.message}`);\r\n-      }\r\n-    } else {\r\n-      console.warn('No valid public ID found for book cover.');\r\n-        }\r\n-      }\r\n-  if (book.bookFile) {\r\n-    const filePublicId = extractPublicId(book.bookFile);\r\n-    if (filePublicId) {\r\n-      console.log(`Deleting book file with public ID: ${filePublicId}`);\r\n-      try {\r\n-        await deleteOldFileFromCloudinary(filePublicId);\r\n-      } catch (error) {\r\n-        console.error(`Failed to delete book file: ${error.message}`);\r\n-      }\r\n-    } else {\r\n-      console.warn('No valid public ID found for book file.');\r\n-    }\r\n-  }\r\n-        const deleteCount = await Book.destroy({ where: { id } });\r\n-        if (deleteCount === 0) {\r\n-          throw new Error('Failed to delete book from the database.');\r\n-        }\r\n-        return {\r\n-          success: true,\r\n-          message: 'Book and associated files deleted successfully.',\r\n-        };\r\n-      } catch (error) {\r\n-        console.error('Error during deleteBook operation:', error.message);\r\n-        return {\r\n-          success: false,\r\n-          message: `Error deleting book: ${error.message}`,\r\n-        };\r\n-      }\r\n-    }),\r\n-    \r\n-    \r\n-\r\n-    // User signup\r\n-    signup: async (_, args) => {\r\n-      try {\r\n-        const { username, phoneNumber, email, password } = args.signupuser;\r\n-        const hashedPassword = await bcrypt.hash(password, 10);\r\n-        const data = await User.create({\r\n-          username,\r\n-          phoneNumber,\r\n-          email,\r\n-          password: hashedPassword\r\n-        });\r\n-        return data;\r\n-      } catch (error) {\r\n-        throw new Error(error.message);\r\n-      }\r\n-    },\r\n-    \r\n-    login: async (_, args, context) => {\r\n-      const { req } = context;\r\n-      const { username, password } = args.loginuser;\r\n-      try {\r\n-        const user = await User.findOne({ where: { username } });\r\n-        if (!user) {\r\n-         throw new Error('Incorrect username or password'); \r\n-        }\r\n-        const passwordMatch = await bcrypt.compare(password, user.password);   \r\n-              if (!passwordMatch) {\r\n-               throw new Error('Incorrect username or password'); \r\n-              }\r\n-              const token = jwt.sign({ userId: user.id, email:user.email }, process.env.SECRET_STRING, {expiresIn:'5h'})\r\n-              \r\n-            return { role: user.role, userId: user.id, token };\r\n-      } catch (error) {\r\n-        console.error(\"Error logging in:\", error.message);\r\n-        throw new Error(\"Login unsuccessful. Please try again.\");\r\n-      }\r\n-    },\r\n-\r\n-  \r\n-    updateUser: async (_, args) => {\r\n-      try {\r\n-        const existingUser =  User.findOne({where: {}})\r\n-        const { profilePic, fullName, username, phoneNumber, email } = args.updateuser;\r\n-        const profilePicUrl = profilePic ? await uploadToCloudinary(profilePic) : existingUser.profilePic;\r\n-        const [updateCount] = await User.update(\r\n-          {  \r\n-            profilePic: profilePicUrl, \r\n-             fullName: fullName || existingUser.fullName, \r\n-             username: username || existingUser.username, \r\n-             phoneNumber: phoneNumber || existingUser.phoneNumber, \r\n-             email: email || existingUser.email,\r\n-         },\r\n-          { where: { id: args.id } }\r\n-        );\r\n-        if (updateCount === 0) {\r\n-          throw new Error('User not found or nothing to update');\r\n-        }\r\n-        return { success: true, message: `User info updated successfully` };\r\n-      } catch (error) {\r\n-        return { success: false, message: `Error updating user: ${error.message}` };\r\n-      }\r\n-    },\r\n-\r\n-\r\n-    deleteUser: async (_, { id }) => {\r\n-      try {\r\n-        const user = await User.findByPk(id);\r\n-        if (!user) throw new Error(\"User not found\");\r\n-        const del = await User.destroy({ where: { id } });\r\n-        if (!del) throw new Error(\"Deletion not successful\");\r\n-        return { success: true, message: \"User info deleted successfully.\" };\r\n-      } catch (error) {\r\n-        return { success: false, message: `Error deleting user: ${error.message}` };\r\n-      }\r\n-    },\r\n-\r\n-\r\n-  }\r\n-};\r\n-import Book from \"../models/book.js\";\r\n-import User from \"../models/user.js\";\r\n-import bcrypt from \"bcrypt\";\r\n-import { GraphQLUpload } from 'graphql-upload';\r\n-import { Op } from 'sequelize';   \r\n-import jwt from'jsonwebtoken';\r\n-import { applyTokenChecker, uploadToCloudinary, deleteOldFileFromCloudinary, extractPublicId } from \"../config/cloudinary.js\";\r\n-\r\n-\r\n-\r\n-\r\n-export const resolvers = {\r\n-  Upload: GraphQLUpload,\r\n-\r\n-  Query: {\r\n-    books: async (_, { page = 1, perPage = 9 }) => {\r\n-      try {\r\n-          const offset = (page - 1) * perPage;\r\n-          const { rows: allBooks, count: totalBooks } = await Book.findAndCountAll({\r\n-              order: [['createdAt', 'DESC']],\r\n-              limit: perPage,\r\n-          offset: offset,\r\n-          });\r\n-          const lastPage = Math.ceil(totalBooks / perPage);\r\n-        const currentPage = page;\r\n-        const previousPage = currentPage-1;\r\n-        const nextPage = currentPage+1; \r\n-          return {\r\n-              allBooks,\r\n-             currentPage,\r\n-              previousPage,\r\n-              nextPage,\r\n-              lastPage,\r\n-          };\r\n-      } catch (error) {\r\n-          console.error('Error fetching books:', error);\r\n-          throw new Error('Unable to fetch books at the moment');\r\n-      }\r\n-  },\r\n-  \r\n-    book: async (_, args) => {\r\n-      try {\r\n-        const data = await Book.findOne({ where: { id: args.id } });\r\n-        return data;\r\n-      } catch (error) {\r\n-        throw new Error(error.message);\r\n-      }\r\n-    },\r\n-\r\n-    users: (applyTokenChecker, async () => {\r\n-      try {\r\n-        const data = await User.findAll();\r\n-        return data;\r\n-      } catch (error) {\r\n-        throw new Error(error.message);\r\n-      }\r\n-    }),\r\n-\r\n-    user:(applyTokenChecker) async (_, args) => {\r\n-      try {\r\n-        const data = await User.findOne({ where: { id: args.id } });\r\n-        return data;\r\n-      } catch (error) {\r\n-        throw new Error(error.message);\r\n-      }\r\n-    },\r\n-\r\n-    searchBooks: async (_, { searchTerm }) => {\r\n-      try {\r\n-        const lowerCaseSearchTerm = `%${searchTerm.toLowerCase()}%`; \r\n-        const books = await Book.findAll({\r\n-          where: {\r\n-            [Op.or]: [\r\n-              { bookName: { [Op.like]: lowerCaseSearchTerm } },\r\n-              { bookAuthor: { [Op.like]: lowerCaseSearchTerm } },\r\n-              { bookDescription: { [Op.like]: lowerCaseSearchTerm } }\r\n-            ]\r\n-          }\r\n-        });\r\n-        return books;\r\n-      } catch (error) {\r\n-        throw new Error(\"Error fetching books: \" + error.message);\r\n-      }\r\n-    }\r\n-  },\r\n-\r\n-  Mutation: {\r\n-\r\n-    addBook: (applyTokenChecker, async (_, { addbook }) => {\r\n-      try {\r\n-        const {\r\n-          bookCover,\r\n-          bookName,\r\n-          bookDescription,\r\n-          bookAuthor,\r\n-          bookCategory,\r\n-          bookLanguage,\r\n-          bookFile,\r\n-        } = addbook;\r\n-        if (!bookName || !bookDescription || !bookAuthor || !bookCategory || !bookLanguage) {\r\n-          throw new Error(\"All required fields (except files) must be provided.\");\r\n-        }\r\n-        const bookCoverUrl = bookCover ? await uploadToCloudinary(bookCover) : null;\r\n-        const bookFileUrl = bookFile ? await uploadToCloudinary(bookFile) : null;\r\n-        const newBook = await Book.create({\r\n-          bookCover: bookCoverUrl,\r\n-          bookName,\r\n-          bookDescription,\r\n-          bookAuthor,\r\n-          bookCategory,\r\n-          bookLanguage,\r\n-          bookFile: bookFileUrl,\r\n-          // postedBy:req.adminId\r\n-        });\r\n-        console.log(newBook)\r\n-      //   return newBook;\r\n-      } catch (error) {\r\n-        console.error(\"Error adding book:\", error.message);\r\n-        throw new Error(\"Failed to add book. Please try again.\");\r\n-      }\r\n-    }),\r\n-     \r\n-\r\n-    // Update a book\r\n-    updateBook: (applyTokenChecker, async (_, args) => {\r\n-      try {\r\n-        const { bookCover, bookName, bookDescription, bookAuthor, bookCategory, bookLanguage, bookFile } = args.updatebook;\r\n-        const existingBook = await Book.findOne({ where: { id: args.id } });\r\n-        if (!existingBook) {\r\n-          throw new Error('Book not found');\r\n-        }\r\n-        const bookCoverUrl = bookCover ? await uploadToCloudinary(bookCover) : existingBook.bookCover;\r\n-        const bookFileUrl = bookFile ? await uploadToCloudinary(bookFile) : existingBook.bookFile;\r\n-        const [updateCount] = await Book.update(\r\n-          {\r\n-            bookCover: bookCoverUrl || existingBook.bookCover,\r\n-            bookName: bookName || existingBook.bookName,\r\n-            bookDescription: bookDescription || existingBook.bookDescription,\r\n-            bookAuthor: bookAuthor || existingBook.bookAuthor,\r\n-            bookCategory: bookCategory || existingBook.bookCategory,\r\n-            bookLanguage: bookLanguage || existingBook.bookLanguage,\r\n-            bookFile: bookFileUrl || existingBook.bookFile\r\n-          },\r\n-          { where: { id: args.id } }\r\n-        );\r\n-        if (updateCount === 0) {\r\n-          throw new Error('No changes detected');\r\n-        }\r\n-        const updatedBook = await Book.findOne({ where: { id: args.id } });\r\n-        return {success: true, message: `Boook info updated successfully` };\r\n-      } catch (error) {\r\n-        console.error('Error during deleteBook operation:', error.message);\r\n-        return {success: false, message: `Error deleting book: ${error.message}`};\r\n-      }\r\n-    }),\r\n-  \r\n-    \r\n-    deleteBook: (applyTokenChecker, async (_, { id }) => {\r\n-      try {\r\n-        const book = await Book.findByPk(id);\r\n-        if (!book) {\r\n-          throw new Error('Book not found.');\r\n-        }\r\n-     if (book.bookCover) {\r\n-    const coverPublicId = extractPublicId(book.bookCover);\r\n-    if (coverPublicId) {\r\n-      console.log(`Deleting book cover with public ID: ${coverPublicId}`);\r\n-      try {\r\n-        await deleteOldFileFromCloudinary(coverPublicId);\r\n-      } catch (error) {\r\n-        console.error(`Failed to delete book cover: ${error.message}`);\r\n-      }\r\n-    } else {\r\n-      console.warn('No valid public ID found for book cover.');\r\n-        }\r\n-      }\r\n-  if (book.bookFile) {\r\n-    const filePublicId = extractPublicId(book.bookFile);\r\n-    if (filePublicId) {\r\n-      console.log(`Deleting book file with public ID: ${filePublicId}`);\r\n-      try {\r\n-        await deleteOldFileFromCloudinary(filePublicId);\r\n-      } catch (error) {\r\n-        console.error(`Failed to delete book file: ${error.message}`);\r\n-      }\r\n-    } else {\r\n-      console.warn('No valid public ID found for book file.');\r\n-    }\r\n-  }\r\n-        const deleteCount = await Book.destroy({ where: { id } });\r\n-        if (deleteCount === 0) {\r\n-          throw new Error('Failed to delete book from the database.');\r\n-        }\r\n-        return {\r\n-          success: true,\r\n-          message: 'Book and associated files deleted successfully.',\r\n-        };\r\n-      } catch (error) {\r\n-        console.error('Error during deleteBook operation:', error.message);\r\n-        return {\r\n-          success: false,\r\n-          message: `Error deleting book: ${error.message}`,\r\n-        };\r\n-      }\r\n-    }),\r\n-    \r\n-    \r\n-\r\n-    // User signup\r\n-    signup: async (_, args) => {\r\n-      try {\r\n-        const { username, phoneNumber, email, password } = args.signupuser;\r\n-        const hashedPassword = await bcrypt.hash(password, 10);\r\n-        const data = await User.create({\r\n-          username,\r\n-          phoneNumber,\r\n-          email,\r\n-          password: hashedPassword\r\n-        });\r\n-        return data;\r\n-      } catch (error) {\r\n-        throw new Error(error.message);\r\n-      }\r\n-    },\r\n-    \r\n-    login: async (_, args, context) => {\r\n-      const { req } = context;\r\n-      const { username, password } = args.loginuser;\r\n-      try {\r\n-        const user = await User.findOne({ where: { username } });\r\n-        if (!user) {\r\n-         throw new Error('Incorrect username or password'); \r\n-        }\r\n-        const passwordMatch = await bcrypt.compare(password, user.password);   \r\n-              if (!passwordMatch) {\r\n-               throw new Error('Incorrect username or password'); \r\n-              }\r\n-              const token = jwt.sign({ userId: user.id, email:user.email }, process.env.SECRET_STRING, {expiresIn:'5h'})\r\n-              \r\n-            return { role: user.role, userId: user.id, token };\r\n-      } catch (error) {\r\n-        console.error(\"Error logging in:\", error.message);\r\n-        throw new Error(\"Login unsuccessful. Please try again.\");\r\n-      }\r\n-    },\r\n-\r\n-  \r\n-    updateUser: async (_, args) => {\r\n-      try {\r\n-        const existingUser =  User.findOne({where: {}})\r\n-        const { profilePic, fullName, username, phoneNumber, email } = args.updateuser;\r\n-        const profilePicUrl = profilePic ? await uploadToCloudinary(profilePic) : existingUser.profilePic;\r\n-        const [updateCount] = await User.update(\r\n-          {  \r\n-            profilePic: profilePicUrl, \r\n-             fullName: fullName || existingUser.fullName, \r\n-             username: username || existingUser.username, \r\n-             phoneNumber: phoneNumber || existingUser.phoneNumber, \r\n-             email: email || existingUser.email,\r\n-         },\r\n-          { where: { id: args.id } }\r\n-        );\r\n-        if (updateCount === 0) {\r\n-          throw new Error('User not found or nothing to update');\r\n-        }\r\n-        return { success: true, message: `User info updated successfully` };\r\n-      } catch (error) {\r\n-        return { success: false, message: `Error updating user: ${error.message}` };\r\n-      }\r\n-    },\r\n-\r\n-\r\n-    deleteUser: async (_, { id }) => {\r\n-      try {\r\n-        const user = await User.findByPk(id);\r\n-        if (!user) throw new Error(\"User not found\");\r\n-        const del = await User.destroy({ where: { id } });\r\n-        if (!del) throw new Error(\"Deletion not successful\");\r\n-        return { success: true, message: \"User info deleted successfully.\" };\r\n-      } catch (error) {\r\n-        return { success: false, message: `Error deleting user: ${error.message}` };\r\n-      }\r\n-    },\r\n-\r\n-\r\n-  }\r\n-};\r\n-import Book from \"../models/book.js\";\r\n-import User from \"../models/user.js\";\r\n-import bcrypt from \"bcrypt\";\r\n-import { GraphQLUpload } from 'graphql-upload';\r\n-import { Op } from 'sequelize';   \r\n-import jwt from'jsonwebtoken';\r\n-import { applyTokenChecker, uploadToCloudinary, deleteOldFileFromCloudinary, extractPublicId } from \"../config/cloudinary.js\";\r\n-\r\n-\r\n-\r\n-\r\n-export const resolvers = {\r\n-  Upload: GraphQLUpload,\r\n-\r\n-  Query: {\r\n-    books: async (_, { page = 1, perPage = 9 }) => {\r\n-      try {\r\n-          const offset = (page - 1) * perPage;\r\n-          const { rows: allBooks, count: totalBooks } = await Book.findAndCountAll({\r\n-              order: [['createdAt', 'DESC']],\r\n-              limit: perPage,\r\n-          offset: offset,\r\n-          });\r\n-          const lastPage = Math.ceil(totalBooks / perPage);\r\n-        const currentPage = page;\r\n-        const previousPage = currentPage-1;\r\n-        const nextPage = currentPage+1; \r\n-          return {\r\n-              allBooks,\r\n-             currentPage,\r\n-              previousPage,\r\n-              nextPage,\r\n-              lastPage,\r\n-          };\r\n-      } catch (error) {\r\n-          console.error('Error fetching books:', error);\r\n-          throw new Error('Unable to fetch books at the moment');\r\n-      }\r\n-  },\r\n-  \r\n-    book: async (_, args) => {\r\n-      try {\r\n-        const data = await Book.findOne({ where: { id: args.id } });\r\n-        return data;\r\n-      } catch (error) {\r\n-        throw new Error(error.message);\r\n-      }\r\n-    },\r\n-\r\n-    users: (applyTokenChecker, async () => {\r\n-      try {\r\n-        const data = await User.findAll();\r\n-        return data;\r\n-      } catch (error) {\r\n-        throw new Error(error.message);\r\n-      }\r\n-    }),\r\n-\r\n-    user: async (_, args) => {\r\n-      try {\r\n-        const data = await User.findOne({ where: { id: args.id } });\r\n-        return data;\r\n-      } catch (error) {\r\n-        throw new Error(error.message);\r\n-      }\r\n-    },\r\n-\r\n-    searchBooks: async (_, { searchTerm }) => {\r\n-      try {\r\n-        const lowerCaseSearchTerm = `%${searchTerm.toLowerCase()}%`; \r\n-        const books = await Book.findAll({\r\n-          where: {\r\n-            [Op.or]: [\r\n-              { bookName: { [Op.like]: lowerCaseSearchTerm } },\r\n-              { bookAuthor: { [Op.like]: lowerCaseSearchTerm } },\r\n-              { bookDescription: { [Op.like]: lowerCaseSearchTerm } }\r\n-            ]\r\n-          }\r\n-        });\r\n-        return books;\r\n-      } catch (error) {\r\n-        throw new Error(\"Error fetching books: \" + error.message);\r\n-      }\r\n-    }\r\n-  },\r\n-\r\n-  Mutation: {\r\n-\r\n-    addBook: (applyTokenChecker, async (_, { addbook }) => {\r\n-      try {\r\n-        const {\r\n-          bookCover,\r\n-          bookName,\r\n-          bookDescription,\r\n-          bookAuthor,\r\n-          bookCategory,\r\n-          bookLanguage,\r\n-          bookFile,\r\n-        } = addbook;\r\n-        if (!bookName || !bookDescription || !bookAuthor || !bookCategory || !bookLanguage) {\r\n-          throw new Error(\"All required fields (except files) must be provided.\");\r\n-        }\r\n-        const bookCoverUrl = bookCover ? await uploadToCloudinary(bookCover) : null;\r\n-        const bookFileUrl = bookFile ? await uploadToCloudinary(bookFile) : null;\r\n-        const newBook = await Book.create({\r\n-          bookCover: bookCoverUrl,\r\n-          bookName,\r\n-          bookDescription,\r\n-          bookAuthor,\r\n-          bookCategory,\r\n-          bookLanguage,\r\n-          bookFile: bookFileUrl,\r\n-          // postedBy:req.adminId\r\n-        });\r\n-        console.log(newBook)\r\n-      //   return newBook;\r\n-      } catch (error) {\r\n-        console.error(\"Error adding book:\", error.message);\r\n-        throw new Error(\"Failed to add book. Please try again.\");\r\n-      }\r\n-    }),\r\n-     \r\n-\r\n-    // Update a book\r\n-    updateBook: (applyTokenChecker, async (_, args) => {\r\n-      try {\r\n-        const { bookCover, bookName, bookDescription, bookAuthor, bookCategory, bookLanguage, bookFile } = args.updatebook;\r\n-        const existingBook = await Book.findOne({ where: { id: args.id } });\r\n-        if (!existingBook) {\r\n-          throw new Error('Book not found');\r\n-        }\r\n-        const bookCoverUrl = bookCover ? await uploadToCloudinary(bookCover) : existingBook.bookCover;\r\n-        const bookFileUrl = bookFile ? await uploadToCloudinary(bookFile) : existingBook.bookFile;\r\n-        const [updateCount] = await Book.update(\r\n-          {\r\n-            bookCover: bookCoverUrl || existingBook.bookCover,\r\n-            bookName: bookName || existingBook.bookName,\r\n-            bookDescription: bookDescription || existingBook.bookDescription,\r\n-            bookAuthor: bookAuthor || existingBook.bookAuthor,\r\n-            bookCategory: bookCategory || existingBook.bookCategory,\r\n-            bookLanguage: bookLanguage || existingBook.bookLanguage,\r\n-            bookFile: bookFileUrl || existingBook.bookFile\r\n-          },\r\n-          { where: { id: args.id } }\r\n-        );\r\n-        if (updateCount === 0) {\r\n-          throw new Error('No changes detected');\r\n-        }\r\n-        const updatedBook = await Book.findOne({ where: { id: args.id } });\r\n-        return {success: true, message: `Boook info updated successfully` };\r\n-      } catch (error) {\r\n-        console.error('Error during deleteBook operation:', error.message);\r\n-        return {success: false, message: `Error deleting book: ${error.message}`};\r\n-      }\r\n-    }),\r\n-  \r\n-    \r\n-    deleteBook: (applyTokenChecker, async (_, { id }) => {\r\n-      try {\r\n-        const book = await Book.findByPk(id);\r\n-        if (!book) {\r\n-          throw new Error('Book not found.');\r\n-        }\r\n-     if (book.bookCover) {\r\n-    const coverPublicId = extractPublicId(book.bookCover);\r\n-    if (coverPublicId) {\r\n-      console.log(`Deleting book cover with public ID: ${coverPublicId}`);\r\n-      try {\r\n-        await deleteOldFileFromCloudinary(coverPublicId);\r\n-      } catch (error) {\r\n-        console.error(`Failed to delete book cover: ${error.message}`);\r\n-      }\r\n-    } else {\r\n-      console.warn('No valid public ID found for book cover.');\r\n-        }\r\n-      }\r\n-  if (book.bookFile) {\r\n-    const filePublicId = extractPublicId(book.bookFile);\r\n-    if (filePublicId) {\r\n-      console.log(`Deleting book file with public ID: ${filePublicId}`);\r\n-      try {\r\n-        await deleteOldFileFromCloudinary(filePublicId);\r\n-      } catch (error) {\r\n-        console.error(`Failed to delete book file: ${error.message}`);\r\n-      }\r\n-    } else {\r\n-      console.warn('No valid public ID found for book file.');\r\n-    }\r\n-  }\r\n-        const deleteCount = await Book.destroy({ where: { id } });\r\n-        if (deleteCount === 0) {\r\n-          throw new Error('Failed to delete book from the database.');\r\n-        }\r\n-        return {\r\n-          success: true,\r\n-          message: 'Book and associated files deleted successfully.',\r\n-        };\r\n-      } catch (error) {\r\n-        console.error('Error during deleteBook operation:', error.message);\r\n-        return {\r\n-          success: false,\r\n-          message: `Error deleting book: ${error.message}`,\r\n-        };\r\n-      }\r\n-    }),\r\n-    \r\n-    \r\n-\r\n-    // User signup\r\n-    signup: async (_, args) => {\r\n-      try {\r\n-        const { username, phoneNumber, email, password } = args.signupuser;\r\n-        const hashedPassword = await bcrypt.hash(password, 10);\r\n-        const data = await User.create({\r\n-          username,\r\n-          phoneNumber,\r\n-          email,\r\n-          password: hashedPassword\r\n-        });\r\n-        return data;\r\n-      } catch (error) {\r\n-        throw new Error(error.message);\r\n-      }\r\n-    },\r\n-    \r\n-    login: async (_, args, context) => {\r\n-      const { req } = context;\r\n-      const { username, password } = args.loginuser;\r\n-      try {\r\n-        const user = await User.findOne({ where: { username } });\r\n-        if (!user) {\r\n-         throw new Error('Incorrect username or password'); \r\n-        }\r\n-        const passwordMatch = await bcrypt.compare(password, user.password);   \r\n-              if (!passwordMatch) {\r\n-               throw new Error('Incorrect username or password'); \r\n-              }\r\n-              const token = jwt.sign({ userId: user.id, email:user.email }, process.env.SECRET_STRING, {expiresIn:'5h'})\r\n-              \r\n-            return { role: user.role, userId: user.id, token };\r\n-      } catch (error) {\r\n-        console.error(\"Error logging in:\", error.message);\r\n-        throw new Error(\"Login unsuccessful. Please try again.\");\r\n-      }\r\n-    },\r\n-\r\n-  \r\n-    updateUser: async (_, args) => {\r\n-      try {\r\n-        const existingUser =  User.findOne({where: {}})\r\n-        const { profilePic, fullName, username, phoneNumber, email } = args.updateuser;\r\n-        const profilePicUrl = profilePic ? await uploadToCloudinary(profilePic) : existingUser.profilePic;\r\n-        const [updateCount] = await User.update(\r\n-          {  \r\n-            profilePic: profilePicUrl, \r\n-             fullName: fullName || existingUser.fullName, \r\n-             username: username || existingUser.username, \r\n-             phoneNumber: phoneNumber || existingUser.phoneNumber, \r\n-             email: email || existingUser.email,\r\n-         },\r\n-          { where: { id: args.id } }\r\n-        );\r\n-        if (updateCount === 0) {\r\n-          throw new Error('User not found or nothing to update');\r\n-        }\r\n-        return { success: true, message: `User info updated successfully` };\r\n-      } catch (error) {\r\n-        return { success: false, message: `Error updating user: ${error.message}` };\r\n-      }\r\n-    },\r\n-\r\n-\r\n-    deleteUser: async (_, { id }) => {\r\n-      try {\r\n-        const user = await User.findByPk(id);\r\n-        if (!user) throw new Error(\"User not found\");\r\n-        const del = await User.destroy({ where: { id } });\r\n-        if (!del) throw new Error(\"Deletion not successful\");\r\n-        return { success: true, message: \"User info deleted successfully.\" };\r\n-      } catch (error) {\r\n-        return { success: false, message: `Error deleting user: ${error.message}` };\r\n-      }\r\n-    },\r\n-\r\n-\r\n-  }\r\n-};\r\n-import Book from \"../models/book.js\";\r\n-import User from \"../models/user.js\";\r\n-import bcrypt from \"bcrypt\";\r\n-import { GraphQLUpload } from 'graphql-upload';\r\n-import { Op } from 'sequelize';   \r\n-import jwt from'jsonwebtoken';\r\n-import { applyTokenChecker, uploadToCloudinary, deleteOldFileFromCloudinary, extractPublicId } from \"../config/cloudinary.js\";\r\n-\r\n-\r\n-\r\n-\r\n-export const resolvers = {\r\n-  Upload: GraphQLUpload,\r\n-\r\n-  Query: {\r\n-    books: async (_, { page = 1, perPage = 9 }) => {\r\n-      try {\r\n-          const offset = (page - 1) * perPage;\r\n-          const { rows: allBooks, count: totalBooks } = await Book.findAndCountAll({\r\n-              order: [['createdAt', 'DESC']],\r\n-              limit: perPage,\r\n-          offset: offset,\r\n-          });\r\n-          const lastPage = Math.ceil(totalBooks / perPage);\r\n-        const currentPage = page;\r\n-        const previousPage = currentPage-1;\r\n-        const nextPage = currentPage+1; \r\n-          return {\r\n-              allBooks,\r\n-             currentPage,\r\n-              previousPage,\r\n-              nextPage,\r\n-              lastPage,\r\n-          };\r\n-      } catch (error) {\r\n-          console.error('Error fetching books:', error);\r\n-          throw new Error('Unable to fetch books at the moment');\r\n-      }\r\n-  },\r\n-  \r\n-    book: async (_, args) => {\r\n-      try {\r\n-        const data = await Book.findOne({ where: { id: args.id } });\r\n-        return data;\r\n-      } catch (error) {\r\n-        throw new Error(error.message);\r\n-      }\r\n-    },\r\n-\r\n-    users: (async () => {\r\n-      try {\r\n-        const data = await User.findAll();\r\n-        return data;\r\n-      } catch (error) {\r\n-        throw new Error(error.message);\r\n-      }\r\n-    },\r\n-\r\n-    user: async (_, args) => {\r\n-      try {\r\n-        const data = await User.findOne({ where: { id: args.id } });\r\n-        return data;\r\n-      } catch (error) {\r\n-        throw new Error(error.message);\r\n-      }\r\n-    },\r\n-\r\n-    searchBooks: async (_, { searchTerm }) => {\r\n-      try {\r\n-        const lowerCaseSearchTerm = `%${searchTerm.toLowerCase()}%`; \r\n-        const books = await Book.findAll({\r\n-          where: {\r\n-            [Op.or]: [\r\n-              { bookName: { [Op.like]: lowerCaseSearchTerm } },\r\n-              { bookAuthor: { [Op.like]: lowerCaseSearchTerm } },\r\n-              { bookDescription: { [Op.like]: lowerCaseSearchTerm } }\r\n-            ]\r\n-          }\r\n-        });\r\n-        return books;\r\n-      } catch (error) {\r\n-        throw new Error(\"Error fetching books: \" + error.message);\r\n-      }\r\n-    }\r\n-  },\r\n-\r\n-  Mutation: {\r\n-\r\n-    addBook: (applyTokenChecker, async (_, { addbook }) => {\r\n-      try {\r\n-        const {\r\n-          bookCover,\r\n-          bookName,\r\n-          bookDescription,\r\n-          bookAuthor,\r\n-          bookCategory,\r\n-          bookLanguage,\r\n-          bookFile,\r\n-        } = addbook;\r\n-        if (!bookName || !bookDescription || !bookAuthor || !bookCategory || !bookLanguage) {\r\n-          throw new Error(\"All required fields (except files) must be provided.\");\r\n-        }\r\n-        const bookCoverUrl = bookCover ? await uploadToCloudinary(bookCover) : null;\r\n-        const bookFileUrl = bookFile ? await uploadToCloudinary(bookFile) : null;\r\n-        const newBook = await Book.create({\r\n-          bookCover: bookCoverUrl,\r\n-          bookName,\r\n-          bookDescription,\r\n-          bookAuthor,\r\n-          bookCategory,\r\n-          bookLanguage,\r\n-          bookFile: bookFileUrl,\r\n-          // postedBy:req.adminId\r\n-        });\r\n-        console.log(newBook)\r\n-      //   return newBook;\r\n-      } catch (error) {\r\n-        console.error(\"Error adding book:\", error.message);\r\n-        throw new Error(\"Failed to add book. Please try again.\");\r\n-      }\r\n-    }),\r\n-     \r\n-\r\n-    // Update a book\r\n-    updateBook: (applyTokenChecker, async (_, args) => {\r\n-      try {\r\n-        const { bookCover, bookName, bookDescription, bookAuthor, bookCategory, bookLanguage, bookFile } = args.updatebook;\r\n-        const existingBook = await Book.findOne({ where: { id: args.id } });\r\n-        if (!existingBook) {\r\n-          throw new Error('Book not found');\r\n-        }\r\n-        const bookCoverUrl = bookCover ? await uploadToCloudinary(bookCover) : existingBook.bookCover;\r\n-        const bookFileUrl = bookFile ? await uploadToCloudinary(bookFile) : existingBook.bookFile;\r\n-        const [updateCount] = await Book.update(\r\n-          {\r\n-            bookCover: bookCoverUrl || existingBook.bookCover,\r\n-            bookName: bookName || existingBook.bookName,\r\n-            bookDescription: bookDescription || existingBook.bookDescription,\r\n-            bookAuthor: bookAuthor || existingBook.bookAuthor,\r\n-            bookCategory: bookCategory || existingBook.bookCategory,\r\n-            bookLanguage: bookLanguage || existingBook.bookLanguage,\r\n-            bookFile: bookFileUrl || existingBook.bookFile\r\n-          },\r\n-          { where: { id: args.id } }\r\n-        );\r\n-        if (updateCount === 0) {\r\n-          throw new Error('No changes detected');\r\n-        }\r\n-        const updatedBook = await Book.findOne({ where: { id: args.id } });\r\n-        return {success: true, message: `Boook info updated successfully` };\r\n-      } catch (error) {\r\n-        console.error('Error during deleteBook operation:', error.message);\r\n-        return {success: false, message: `Error deleting book: ${error.message}`};\r\n-      }\r\n-    }),\r\n-  \r\n-    \r\n-    deleteBook: (applyTokenChecker, async (_, { id }) => {\r\n-      try {\r\n-        const book = await Book.findByPk(id);\r\n-        if (!book) {\r\n-          throw new Error('Book not found.');\r\n-        }\r\n-     if (book.bookCover) {\r\n-    const coverPublicId = extractPublicId(book.bookCover);\r\n-    if (coverPublicId) {\r\n-      console.log(`Deleting book cover with public ID: ${coverPublicId}`);\r\n-      try {\r\n-        await deleteOldFileFromCloudinary(coverPublicId);\r\n-      } catch (error) {\r\n-        console.error(`Failed to delete book cover: ${error.message}`);\r\n-      }\r\n-    } else {\r\n-      console.warn('No valid public ID found for book cover.');\r\n-        }\r\n-      }\r\n-  if (book.bookFile) {\r\n-    const filePublicId = extractPublicId(book.bookFile);\r\n-    if (filePublicId) {\r\n-      console.log(`Deleting book file with public ID: ${filePublicId}`);\r\n-      try {\r\n-        await deleteOldFileFromCloudinary(filePublicId);\r\n-      } catch (error) {\r\n-        console.error(`Failed to delete book file: ${error.message}`);\r\n-      }\r\n-    } else {\r\n-      console.warn('No valid public ID found for book file.');\r\n-    }\r\n-  }\r\n-        const deleteCount = await Book.destroy({ where: { id } });\r\n-        if (deleteCount === 0) {\r\n-          throw new Error('Failed to delete book from the database.');\r\n-        }\r\n-        return {\r\n-          success: true,\r\n-          message: 'Book and associated files deleted successfully.',\r\n-        };\r\n-      } catch (error) {\r\n-        console.error('Error during deleteBook operation:', error.message);\r\n-        return {\r\n-          success: false,\r\n-          message: `Error deleting book: ${error.message}`,\r\n-        };\r\n-      }\r\n-    }),\r\n-    \r\n-    \r\n-\r\n-    // User signup\r\n-    signup: async (_, args) => {\r\n-      try {\r\n-        const { username, phoneNumber, email, password } = args.signupuser;\r\n-        const hashedPassword = await bcrypt.hash(password, 10);\r\n-        const data = await User.create({\r\n-          username,\r\n-          phoneNumber,\r\n-          email,\r\n-          password: hashedPassword\r\n-        });\r\n-        return data;\r\n-      } catch (error) {\r\n-        throw new Error(error.message);\r\n-      }\r\n-    },\r\n-    \r\n-    login: async (_, args, context) => {\r\n-      const { req } = context;\r\n-      const { username, password } = args.loginuser;\r\n-      try {\r\n-        const user = await User.findOne({ where: { username } });\r\n-        if (!user) {\r\n-         throw new Error('Incorrect username or password'); \r\n-        }\r\n-        const passwordMatch = await bcrypt.compare(password, user.password);   \r\n-              if (!passwordMatch) {\r\n-               throw new Error('Incorrect username or password'); \r\n-              }\r\n-              const token = jwt.sign({ userId: user.id, email:user.email }, process.env.SECRET_STRING, {expiresIn:'5h'})\r\n-              \r\n-            return { role: user.role, userId: user.id, token };\r\n-      } catch (error) {\r\n-        console.error(\"Error logging in:\", error.message);\r\n-        throw new Error(\"Login unsuccessful. Please try again.\");\r\n-      }\r\n-    },\r\n-\r\n-  \r\n-    updateUser: async (_, args) => {\r\n-      try {\r\n-        const existingUser =  User.findOne({where: {}})\r\n-        const { profilePic, fullName, username, phoneNumber, email } = args.updateuser;\r\n-        const profilePicUrl = profilePic ? await uploadToCloudinary(profilePic) : existingUser.profilePic;\r\n-        const [updateCount] = await User.update(\r\n-          {  \r\n-            profilePic: profilePicUrl, \r\n-             fullName: fullName || existingUser.fullName, \r\n-             username: username || existingUser.username, \r\n-             phoneNumber: phoneNumber || existingUser.phoneNumber, \r\n-             email: email || existingUser.email,\r\n-         },\r\n-          { where: { id: args.id } }\r\n-        );\r\n-        if (updateCount === 0) {\r\n-          throw new Error('User not found or nothing to update');\r\n-        }\r\n-        return { success: true, message: `User info updated successfully` };\r\n-      } catch (error) {\r\n-        return { success: false, message: `Error updating user: ${error.message}` };\r\n-      }\r\n-    },\r\n-\r\n-\r\n-    deleteUser: async (_, { id }) => {\r\n-      try {\r\n-        const user = await User.findByPk(id);\r\n-        if (!user) throw new Error(\"User not found\");\r\n-        const del = await User.destroy({ where: { id } });\r\n-        if (!del) throw new Error(\"Deletion not successful\");\r\n-        return { success: true, message: \"User info deleted successfully.\" };\r\n-      } catch (error) {\r\n-        return { success: false, message: `Error deleting user: ${error.message}` };\r\n-      }\r\n-    },\r\n-\r\n-\r\n-  }\r\n-};\r\n-import Book from \"../models/book.js\";\r\n-import User from \"../models/user.js\";\r\n-import bcrypt from \"bcrypt\";\r\n-import { GraphQLUpload } from 'graphql-upload';\r\n-import { Op } from 'sequelize';   \r\n-import jwt from'jsonwebtoken';\r\n-import { applyTokenChecker, uploadToCloudinary, deleteOldFileFromCloudinary, extractPublicId } from \"../config/cloudinary.js\";\r\n-\r\n-\r\n-\r\n-\r\n-export const resolvers = {\r\n-  Upload: GraphQLUpload,\r\n-\r\n-  Query: {\r\n-    books: async (_, { page = 1, perPage = 9 }) => {\r\n-      try {\r\n-          const offset = (page - 1) * perPage;\r\n-          const { rows: allBooks, count: totalBooks } = await Book.findAndCountAll({\r\n-              order: [['createdAt', 'DESC']],\r\n-              limit: perPage,\r\n-          offset: offset,\r\n-          });\r\n-          const lastPage = Math.ceil(totalBooks / perPage);\r\n-        const currentPage = page;\r\n-        const previousPage = currentPage-1;\r\n-        const nextPage = currentPage+1; \r\n-          return {\r\n-              allBooks,\r\n-             currentPage,\r\n-              previousPage,\r\n-              nextPage,\r\n-              lastPage,\r\n-          };\r\n-      } catch (error) {\r\n-          console.error('Error fetching books:', error);\r\n-          throw new Error('Unable to fetch books at the moment');\r\n-      }\r\n-  },\r\n-  \r\n-    book: async (_, args) => {\r\n-      try {\r\n-        const data = await Book.findOne({ where: { id: args.id } });\r\n-        return data;\r\n-      } catch (error) {\r\n-        throw new Error(error.message);\r\n-      }\r\n-    },\r\n-\r\n-    users: async () => {\r\n-      try {\r\n-        const data = await User.findAll();\r\n-        return data;\r\n-      } catch (error) {\r\n-        throw new Error(error.message);\r\n-      }\r\n-    },\r\n-\r\n-    user: async (_, args) => {\r\n-      try {\r\n-        const data = await User.findOne({ where: { id: args.id } });\r\n-        return data;\r\n-      } catch (error) {\r\n-        throw new Error(error.message);\r\n-      }\r\n-    },\r\n-\r\n-    searchBooks: async (_, { searchTerm }) => {\r\n-      try {\r\n-        const lowerCaseSearchTerm = `%${searchTerm.toLowerCase()}%`; \r\n-        const books = await Book.findAll({\r\n-          where: {\r\n-            [Op.or]: [\r\n-              { bookName: { [Op.like]: lowerCaseSearchTerm } },\r\n-              { bookAuthor: { [Op.like]: lowerCaseSearchTerm } },\r\n-              { bookDescription: { [Op.like]: lowerCaseSearchTerm } }\r\n-            ]\r\n-          }\r\n-        });\r\n-        return books;\r\n-      } catch (error) {\r\n-        throw new Error(\"Error fetching books: \" + error.message);\r\n-      }\r\n-    }\r\n-  },\r\n-\r\n-  Mutation: {\r\n-\r\n-    addBook: (applyTokenChecker, async (_, { addbook }) => {\r\n-      try {\r\n-        const {\r\n-          bookCover,\r\n-          bookName,\r\n-          bookDescription,\r\n-          bookAuthor,\r\n-          bookCategory,\r\n-          bookLanguage,\r\n-          bookFile,\r\n-        } = addbook;\r\n-        if (!bookName || !bookDescription || !bookAuthor || !bookCategory || !bookLanguage) {\r\n-          throw new Error(\"All required fields (except files) must be provided.\");\r\n-        }\r\n-        const bookCoverUrl = bookCover ? await uploadToCloudinary(bookCover) : null;\r\n-        const bookFileUrl = bookFile ? await uploadToCloudinary(bookFile) : null;\r\n-        const newBook = await Book.create({\r\n-          bookCover: bookCoverUrl,\r\n-          bookName,\r\n-          bookDescription,\r\n-          bookAuthor,\r\n-          bookCategory,\r\n-          bookLanguage,\r\n-          bookFile: bookFileUrl,\r\n-          // postedBy:req.adminId\r\n-        });\r\n-        console.log(newBook)\r\n-      //   return newBook;\r\n-      } catch (error) {\r\n-        console.error(\"Error adding book:\", error.message);\r\n-        throw new Error(\"Failed to add book. Please try again.\");\r\n-      }\r\n-    }),\r\n-     \r\n-\r\n-    // Update a book\r\n-    updateBook: (applyTokenChecker, async (_, args) => {\r\n-      try {\r\n-        const { bookCover, bookName, bookDescription, bookAuthor, bookCategory, bookLanguage, bookFile } = args.updatebook;\r\n-        const existingBook = await Book.findOne({ where: { id: args.id } });\r\n-        if (!existingBook) {\r\n-          throw new Error('Book not found');\r\n-        }\r\n-        const bookCoverUrl = bookCover ? await uploadToCloudinary(bookCover) : existingBook.bookCover;\r\n-        const bookFileUrl = bookFile ? await uploadToCloudinary(bookFile) : existingBook.bookFile;\r\n-        const [updateCount] = await Book.update(\r\n-          {\r\n-            bookCover: bookCoverUrl || existingBook.bookCover,\r\n-            bookName: bookName || existingBook.bookName,\r\n-            bookDescription: bookDescription || existingBook.bookDescription,\r\n-            bookAuthor: bookAuthor || existingBook.bookAuthor,\r\n-            bookCategory: bookCategory || existingBook.bookCategory,\r\n-            bookLanguage: bookLanguage || existingBook.bookLanguage,\r\n-            bookFile: bookFileUrl || existingBook.bookFile\r\n-          },\r\n-          { where: { id: args.id } }\r\n-        );\r\n-        if (updateCount === 0) {\r\n-          throw new Error('No changes detected');\r\n-        }\r\n-        const updatedBook = await Book.findOne({ where: { id: args.id } });\r\n-        return {success: true, message: `Boook info updated successfully` };\r\n-      } catch (error) {\r\n-        console.error('Error during deleteBook operation:', error.message);\r\n-        return {success: false, message: `Error deleting book: ${error.message}`};\r\n-      }\r\n-    }),\r\n-  \r\n-    \r\n-    deleteBook: (applyTokenChecker, async (_, { id }) => {\r\n-      try {\r\n-        const book = await Book.findByPk(id);\r\n-        if (!book) {\r\n-          throw new Error('Book not found.');\r\n-        }\r\n-     if (book.bookCover) {\r\n-    const coverPublicId = extractPublicId(book.bookCover);\r\n-    if (coverPublicId) {\r\n-      console.log(`Deleting book cover with public ID: ${coverPublicId}`);\r\n-      try {\r\n-        await deleteOldFileFromCloudinary(coverPublicId);\r\n-      } catch (error) {\r\n-        console.error(`Failed to delete book cover: ${error.message}`);\r\n-      }\r\n-    } else {\r\n-      console.warn('No valid public ID found for book cover.');\r\n-        }\r\n-      }\r\n-  if (book.bookFile) {\r\n-    const filePublicId = extractPublicId(book.bookFile);\r\n-    if (filePublicId) {\r\n-      console.log(`Deleting book file with public ID: ${filePublicId}`);\r\n-      try {\r\n-        await deleteOldFileFromCloudinary(filePublicId);\r\n-      } catch (error) {\r\n-        console.error(`Failed to delete book file: ${error.message}`);\r\n-      }\r\n-    } else {\r\n-      console.warn('No valid public ID found for book file.');\r\n-    }\r\n-  }\r\n-        const deleteCount = await Book.destroy({ where: { id } });\r\n-        if (deleteCount === 0) {\r\n-          throw new Error('Failed to delete book from the database.');\r\n-        }\r\n-        return {\r\n-          success: true,\r\n-          message: 'Book and associated files deleted successfully.',\r\n-        };\r\n-      } catch (error) {\r\n-        console.error('Error during deleteBook operation:', error.message);\r\n-        return {\r\n-          success: false,\r\n-          message: `Error deleting book: ${error.message}`,\r\n-        };\r\n-      }\r\n-    }),\r\n-    \r\n-    \r\n-\r\n-    // User signup\r\n-    signup: async (_, args) => {\r\n-      try {\r\n-        const { username, phoneNumber, email, password } = args.signupuser;\r\n-        const hashedPassword = await bcrypt.hash(password, 10);\r\n-        const data = await User.create({\r\n-          username,\r\n-          phoneNumber,\r\n-          email,\r\n-          password: hashedPassword\r\n-        });\r\n-        return data;\r\n-      } catch (error) {\r\n-        throw new Error(error.message);\r\n-      }\r\n-    },\r\n-    \r\n-    login: async (_, args, context) => {\r\n-      const { req } = context;\r\n-      const { username, password } = args.loginuser;\r\n-      try {\r\n-        const user = await User.findOne({ where: { username } });\r\n-        if (!user) {\r\n-         throw new Error('Incorrect username or password'); \r\n-        }\r\n-        const passwordMatch = await bcrypt.compare(password, user.password);   \r\n-              if (!passwordMatch) {\r\n-               throw new Error('Incorrect username or password'); \r\n-              }\r\n-              const token = jwt.sign({ userId: user.id, email:user.email }, process.env.SECRET_STRING, {expiresIn:'5h'})\r\n-              \r\n-            return { role: user.role, userId: user.id, token };\r\n-      } catch (error) {\r\n-        console.error(\"Error logging in:\", error.message);\r\n-        throw new Error(\"Login unsuccessful. Please try again.\");\r\n-      }\r\n-    },\r\n-\r\n-  \r\n-    updateUser: async (_, args) => {\r\n-      try {\r\n-        const existingUser =  User.findOne({where: {}})\r\n-        const { profilePic, fullName, username, phoneNumber, email } = args.updateuser;\r\n-        const profilePicUrl = profilePic ? await uploadToCloudinary(profilePic) : existingUser.profilePic;\r\n-        const [updateCount] = await User.update(\r\n-          {  \r\n-            profilePic: profilePicUrl, \r\n-             fullName: fullName || existingUser.fullName, \r\n-             username: username || existingUser.username, \r\n-             phoneNumber: phoneNumber || existingUser.phoneNumber, \r\n-             email: email || existingUser.email,\r\n-         },\r\n-          { where: { id: args.id } }\r\n-        );\r\n-        if (updateCount === 0) {\r\n-          throw new Error('User not found or nothing to update');\r\n-        }\r\n-        return { success: true, message: `User info updated successfully` };\r\n-      } catch (error) {\r\n-        return { success: false, message: `Error updating user: ${error.message}` };\r\n-      }\r\n-    },\r\n-\r\n-\r\n-    deleteUser: async (_, { id }) => {\r\n-      try {\r\n-        const user = await User.findByPk(id);\r\n-        if (!user) throw new Error(\"User not found\");\r\n-        const del = await User.destroy({ where: { id } });\r\n-        if (!del) throw new Error(\"Deletion not successful\");\r\n-        return { success: true, message: \"User info deleted successfully.\" };\r\n-      } catch (error) {\r\n-        return { success: false, message: `Error deleting user: ${error.message}` };\r\n-      }\r\n-    },\r\n-\r\n-\r\n-  }\r\n-};\r\n"
                },
                {
                    "date": 1736578113322,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -244,9 +244,9 @@\n       }\r\n     },\r\n \r\n   \r\n-    updateUser: (async (_, args) => {\r\n+    updateUser: ( applyTokenChecker, async (_, args) => {\r\n       try {\r\n         const existingUser =  User.findOne({where: {}})\r\n         const { profilePic, fullName, username, phoneNumber, email } = args.updateuser;\r\n         const profilePicUrl = profilePic ? await uploadToCloudinary(profilePic) : existingUser.profilePic;\r\n@@ -266,9 +266,9 @@\n         return { success: true, message: `User info updated successfully` };\r\n       } catch (error) {\r\n         return { success: false, message: `Error updating user: ${error.message}` };\r\n       }\r\n-    },\r\n+    }),\r\n \r\n \r\n     deleteUser: async (_, { id }) => {\r\n       try {\r\n"
                },
                {
                    "date": 1736578120451,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -283,5 +283,5 @@\n     },\r\n \r\n \r\n   }\r\n-};\n\\ No newline at end of file\n+};\r\n"
                },
                {
                    "date": 1736578130627,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,287 @@\n+import Book from \"../models/book.js\";\r\n+import User from \"../models/user.js\";\r\n+import bcrypt from \"bcrypt\";\r\n+import { GraphQLUpload } from 'graphql-upload';\r\n+import { Op } from 'sequelize';   \r\n+import jwt from'jsonwebtoken';\r\n+import { applyTokenChecker, uploadToCloudinary, deleteOldFileFromCloudinary, extractPublicId } from \"../config/cloudinary.js\";\r\n+\r\n+\r\n+\r\n+\r\n+export const resolvers = {\r\n+  Upload: GraphQLUpload,\r\n+\r\n+  Query: {\r\n+    books: async (_, { page = 1, perPage = 9 }) => {\r\n+      try {\r\n+          const offset = (page - 1) * perPage;\r\n+          const { rows: allBooks, count: totalBooks } = await Book.findAndCountAll({\r\n+              order: [['createdAt', 'DESC']],\r\n+              limit: perPage,\r\n+          offset: offset,\r\n+          });\r\n+          const lastPage = Math.ceil(totalBooks / perPage);\r\n+        const currentPage = page;\r\n+        const previousPage = currentPage-1;\r\n+        const nextPage = currentPage+1; \r\n+          return {\r\n+              allBooks,\r\n+             currentPage,\r\n+              previousPage,\r\n+              nextPage,\r\n+              lastPage,\r\n+          };\r\n+      } catch (error) {\r\n+          console.error('Error fetching books:', error);\r\n+          throw new Error('Unable to fetch books at the moment');\r\n+      }\r\n+  },\r\n+  \r\n+    book: async (_, args) => {\r\n+      try {\r\n+        const data = await Book.findOne({ where: { id: args.id } });\r\n+        return data;\r\n+      } catch (error) {\r\n+        throw new Error(error.message);\r\n+      }\r\n+    },\r\n+\r\n+    users: (applyTokenChecker, async () => {\r\n+      try {\r\n+        const data = await User.findAll();\r\n+        return data;\r\n+      } catch (error) {\r\n+        throw new Error(error.message);\r\n+      }\r\n+    }),\r\n+\r\n+    user:(applyTokenChecker, async (_, args) => {\r\n+      try {\r\n+        const data = await User.findOne({ where: { id: args.id } });\r\n+        return data;\r\n+      } catch (error) {\r\n+        throw new Error(error.message);\r\n+      }\r\n+    }),\r\n+\r\n+    searchBooks: async (_, { searchTerm }) => {\r\n+      try {\r\n+        const lowerCaseSearchTerm = `%${searchTerm.toLowerCase()}%`; \r\n+        const books = await Book.findAll({\r\n+          where: {\r\n+            [Op.or]: [\r\n+              { bookName: { [Op.like]: lowerCaseSearchTerm } },\r\n+              { bookAuthor: { [Op.like]: lowerCaseSearchTerm } },\r\n+              { bookDescription: { [Op.like]: lowerCaseSearchTerm } }\r\n+            ]\r\n+          }\r\n+        });\r\n+        return books;\r\n+      } catch (error) {\r\n+        throw new Error(\"Error fetching books: \" + error.message);\r\n+      }\r\n+    }\r\n+  },\r\n+\r\n+  Mutation: {\r\n+\r\n+    addBook: (applyTokenChecker, async (_, { addbook }) => {\r\n+      try {\r\n+        const {\r\n+          bookCover,\r\n+          bookName,\r\n+          bookDescription,\r\n+          bookAuthor,\r\n+          bookCategory,\r\n+          bookLanguage,\r\n+          bookFile,\r\n+        } = addbook;\r\n+        if (!bookName || !bookDescription || !bookAuthor || !bookCategory || !bookLanguage) {\r\n+          throw new Error(\"All required fields (except files) must be provided.\");\r\n+        }\r\n+        const bookCoverUrl = bookCover ? await uploadToCloudinary(bookCover) : null;\r\n+        const bookFileUrl = bookFile ? await uploadToCloudinary(bookFile) : null;\r\n+        const newBook = await Book.create({\r\n+          bookCover: bookCoverUrl,\r\n+          bookName,\r\n+          bookDescription,\r\n+          bookAuthor,\r\n+          bookCategory,\r\n+          bookLanguage,\r\n+          bookFile: bookFileUrl,\r\n+          // postedBy:req.adminId\r\n+        });\r\n+        console.log(newBook)\r\n+      //   return newBook;\r\n+      } catch (error) {\r\n+        console.error(\"Error adding book:\", error.message);\r\n+        throw new Error(\"Failed to add book. Please try again.\");\r\n+      }\r\n+    }),\r\n+     \r\n+\r\n+    // Update a book\r\n+    updateBook: (applyTokenChecker, async (_, args) => {\r\n+      try {\r\n+        const { bookCover, bookName, bookDescription, bookAuthor, bookCategory, bookLanguage, bookFile } = args.updatebook;\r\n+        const existingBook = await Book.findOne({ where: { id: args.id } });\r\n+        if (!existingBook) {\r\n+          throw new Error('Book not found');\r\n+        }\r\n+        const bookCoverUrl = bookCover ? await uploadToCloudinary(bookCover) : existingBook.bookCover;\r\n+        const bookFileUrl = bookFile ? await uploadToCloudinary(bookFile) : existingBook.bookFile;\r\n+        const [updateCount] = await Book.update(\r\n+          {\r\n+            bookCover: bookCoverUrl || existingBook.bookCover,\r\n+            bookName: bookName || existingBook.bookName,\r\n+            bookDescription: bookDescription || existingBook.bookDescription,\r\n+            bookAuthor: bookAuthor || existingBook.bookAuthor,\r\n+            bookCategory: bookCategory || existingBook.bookCategory,\r\n+            bookLanguage: bookLanguage || existingBook.bookLanguage,\r\n+            bookFile: bookFileUrl || existingBook.bookFile\r\n+          },\r\n+          { where: { id: args.id } }\r\n+        );\r\n+        if (updateCount === 0) {\r\n+          throw new Error('No changes detected');\r\n+        }\r\n+        const updatedBook = await Book.findOne({ where: { id: args.id } });\r\n+        return {success: true, message: `Boook info updated successfully` };\r\n+      } catch (error) {\r\n+        console.error('Error during deleteBook operation:', error.message);\r\n+        return {success: false, message: `Error deleting book: ${error.message}`};\r\n+      }\r\n+    }),\r\n+  \r\n+    \r\n+    deleteBook: (applyTokenChecker, async (_, { id }) => {\r\n+      try {\r\n+        const book = await Book.findByPk(id);\r\n+        if (!book) {\r\n+          throw new Error('Book not found.');\r\n+        }\r\n+     if (book.bookCover) {\r\n+    const coverPublicId = extractPublicId(book.bookCover);\r\n+    if (coverPublicId) {\r\n+      console.log(`Deleting book cover with public ID: ${coverPublicId}`);\r\n+      try {\r\n+        await deleteOldFileFromCloudinary(coverPublicId);\r\n+      } catch (error) {\r\n+        console.error(`Failed to delete book cover: ${error.message}`);\r\n+      }\r\n+    } else {\r\n+      console.warn('No valid public ID found for book cover.');\r\n+        }\r\n+      }\r\n+  if (book.bookFile) {\r\n+    const filePublicId = extractPublicId(book.bookFile);\r\n+    if (filePublicId) {\r\n+      console.log(`Deleting book file with public ID: ${filePublicId}`);\r\n+      try {\r\n+        await deleteOldFileFromCloudinary(filePublicId);\r\n+      } catch (error) {\r\n+        console.error(`Failed to delete book file: ${error.message}`);\r\n+      }\r\n+    } else {\r\n+      console.warn('No valid public ID found for book file.');\r\n+    }\r\n+  }\r\n+        const deleteCount = await Book.destroy({ where: { id } });\r\n+        if (deleteCount === 0) {\r\n+          throw new Error('Failed to delete book from the database.');\r\n+        }\r\n+        return {\r\n+          success: true,\r\n+          message: 'Book and associated files deleted successfully.',\r\n+        };\r\n+      } catch (error) {\r\n+        console.error('Error during deleteBook operation:', error.message);\r\n+        return {\r\n+          success: false,\r\n+          message: `Error deleting book: ${error.message}`,\r\n+        };\r\n+      }\r\n+    }),\r\n+    \r\n+    \r\n+\r\n+    // User signup\r\n+    signup: async (_, args) => {\r\n+      try {\r\n+        const { username, phoneNumber, email, password } = args.signupuser;\r\n+        const hashedPassword = await bcrypt.hash(password, 10);\r\n+        const data = await User.create({\r\n+          username,\r\n+          phoneNumber,\r\n+          email,\r\n+          password: hashedPassword\r\n+        });\r\n+        return data;\r\n+      } catch (error) {\r\n+        throw new Error(error.message);\r\n+      }\r\n+    },\r\n+    \r\n+    login: async (_, args, context) => {\r\n+      const { req } = context;\r\n+      const { username, password } = args.loginuser;\r\n+      try {\r\n+        const user = await User.findOne({ where: { username } });\r\n+        if (!user) {\r\n+         throw new Error('Incorrect username or password'); \r\n+        }\r\n+        const passwordMatch = await bcrypt.compare(password, user.password);   \r\n+              if (!passwordMatch) {\r\n+               throw new Error('Incorrect username or password'); \r\n+              }\r\n+              const token = jwt.sign({ userId: user.id, email:user.email }, process.env.SECRET_STRING, {expiresIn:'5h'})\r\n+              \r\n+            return { role: user.role, userId: user.id, token };\r\n+      } catch (error) {\r\n+        console.error(\"Error logging in:\", error.message);\r\n+        throw new Error(\"Login unsuccessful. Please try again.\");\r\n+      }\r\n+    },\r\n+\r\n+  \r\n+    updateUser: ( applyTokenChecker, async (_, args) => {\r\n+      try {\r\n+        const existingUser =  User.findOne({where: {}})\r\n+        const { profilePic, fullName, username, phoneNumber, email } = args.updateuser;\r\n+        const profilePicUrl = profilePic ? await uploadToCloudinary(profilePic) : existingUser.profilePic;\r\n+        const [updateCount] = await User.update(\r\n+          {  \r\n+            profilePic: profilePicUrl, \r\n+             fullName: fullName || existingUser.fullName, \r\n+             username: username || existingUser.username, \r\n+             phoneNumber: phoneNumber || existingUser.phoneNumber, \r\n+             email: email || existingUser.email,\r\n+         },\r\n+          { where: { id: args.id } }\r\n+        );\r\n+        if (updateCount === 0) {\r\n+          throw new Error('User not found or nothing to update');\r\n+        }\r\n+        return { success: true, message: `User info updated successfully` };\r\n+      } catch (error) {\r\n+        return { success: false, message: `Error updating user: ${error.message}` };\r\n+      }\r\n+    }),\r\n+\r\n+\r\n+    deleteUser:(applyTokenChecker,async (_, { id }) => {\r\n+      try {\r\n+        const user = await User.findByPk(id);\r\n+        if (!user) throw new Error(\"User not found\");\r\n+        const del = await User.destroy({ where: { id } });\r\n+        if (!del) throw new Error(\"Deletion not successful\");\r\n+        return { success: true, message: \"User info deleted successfully.\" };\r\n+      } catch (error) {\r\n+        return { success: false, message: `Error deleting user: ${error.message}` };\r\n+      }\r\n+    },\r\n+\r\n+\r\n+  }\r\n+}) ;\r\n"
                },
                {
                    "date": 1736578141633,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,287 @@\n+import Book from \"../models/book.js\";\r\n+import User from \"../models/user.js\";\r\n+import bcrypt from \"bcrypt\";\r\n+import { GraphQLUpload } from 'graphql-upload';\r\n+import { Op } from 'sequelize';   \r\n+import jwt from'jsonwebtoken';\r\n+import { applyTokenChecker, uploadToCloudinary, deleteOldFileFromCloudinary, extractPublicId } from \"../config/cloudinary.js\";\r\n+\r\n+\r\n+\r\n+\r\n+export const resolvers = {\r\n+  Upload: GraphQLUpload,\r\n+\r\n+  Query: {\r\n+    books: async (_, { page = 1, perPage = 9 }) => {\r\n+      try {\r\n+          const offset = (page - 1) * perPage;\r\n+          const { rows: allBooks, count: totalBooks } = await Book.findAndCountAll({\r\n+              order: [['createdAt', 'DESC']],\r\n+              limit: perPage,\r\n+          offset: offset,\r\n+          });\r\n+          const lastPage = Math.ceil(totalBooks / perPage);\r\n+        const currentPage = page;\r\n+        const previousPage = currentPage-1;\r\n+        const nextPage = currentPage+1; \r\n+          return {\r\n+              allBooks,\r\n+             currentPage,\r\n+              previousPage,\r\n+              nextPage,\r\n+              lastPage,\r\n+          };\r\n+      } catch (error) {\r\n+          console.error('Error fetching books:', error);\r\n+          throw new Error('Unable to fetch books at the moment');\r\n+      }\r\n+  },\r\n+  \r\n+    book: async (_, args) => {\r\n+      try {\r\n+        const data = await Book.findOne({ where: { id: args.id } });\r\n+        return data;\r\n+      } catch (error) {\r\n+        throw new Error(error.message);\r\n+      }\r\n+    },\r\n+\r\n+    users: (applyTokenChecker, async () => {\r\n+      try {\r\n+        const data = await User.findAll();\r\n+        return data;\r\n+      } catch (error) {\r\n+        throw new Error(error.message);\r\n+      }\r\n+    }),\r\n+\r\n+    user:(applyTokenChecker, async (_, args) => {\r\n+      try {\r\n+        const data = await User.findOne({ where: { id: args.id } });\r\n+        return data;\r\n+      } catch (error) {\r\n+        throw new Error(error.message);\r\n+      }\r\n+    }),\r\n+\r\n+    searchBooks: async (_, { searchTerm }) => {\r\n+      try {\r\n+        const lowerCaseSearchTerm = `%${searchTerm.toLowerCase()}%`; \r\n+        const books = await Book.findAll({\r\n+          where: {\r\n+            [Op.or]: [\r\n+              { bookName: { [Op.like]: lowerCaseSearchTerm } },\r\n+              { bookAuthor: { [Op.like]: lowerCaseSearchTerm } },\r\n+              { bookDescription: { [Op.like]: lowerCaseSearchTerm } }\r\n+            ]\r\n+          }\r\n+        });\r\n+        return books;\r\n+      } catch (error) {\r\n+        throw new Error(\"Error fetching books: \" + error.message);\r\n+      }\r\n+    }\r\n+  },\r\n+\r\n+  Mutation: {\r\n+\r\n+    addBook: (applyTokenChecker, async (_, { addbook }) => {\r\n+      try {\r\n+        const {\r\n+          bookCover,\r\n+          bookName,\r\n+          bookDescription,\r\n+          bookAuthor,\r\n+          bookCategory,\r\n+          bookLanguage,\r\n+          bookFile,\r\n+        } = addbook;\r\n+        if (!bookName || !bookDescription || !bookAuthor || !bookCategory || !bookLanguage) {\r\n+          throw new Error(\"All required fields (except files) must be provided.\");\r\n+        }\r\n+        const bookCoverUrl = bookCover ? await uploadToCloudinary(bookCover) : null;\r\n+        const bookFileUrl = bookFile ? await uploadToCloudinary(bookFile) : null;\r\n+        const newBook = await Book.create({\r\n+          bookCover: bookCoverUrl,\r\n+          bookName,\r\n+          bookDescription,\r\n+          bookAuthor,\r\n+          bookCategory,\r\n+          bookLanguage,\r\n+          bookFile: bookFileUrl,\r\n+          // postedBy:req.adminId\r\n+        });\r\n+        console.log(newBook)\r\n+      //   return newBook;\r\n+      } catch (error) {\r\n+        console.error(\"Error adding book:\", error.message);\r\n+        throw new Error(\"Failed to add book. Please try again.\");\r\n+      }\r\n+    }),\r\n+     \r\n+\r\n+    // Update a book\r\n+    updateBook: (applyTokenChecker, async (_, args) => {\r\n+      try {\r\n+        const { bookCover, bookName, bookDescription, bookAuthor, bookCategory, bookLanguage, bookFile } = args.updatebook;\r\n+        const existingBook = await Book.findOne({ where: { id: args.id } });\r\n+        if (!existingBook) {\r\n+          throw new Error('Book not found');\r\n+        }\r\n+        const bookCoverUrl = bookCover ? await uploadToCloudinary(bookCover) : existingBook.bookCover;\r\n+        const bookFileUrl = bookFile ? await uploadToCloudinary(bookFile) : existingBook.bookFile;\r\n+        const [updateCount] = await Book.update(\r\n+          {\r\n+            bookCover: bookCoverUrl || existingBook.bookCover,\r\n+            bookName: bookName || existingBook.bookName,\r\n+            bookDescription: bookDescription || existingBook.bookDescription,\r\n+            bookAuthor: bookAuthor || existingBook.bookAuthor,\r\n+            bookCategory: bookCategory || existingBook.bookCategory,\r\n+            bookLanguage: bookLanguage || existingBook.bookLanguage,\r\n+            bookFile: bookFileUrl || existingBook.bookFile\r\n+          },\r\n+          { where: { id: args.id } }\r\n+        );\r\n+        if (updateCount === 0) {\r\n+          throw new Error('No changes detected');\r\n+        }\r\n+        const updatedBook = await Book.findOne({ where: { id: args.id } });\r\n+        return {success: true, message: `Boook info updated successfully` };\r\n+      } catch (error) {\r\n+        console.error('Error during deleteBook operation:', error.message);\r\n+        return {success: false, message: `Error deleting book: ${error.message}`};\r\n+      }\r\n+    }),\r\n+  \r\n+    \r\n+    deleteBook: (applyTokenChecker, async (_, { id }) => {\r\n+      try {\r\n+        const book = await Book.findByPk(id);\r\n+        if (!book) {\r\n+          throw new Error('Book not found.');\r\n+        }\r\n+     if (book.bookCover) {\r\n+    const coverPublicId = extractPublicId(book.bookCover);\r\n+    if (coverPublicId) {\r\n+      console.log(`Deleting book cover with public ID: ${coverPublicId}`);\r\n+      try {\r\n+        await deleteOldFileFromCloudinary(coverPublicId);\r\n+      } catch (error) {\r\n+        console.error(`Failed to delete book cover: ${error.message}`);\r\n+      }\r\n+    } else {\r\n+      console.warn('No valid public ID found for book cover.');\r\n+        }\r\n+      }\r\n+  if (book.bookFile) {\r\n+    const filePublicId = extractPublicId(book.bookFile);\r\n+    if (filePublicId) {\r\n+      console.log(`Deleting book file with public ID: ${filePublicId}`);\r\n+      try {\r\n+        await deleteOldFileFromCloudinary(filePublicId);\r\n+      } catch (error) {\r\n+        console.error(`Failed to delete book file: ${error.message}`);\r\n+      }\r\n+    } else {\r\n+      console.warn('No valid public ID found for book file.');\r\n+    }\r\n+  }\r\n+        const deleteCount = await Book.destroy({ where: { id } });\r\n+        if (deleteCount === 0) {\r\n+          throw new Error('Failed to delete book from the database.');\r\n+        }\r\n+        return {\r\n+          success: true,\r\n+          message: 'Book and associated files deleted successfully.',\r\n+        };\r\n+      } catch (error) {\r\n+        console.error('Error during deleteBook operation:', error.message);\r\n+        return {\r\n+          success: false,\r\n+          message: `Error deleting book: ${error.message}`,\r\n+        };\r\n+      }\r\n+    }),\r\n+    \r\n+    \r\n+\r\n+    // User signup\r\n+    signup: async (_, args) => {\r\n+      try {\r\n+        const { username, phoneNumber, email, password } = args.signupuser;\r\n+        const hashedPassword = await bcrypt.hash(password, 10);\r\n+        const data = await User.create({\r\n+          username,\r\n+          phoneNumber,\r\n+          email,\r\n+          password: hashedPassword\r\n+        });\r\n+        return data;\r\n+      } catch (error) {\r\n+        throw new Error(error.message);\r\n+      }\r\n+    },\r\n+    \r\n+    login: async (_, args, context) => {\r\n+      const { req } = context;\r\n+      const { username, password } = args.loginuser;\r\n+      try {\r\n+        const user = await User.findOne({ where: { username } });\r\n+        if (!user) {\r\n+         throw new Error('Incorrect username or password'); \r\n+        }\r\n+        const passwordMatch = await bcrypt.compare(password, user.password);   \r\n+              if (!passwordMatch) {\r\n+               throw new Error('Incorrect username or password'); \r\n+              }\r\n+              const token = jwt.sign({ userId: user.id, email:user.email }, process.env.SECRET_STRING, {expiresIn:'5h'})\r\n+              \r\n+            return { role: user.role, userId: user.id, token };\r\n+      } catch (error) {\r\n+        console.error(\"Error logging in:\", error.message);\r\n+        throw new Error(\"Login unsuccessful. Please try again.\");\r\n+      }\r\n+    },\r\n+\r\n+  \r\n+    updateUser: ( applyTokenChecker, async (_, args) => {\r\n+      try {\r\n+        const existingUser =  User.findOne({where: {}})\r\n+        const { profilePic, fullName, username, phoneNumber, email } = args.updateuser;\r\n+        const profilePicUrl = profilePic ? await uploadToCloudinary(profilePic) : existingUser.profilePic;\r\n+        const [updateCount] = await User.update(\r\n+          {  \r\n+            profilePic: profilePicUrl, \r\n+             fullName: fullName || existingUser.fullName, \r\n+             username: username || existingUser.username, \r\n+             phoneNumber: phoneNumber || existingUser.phoneNumber, \r\n+             email: email || existingUser.email,\r\n+         },\r\n+          { where: { id: args.id } }\r\n+        );\r\n+        if (updateCount === 0) {\r\n+          throw new Error('User not found or nothing to update');\r\n+        }\r\n+        return { success: true, message: `User info updated successfully` };\r\n+      } catch (error) {\r\n+        return { success: false, message: `Error updating user: ${error.message}` };\r\n+      }\r\n+    }),\r\n+\r\n+\r\n+    deleteUser:(applyTokenChecker, async (_, { id }) => {\r\n+      try {\r\n+        const user = await User.findByPk(id);\r\n+        if (!user) throw new Error(\"User not found\");\r\n+        const del = await User.destroy({ where: { id } });\r\n+        if (!del) throw new Error(\"Deletion not successful\");\r\n+        return { success: true, message: \"User info deleted successfully.\" };\r\n+      } catch (error) {\r\n+        return { success: false, message: `Error deleting user: ${error.message}` };\r\n+      }\r\n+    }),\r\n+\r\n+\r\n+  }\r\n+};\r\n"
                }
            ],
            "date": 1736577786099,
            "name": "Commit-0",
            "content": "import Book from \"../models/book.js\";\r\nimport User from \"../models/user.js\";\r\nimport bcrypt from \"bcrypt\";\r\nimport { GraphQLUpload } from 'graphql-upload';\r\nimport { Op } from 'sequelize';   \r\nimport jwt from'jsonwebtoken';\r\nimport { applyTokenChecker, uploadToCloudinary, deleteOldFileFromCloudinary, extractPublicId } from \"../config/cloudinary.js\";\r\n\r\n\r\n\r\n\r\nexport const resolvers = {\r\n  Upload: GraphQLUpload,\r\n\r\n  Query: {\r\n    books: async (_, { page = 1, perPage = 9 }) => {\r\n      try {\r\n          const offset = (page - 1) * perPage;\r\n          const { rows: allBooks, count: totalBooks } = await Book.findAndCountAll({\r\n              order: [['createdAt', 'DESC']],\r\n              limit: perPage,\r\n          offset: offset,\r\n          });\r\n          const lastPage = Math.ceil(totalBooks / perPage);\r\n        const currentPage = page;\r\n        const previousPage = currentPage-1;\r\n        const nextPage = currentPage+1; \r\n          return {\r\n              allBooks,\r\n             currentPage,\r\n              previousPage,\r\n              nextPage,\r\n              lastPage,\r\n          };\r\n      } catch (error) {\r\n          console.error('Error fetching books:', error);\r\n          throw new Error('Unable to fetch books at the moment');\r\n      }\r\n  },\r\n  \r\n    book: async (_, args) => {\r\n      try {\r\n        const data = await Book.findOne({ where: { id: args.id } });\r\n        return data;\r\n      } catch (error) {\r\n        throw new Error(error.message);\r\n      }\r\n    },\r\n\r\n    users: async () => {\r\n      try {\r\n        const data = await User.findAll();\r\n        return data;\r\n      } catch (error) {\r\n        throw new Error(error.message);\r\n      }\r\n    },\r\n\r\n    user: async (_, args) => {\r\n      try {\r\n        const data = await User.findOne({ where: { id: args.id } });\r\n        return data;\r\n      } catch (error) {\r\n        throw new Error(error.message);\r\n      }\r\n    },\r\n\r\n    searchBooks: async (_, { searchTerm }) => {\r\n      try {\r\n        const lowerCaseSearchTerm = `%${searchTerm.toLowerCase()}%`; \r\n        const books = await Book.findAll({\r\n          where: {\r\n            [Op.or]: [\r\n              { bookName: { [Op.like]: lowerCaseSearchTerm } },\r\n              { bookAuthor: { [Op.like]: lowerCaseSearchTerm } },\r\n              { bookDescription: { [Op.like]: lowerCaseSearchTerm } }\r\n            ]\r\n          }\r\n        });\r\n        return books;\r\n      } catch (error) {\r\n        throw new Error(\"Error fetching books: \" + error.message);\r\n      }\r\n    }\r\n  },\r\n\r\n  Mutation: {\r\n\r\n    addBook: async (_,  { addbook }) => {\r\n      try {\r\n        const {\r\n          bookCover,\r\n          bookName,\r\n          bookDescription,\r\n          bookAuthor,\r\n          bookCategory,\r\n          bookLanguage,\r\n          bookFile,\r\n        } = addbook;\r\n        if (!bookName || !bookDescription || !bookAuthor || !bookCategory || !bookLanguage) {\r\n          throw new Error(\"All required fields (except files) must be provided.\");\r\n        }\r\n        const bookCoverUrl = bookCover ? await uploadToCloudinary(bookCover) : null;\r\n        const bookFileUrl = bookFile ? await uploadToCloudinary(bookFile) : null;\r\n        const newBook = await Book.create({\r\n          bookCover: bookCoverUrl,\r\n          bookName,\r\n          bookDescription,\r\n          bookAuthor,\r\n          bookCategory,\r\n          bookLanguage,\r\n          bookFile: bookFileUrl,\r\n          // postedBy:req.adminId\r\n        });\r\n        console.log(newBook)\r\n      //   return newBook;\r\n      } catch (error) {\r\n        console.error(\"Error adding book:\", error.message);\r\n        throw new Error(\"Failed to add book. Please try again.\");\r\n      }\r\n    },\r\n     \r\n\r\n    // Update a book\r\n    updateBook: async (_, args) => {\r\n      try {\r\n        const { bookCover, bookName, bookDescription, bookAuthor, bookCategory, bookLanguage, bookFile } = args.updatebook;\r\n        const existingBook = await Book.findOne({ where: { id: args.id } });\r\n        if (!existingBook) {\r\n          throw new Error('Book not found');\r\n        }\r\n        const bookCoverUrl = bookCover ? await uploadToCloudinary(bookCover) : existingBook.bookCover;\r\n        const bookFileUrl = bookFile ? await uploadToCloudinary(bookFile) : existingBook.bookFile;\r\n        const [updateCount] = await Book.update(\r\n          {\r\n            bookCover: bookCoverUrl || existingBook.bookCover,\r\n            bookName: bookName || existingBook.bookName,\r\n            bookDescription: bookDescription || existingBook.bookDescription,\r\n            bookAuthor: bookAuthor || existingBook.bookAuthor,\r\n            bookCategory: bookCategory || existingBook.bookCategory,\r\n            bookLanguage: bookLanguage || existingBook.bookLanguage,\r\n            bookFile: bookFileUrl || existingBook.bookFile\r\n          },\r\n          { where: { id: args.id } }\r\n        );\r\n        if (updateCount === 0) {\r\n          throw new Error('No changes detected');\r\n        }\r\n        const updatedBook = await Book.findOne({ where: { id: args.id } });\r\n        return {success: true, message: `Boook info updated successfully` };\r\n      } catch (error) {\r\n        console.error('Error during deleteBook operation:', error.message);\r\n        return {success: false, message: `Error deleting book: ${error.message}`};\r\n      }\r\n    },\r\n  \r\n    \r\n    deleteBook: async (_, { id }) => {\r\n      try {\r\n        const book = await Book.findByPk(id);\r\n        if (!book) {\r\n          throw new Error('Book not found.');\r\n        }\r\n     if (book.bookCover) {\r\n    const coverPublicId = extractPublicId(book.bookCover);\r\n    if (coverPublicId) {\r\n      console.log(`Deleting book cover with public ID: ${coverPublicId}`);\r\n      try {\r\n        await deleteOldFileFromCloudinary(coverPublicId);\r\n      } catch (error) {\r\n        console.error(`Failed to delete book cover: ${error.message}`);\r\n      }\r\n    } else {\r\n      console.warn('No valid public ID found for book cover.');\r\n        }\r\n      }\r\n  if (book.bookFile) {\r\n    const filePublicId = extractPublicId(book.bookFile);\r\n    if (filePublicId) {\r\n      console.log(`Deleting book file with public ID: ${filePublicId}`);\r\n      try {\r\n        await deleteOldFileFromCloudinary(filePublicId);\r\n      } catch (error) {\r\n        console.error(`Failed to delete book file: ${error.message}`);\r\n      }\r\n    } else {\r\n      console.warn('No valid public ID found for book file.');\r\n    }\r\n  }\r\n        const deleteCount = await Book.destroy({ where: { id } });\r\n        if (deleteCount === 0) {\r\n          throw new Error('Failed to delete book from the database.');\r\n        }\r\n        return {\r\n          success: true,\r\n          message: 'Book and associated files deleted successfully.',\r\n        };\r\n      } catch (error) {\r\n        console.error('Error during deleteBook operation:', error.message);\r\n        return {\r\n          success: false,\r\n          message: `Error deleting book: ${error.message}`,\r\n        };\r\n      }\r\n    },\r\n    \r\n    \r\n\r\n    // User signup\r\n    signup: async (_, args) => {\r\n      try {\r\n        const { username, phoneNumber, email, password } = args.signupuser;\r\n        const hashedPassword = await bcrypt.hash(password, 10);\r\n        const data = await User.create({\r\n          username,\r\n          phoneNumber,\r\n          email,\r\n          password: hashedPassword\r\n        });\r\n        return data;\r\n      } catch (error) {\r\n        throw new Error(error.message);\r\n      }\r\n    },\r\n    \r\n    login: async (_, args, context) => {\r\n      const { req } = context;\r\n      const { username, password } = args.loginuser;\r\n      try {\r\n        const user = await User.findOne({ where: { username } });\r\n        if (!user) {\r\n         throw new Error('Incorrect username or password'); \r\n        }\r\n        const passwordMatch = await bcrypt.compare(password, user.password);   \r\n              if (!passwordMatch) {\r\n               throw new Error('Incorrect username or password'); \r\n              }\r\n              const token = jwt.sign({ userId: user.id, email:user.email }, process.env.SECRET_STRING, {expiresIn:'5h'})\r\n              \r\n            return { role: user.role, userId: user.id, token };\r\n      } catch (error) {\r\n        console.error(\"Error logging in:\", error.message);\r\n        throw new Error(\"Login unsuccessful. Please try again.\");\r\n      }\r\n    },\r\n\r\n  \r\n    updateUser: async (_, args) => {\r\n      try {\r\n        const existingUser =  User.findOne({where: {}})\r\n        const { profilePic, fullName, username, phoneNumber, email } = args.updateuser;\r\n        const profilePicUrl = profilePic ? await uploadToCloudinary(profilePic) : existingUser.profilePic;\r\n        const [updateCount] = await User.update(\r\n          {  \r\n            profilePic: profilePicUrl, \r\n             fullName: fullName || existingUser.fullName, \r\n             username: username || existingUser.username, \r\n             phoneNumber: phoneNumber || existingUser.phoneNumber, \r\n             email: email || existingUser.email,\r\n         },\r\n          { where: { id: args.id } }\r\n        );\r\n        if (updateCount === 0) {\r\n          throw new Error('User not found or nothing to update');\r\n        }\r\n        return { success: true, message: `User info updated successfully` };\r\n      } catch (error) {\r\n        return { success: false, message: `Error updating user: ${error.message}` };\r\n      }\r\n    },\r\n\r\n\r\n    deleteUser: async (_, { id }) => {\r\n      try {\r\n        const user = await User.findByPk(id);\r\n        if (!user) throw new Error(\"User not found\");\r\n        const del = await User.destroy({ where: { id } });\r\n        if (!del) throw new Error(\"Deletion not successful\");\r\n        return { success: true, message: \"User info deleted successfully.\" };\r\n      } catch (error) {\r\n        return { success: false, message: `Error deleting user: ${error.message}` };\r\n      }\r\n    },\r\n\r\n\r\n  }\r\n};\r\n"
        }
    ]
}